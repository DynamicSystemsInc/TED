#!/bin/ksh -p

#
# Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
#

. /usr/lib/brand/solaris/common.ksh

# Allows developers to override some things like PATH and PYTHONPATH
. /usr/lib/brand/solaris/developerenv.ksh

f_a_obs=$(gettext "-a publisher=uri option is obsolete.")
f_mktemp=$(gettext "Unable to make temporary filename.")
f_aimanifest_add=$(gettext "Unable to aimanifest add.")
f_aimanifest_get=$(gettext "Unable to aimanifest get.")
f_autoinstall=$(gettext "auto-install failed.  AI manifest %s preserved.")
f_nolabel=$(gettext "A label must be assigned before installing.")
m_ai_running=$(gettext "Running auto-install: '%s'")

m_image=$(gettext       "       Image: Preparing at %s.")

m_usage=$(gettext "\n\tinstall [-h]
\tinstall [-m manifest] [-c profile.xml | dir]
\tinstall -a unified_archive [-z archived_zone] {-p|-u} [-U] [-s|-v] [-c profile.xml | dir] [-x {cert|key|ca-cert}=path]")

m_done=$(gettext      " done.")

trap_cleanup() {
	gtprint "$m_interrupt"
	fini_tmpdir

	exit $EXIT_CODE
}

trap_exit() {
	if [[ $EXIT_CODE == @($ZONE_SUBPROC_FATAL|$ZONE_SUBPROC_TRYAGAIN) ]]
	then
	    # If install fails, uninstall so user can try again.
	    /usr/lib/brand/solaris/uninstall "${zone.name}" "${zone.path}"
	    if (( $? == 0 )); then
	        EXIT_CODE=$ZONE_SUBPROC_TRYAGAIN
	    fi
	fi

	fini_tmpdir

	vlog "Exiting with exit code $EXIT_CODE"
	finish_log zone
	exit $EXIT_CODE
}

EXIT_CODE=$ZONE_SUBPROC_TRYAGAIN
trap trap_cleanup INT

# Used by start_log()
set -A save_args "$0" "$@"

manifest=""
profile_dir=""
ZONENAME=""
ZONEPATH=""

# Setup i18n output
TEXTDOMAIN="solaris_lib_brand"
export TEXTDOMAIN

PKG=pkg

unset silent_mode
unset verbose_mode
unset sc_config
unset temp_manifest
unset labeled_scprofile
unset archived_zone
unset archive
allow_updates=min
typeset -a xopts

#
# The user may pick -u (configure) or -p (preserve config) for a unified
# archive install.  Recovery archive defaults to -p (preserve) unless -u
# is specified.  The clone archive is unconfigured in the archive so -u/-p
# are ignored and the -c option drives whether the zone is configured.
# The -p option cannot be used with the -u option, but is ignored otherwise
# for unified archives.
#
unset unconfig_zone
unset preserve_zone

while getopts ":a:c:hm:pR:suUx:vz:Z:" opt; do
	case $opt in
	a)	archive=$(mk_abs_path "$OPTARG")
		# We're expecting a path to an archive
		if [[ ! -f $archive ]]; then
		# If old style 'pub=uri' parameter then error.
			echo "$archive" | egrep -s =
			if (( $? == 0 )); then
				fail_usage "$f_a_obs"
			fi
		fi
		;;
	c)	OPTARG=$(mk_abs_path $OPTARG)
		ls "$OPTARG" >/dev/null 2>&1
		[[ -f $OPTARG ]] || [[ -d $OPTARG ]] || fatal "$f_arg_not_file_or_dir" "$OPTARG"
		sc_config="$OPTARG" ;;
	h)	fail_usage "";;
	m)	manifest="$(mk_abs_path $OPTARG)" ;;
	p)	preserve_zone="-p";;
	R)	ZONEPATH="$OPTARG" ;;
	s)	silent_mode=1;;
	u)	unconfig_zone="-u";;
	U)	allow_updates=all;;
	v)	verbose_mode="-v";;
	x)	xopts+=( $OPTARG );;
	Z)	if [[ -n $ZONENAME ]]; then
			# If 'install -a archive -z archived_zone' is
			# fat-fingered to use -Z rather than -z, we will end
			# up here.
			fail_usage ""
		fi
		ZONENAME="$OPTARG"
		;;
	z)	archived_zone=$OPTARG ;;
	*)	if [[ $OPTARG == '?' ]]; then
			fail_usage ""
		else
			fail_usage "$unknown_opt" "$OPTARG"
		fi
		;;
	esac
done
shift $((OPTIND-1))

if [[ -z $ZONEPATH || -z $ZONENAME ]]; then
	print -u2 "Brand error: No zone path or name"
	exit $ZONE_SUBPROC_USAGE
fi
zone=
init_zone zone "$ZONENAME" "$ZONEPATH"
eval $(bind_legacy_zone_globals zone)

# Check whether the zone has existing zone BEs and if so, suggest either trying
# to re-attach the zone or marking it incomplete and uninstalling it first.
if has_bes zone; then
	log "$f_reattach_or_uninstall_install"
	EXIT_CODE=$ZONE_SUBPROC_TRYAGAIN
	exit $EXIT_CODE
fi

is_brand_labeled
brand_labeled=$?
if (( $brand_labeled == 0 )); then
	. /usr/lib/brand/labeled/common.ksh
fi

check_sc_config "$sc_config"

# The install can't be both verbose AND silent...
[[ -n $silent_mode && -n $verbose_mode ]] && \
    fail_usage "$f_incompat_options" "-s" "-v"

# The install can't both preserve and unconfigure
[[ -n $unconfig_zone && -n $preserve_zone ]] && \
    fail_usage "$f_incompat_options" "-u" "-p"

if [[ -n $archive ]]; then
	# AI zone manifest option isn`t allowed when installing from an archive
	[[ -n "$manifest" ]] && fail_usage \
	    "$f_incompat_options" "-a" "-m"

	typeset -A zone.xopts=([cert]= [ca-cert]= [key]=)
	for xopt in "${xopts[@]}"; do
		process_xopt zone.xopts "$xopt"
	done
else
	# Only -x options are with -a archive
	(( ${#xopts[*]} == 0 )) || fail_usage ""
fi

# Install can't use -z without -a.
if [[ -n "$archived_zone" && -z "$archive" ]]; then
	fail_usage "$f_int_missing_opt" "a"
fi

start_log zone install "${save_args[@]}"
trap trap_exit EXIT

#
# Look for the 'entire' incorporation's FMRI in the current image; due to users
# doing weird machinations with their publishers, we strip off the publisher
# from the FMRI if it is present.
# It's ok to not find entire in the current image, since this means the user
# can install pre-release development bits for testing purposes.
#
entire_fmri=$(get_entire_incorp)

log "$m_image\n" $ZONEROOT

enable_zones_services 1
if (( $? != 0 )); then
	EXIT_CODE=$ZONE_SUBPROC_TRYAGAIN
	exit $EXIT_CODE
fi

integer ua_deployment=0
zone.ua_archived_zone=${archived_zone:-}

if [[ -n $archive ]]; then
	# Create an AI manifest
	prep_ua_manifest zone "$archive" manifest || exit $EXIT_CODE
	create_zone_rpool -er zone || exit $EXIT_CODE
fi

if [[ -n $manifest ]]; then
        AIM_MANIFEST=$manifest \
	    aimanifest get /auto_install/ai_instance/software[@type=ARCHIVE] \
	    >/dev/null 2>&1
	if (( $? == 0 )); then
		ua_deployment=1
	fi

        if (( ua_deployment == 1 )); then
                # If the software type is ARCHIVE, read the archive information.
                # It will be needed later to determine what type of archive
		# is being deployed.
                typeset -A uar_props
                export AIM_MANIFEST=$manifest
                typeset archive_loc=$(aimanifest get \
		    "/auto_install/ai_instance/software[@type=ARCHIVE]/source/file@uri")
		if [[ -z $archive_loc ]]; then
			gtprint "$f_aimanifest_get: No archive source found in"
			print "$manifest"
			exit $ZONE_SUBPROC_TRYAGAIN
		fi
                typeset -A zone.xopts=([cert]= [ca-cert]= [key]=)
		
		#
		# Manifest file specifies a unified archive at an https
		# uri. We need to load the necessary certificates and/or
		# key.
		#
		if [[ "$archive_loc" == https:* ]]; then
			init_tmpdir
			load_xopt "$manifest" zone.xopts "$TMPDIR"
		fi
                read_uar_info "$archive_loc" zone.xopts uar_props ||
		    exit $ZONE_SUBPROC_TRYAGAIN
                uar_creator=${!uar_props[archive][*]}
        fi
else
	# Use default AI zone manifest if none is given
	manifest=/usr/share/auto_install/manifest/zone_default.xml
fi

#
# So long as this is not a unified archive deployment:
#   - Add packages to AI zone manifest for TX zones if appropriate.
#   - Add entire package if installed in GZ
#
# The environment variable AIM_MANIFEST contains the file where all the
# aimanifest changes will be made.  The load operation loads that manifest
# into the working file.  The add operation adds the entries to the
# working file.
#
if (( ua_deployment == 0 )) && 
    ( (( brand_labeled == 0 )) || [[ -n $entire_fmri ]] ); then
	temp_manifest=$(mktemp -t manifest.xml.XXXXXX)
	if [[ -z $temp_manifest ]]; then
		gtprint "$f_mktemp"
		exit $ZONE_SUBPROC_TRYAGAIN
	fi
	export AIM_MANIFEST=$temp_manifest
	aimanifest load $manifest
	if (( $? != 0 )); then
		gtprint "$f_aimanifest_load"
		exit $ZONE_SUBPROC_TRYAGAIN
	fi
	if (( $brand_labeled == 0 )); then
		primary=$(tncfg -z $ZONENAME info primary 2>/dev/null)
		if [ $? != 0 ]; then
			gtprint "$f_nolabel"
			exit $ZONE_SUBPROC_TRYAGAIN
		elif [ $primary = "primary=yes" ]; then
			labeled_pkg=pkg:/group/feature/trusted-desktop2
		else
			labeled_pkg=pkg:/system/trusted
		fi
		aimanifest add \
		    /auto_install/ai_instance/software/software_data[@action="install"]/name \
	            $labeled_pkg
		if (( $? != 0 )); then
			gtprint "$f_aimanifest_add"
			exit $ZONE_SUBPROC_TRYAGAIN
		fi
	fi
	if [[ -n $entire_fmri ]]; then
		aimanifest add \
		    /auto_install/ai_instance/software/software_data[@action="install"]/name \
		    pkg:///$entire_fmri
		if (( $? != 0 )); then
			gtprint "$f_aimanifest_add"
			exit $ZONE_SUBPROC_TRYAGAIN
		fi
	fi
	manifest=$temp_manifest
fi

#
# Before installing the zone, set up ZFS dataset for the zone root dataset,
# but don't create rpool/ROOT or rpool/export hierarchies since installer
# will create them.  Sets EXIT_CODE if datasets are created.
#
create_active_ds -r zone || fatal "$f_no_ds"

#
# Set up the AI install. Check to see if the installation includes
# a recovery archive, and do not use enable_sci.xml if it is.
# If it is a clone archive, then including enable_sci.xml is appropriate.
#
# If unconfig service is online, then call auto-install with the default
# profile or with the caller supplied profile.
# If unconfig service is offline or doesn't exist, then don't pass
# any profile to auto-install since this will cause SCI tool to start in
# zone on boot.  Previous sysconfig method handled below after install.
#
aisc=""
SC_ONLINE=$(svcprop -p restarter/state \
    svc:/milestone/unconfig:default 2> /dev/null)
set -A aicmd /usr/lib/install/auto-install -z "$ZONENAME" \
    -Z "${zone.rpool_ds}" -m "$manifest"
if (( $? == 0 )) && [[ $SC_ONLINE == "online" ]]; then
	if [[ -n $sc_config ]]; then
		a_push aicmd -c "$sc_config"
		aisc=$sc_config
	elif (( $brand_labeled == 0 )); then
		labeled_makeSCprofile
		a_push aicmd -c "$labeled_scprofile"
		aisc=$labeled_scprofile
	elif (( ua_deployment == 0 )) ||
		[[ ${uar_props[archive][$uar_creator][recovery]} == No ]]; then
		aisc=/usr/share/auto_install/sc_profiles/enable_sci.xml
		a_push aicmd -c "$aisc"
	fi
fi

#
# Run auto-install, saving the output in the log file.
#
vlog "$m_ai_running" "${aicmd[*]}"
"${aicmd[@]}" || fail_fatal "$f_autoinstall" "$manifest"

if [[ -n $temp_manifest ]]; then
	rm $temp_manifest
fi

mount_active_be -c zone || fail_fatal "$f_mount_active_be"

# If archive install, call zoneattach to attach the image and 
# apply_sysconfig. On failure, leave zone in unavailable state.
# Then, reconfigure zone for a recovery archive if -u was given.
# Clone archive sysconfig was handled above.
if (( ua_deployment == 1 )); then
	# args for zoneattach
	typeset -A attach_args
	set -A attach_args -- -z "${zone.name}" -r "${zone.root}" \
	    -l "$LOGFILE" -u "$allow_updates"
	if [[ -n $verbose_mode ]]; then
		a_push attach_args -v
	fi
	if [[ -n $aisc ]]; then
		a_push attach_args -p "$aisc"
	fi
	/usr/lib/brand/solaris/zoneattach "${attach_args[@]}"
	rc=$?
	if (( rc != 0 )); then
		EXIT_CODE=$rc
		exit $EXIT_CODE
	fi

	if [[ ${uar_props[archive][$uar_creator][recovery]} == Yes &&
	     -n $unconfig_zone ]]; then
		# If sc_config is not set, the zone is unconfigured
		reconfigure_zone "$sc_config"
	fi
fi

# brand_labeled zone support directory of profiles.
if [[ -n $labeled_scprofile && -d $labeled_scprofile ]]; then
	# Remove the directory of profiles
	rm -rf $labeled_scprofile
fi

log "$m_done\n"

log "$m_complete_seconds\n\n" ${SECONDS}
if (( $brand_labeled != 0 )); then
	log "$m_postnote\n"
else
	labeled_configure
fi

fini_tmpdir

finish_log zone
trap - EXIT
exit $ZONE_SUBPROC_OK
