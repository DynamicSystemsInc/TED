--- marco-1.22.1/src/Makefile.am	2019-12-19 13:48:55.280313040 +0000
+++ marco-1.22.1/src/Makefile.am	2019-12-19 13:49:33.914199785 +0000
@@ -11,6 +11,7 @@
 	-DMARCO_DATADIR=\"$(datadir)\" \
 	-DG_LOG_DOMAIN=\"marco\" \
 	-DSN_API_NOT_YET_FROZEN=1 \
+	-DHAVE_XTSOL \
 	@MARCO_CFLAGS@
 
 marco_SOURCES = \
@@ -105,6 +106,9 @@
 	ui/theme.c \
 	ui/theme.h \
 	ui/ui.c \
+	core/trusted.c \
+	core/trusted.h \
+	core/trusted-pics.h \
 	include/all-keybindings.h
 
 # by setting libmarco_private_la_CFLAGS, the files shared with
@@ -147,7 +151,48 @@
 EFENCE=
 marco_LDADD=@MARCO_LIBS@ $(EFENCE)
 
-marco_theme_viewer_LDADD= @MARCO_LIBS@ libmarco-private.la
+marco_theme_viewer_LDADD= @MARCO_LIBS@ libmarco-private.la \
+	core/async-getprop.o \
+	core/bell.o \
+	core/boxes.o \
+	compositor/compositor.o \
+	compositor/compositor-xrender.o \
+	core/constraints.o \
+	core/core.o \
+	core/delete.o \
+	core/display.o \
+	ui/draw-workspace.o \
+	core/edge-resistance.o \
+	core/effects.o \
+	core/errors.o \
+	core/eventqueue.o \
+	core/frame.o \
+	ui/gradient.o \
+	core/group-props.o \
+	core/group.o \
+	core/iconcache.o \
+	core/keybindings.o \
+	core/place.o \
+	core/prefs.o \
+	core/screen.o \
+	core/session.o \
+	core/stack.o \
+	core/util.o \
+	core/window-props.o \
+	core/window.o \
+	core/workspace.o \
+	core/xprops.o \
+	ui/fixedtip.o \
+	ui/frames.o \
+	ui/menu.o \
+	ui/metaaccellabel.o \
+	ui/resizepopup.o \
+	ui/tabpopup.o \
+	ui/tile-preview.o \
+	ui/theme-parser.o \
+	ui/theme.o \
+	ui/ui.o \
+	core/trusted.o
 
 testboxes_SOURCES=include/util.h core/util.c include/boxes.h core/boxes.c core/testboxes.c
 testgradient_SOURCES=ui/gradient.h ui/gradient.c ui/testgradient.c
diff -ur marco-1.22.1/src/core/display-private.h marco-1.22.1/src/core/display-private.h
--- marco-1.22.1/src/core/display-private.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/display-private.h	2019-09-12 22:06:00.631162567 +0000
@@ -25,9 +25,11 @@
 #ifndef META_DISPLAY_PRIVATE_H
 #define META_DISPLAY_PRIVATE_H
 
+#if 0
 #ifndef PACKAGE
 	#error "config.h not included"
 #endif
+#endif
 
 #include <glib.h>
 #include <X11/Xlib.h>
@@ -132,6 +134,9 @@
 	guint error_trap_synced_at_last_pop: 1;
 	MetaEventQueue* events;
 	GSList* screens;
+#ifdef HAVE_XTSOL
+	GSList *labels;
+#endif
 	MetaScreen* active_screen;
 	GHashTable* window_ids;
 	int error_traps;
diff -ur marco-1.22.1/src/core/display.c marco-1.22.1/src/core/display.c
--- marco-1.22.1/src/core/display.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/display.c	2019-10-07 17:13:36.157814326 +0000
@@ -87,6 +87,9 @@
 #include <gdk/gdkx.h>
 
 #include <string.h>
+#ifdef HAVE_XTSOL
+#include "trusted.h"
+#endif
 
 #define GRAB_OP_IS_WINDOW_SWITCH(g)                     \
         (g == META_GRAB_OP_KEYBOARD_TABBING_NORMAL  ||  \
@@ -426,7 +429,11 @@
 
   the_display->screens = NULL;
   the_display->active_screen = NULL;
-
+  
+#ifdef HAVE_XTSOL
+  the_display->labels = NULL;
+#endif
+  
 #ifdef HAVE_STARTUP_NOTIFICATION
   the_display->sn_display = sn_display_new (the_display->xdisplay,
                                         sn_error_trap_push,
@@ -1997,7 +2004,10 @@
         meta_window_handle_mouse_grab_op_event (window, event);
       break;
     case EnterNotify:
-      if (display->grab_window == window &&
+#ifdef HAVE_XTSOL
+        tsol_trusted_stripe_atom_update (display, window);
+#endif      
+	if (display->grab_window == window &&
           grab_op_is_mouse (display->grab_op))
         {
           meta_window_handle_mouse_grab_op_event (window, event);
@@ -2089,6 +2099,9 @@
         }
       break;
     case LeaveNotify:
+#ifdef HAVE_XTSOL
+      tsol_trusted_stripe_atom_update (display, window);
+#endif
       if (display->grab_window == window &&
           grab_op_is_mouse (display->grab_op))
         meta_window_handle_mouse_grab_op_event (window, event);
@@ -2379,6 +2392,14 @@
             else if (event->xproperty.atom ==
                      display->atom__NET_DESKTOP_NAMES)
               meta_screen_update_workspace_names (screen);
+ #ifdef HAVE_XTSOL	    
+             else if (event->xproperty.atom ==
+                      display->atom__NET_DESKTOP_LABELS)
+               tsol_workspace_labels_gconf_update (screen);
+             else if (event->xproperty.atom ==
+                      display->atom__NET_DESKTOP_ROLES)
+               tsol_workspace_roles_gconf_update (screen);
+ #endif /*HAVE_XTSOL */	  	    
 #if 0
             else if (event->xproperty.atom ==
                      display->atom__NET_RESTACK_WINDOW)
diff -ur marco-1.22.1/src/core/frame.c marco-1.22.1/src/core/frame.c
--- marco-1.22.1/src/core/frame.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/frame.c	2019-10-19 09:44:47.881220137 +0000
@@ -28,6 +28,9 @@
 #include "bell.h"
 #include "errors.h"
 #include "keybindings.h"
+#ifdef HAVE_XTSOL
+#include "trusted.h"
+#endif
 
 #ifdef HAVE_RENDER
 #include <X11/extensions/Xrender.h>
@@ -156,6 +159,20 @@
                              window->frame->xwindow,
                              window->title);
 
+ #ifdef HAVE_XTSOL
+  if (tsol_is_available ()) {
+	  /* associate trusted label with the window only if a frame exist */
+	  meta_ui_set_frame_label (window->screen->ui,
+				   window->frame->xwindow,
+				   tsol_meta_window_label_get (window));
+
+	  /* make sure the frame window as the same privileges
+	   * "real" window */
+	  tsol_set_frame_label (window->display->xdisplay, window->xwindow, window->frame->xwindow);
+  }
+#endif
+
+
   /* Move keybindings to frame instead of window */
   meta_window_grab_keys (window);
 
diff -ur marco-1.22.1/src/core/keybindings.c marco-1.22.1/src/core/keybindings.c
--- marco-1.22.1/src/core/keybindings.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/keybindings.c	2019-10-07 17:13:36.158150094 +0000
@@ -27,6 +27,7 @@
 #define _XOPEN_SOURCE /* for putenv() */
 
 #include <config.h>
+#include <gdk/gdkx.h>
 #include "keybindings.h"
 #include "workspace.h"
 #include "errors.h"
@@ -49,6 +50,10 @@
 #include <X11/XKBlib.h>
 #endif
 
+#ifdef HAVE_XTSOL
+#include "trusted.h"
+#endif
+
 static gboolean all_bindings_disabled = FALSE;
 
 typedef void (* MetaKeyHandlerFunc) (MetaDisplay    *display,
@@ -2429,6 +2434,42 @@
                            NULL, &argv,
                            error))
     return FALSE;
+  #ifdef HAVE_XTSOL
+  if (tsol_is_available ())
+    {
+      GdkDisplay *dpy;
+      Display *xdpy;
+      Window root;
+      Atom atom, utf8_string;
+      gchar* tsol_command =  g_strdup_printf ("%d:%s",
+                                              screen->number,
+                                              command_line);
+
+      dpy = gdk_display_get_default ();
+      xdpy = GDK_DISPLAY_XDISPLAY (dpy);
+
+      utf8_string = XInternAtom (xdpy, "UTF8_STRING", FALSE);
+
+      root = DefaultRootWindow (xdpy);
+
+      atom = XInternAtom (xdpy, "_LABEL_EXEC_COMMAND", FALSE);
+
+      gdk_error_trap_push ();
+
+      XChangeProperty (xdpy, root, atom, utf8_string, 8, PropModeReplace,
+                       (const unsigned char *)tsol_command, strlen (tsol_command));
+
+      XSync (xdpy, False);
+
+      gdk_error_trap_pop ();
+
+      g_free (tsol_command);
+
+      retval = TRUE;
+    }
+  else
+#endif /* HAVE_XTSOL */
+    {
 
   retval = g_spawn_async (NULL,
                           argv,
@@ -2439,7 +2480,7 @@
                           NULL,
                           error);
   g_strfreev (argv);
-
+    }
   return retval;
 }
 
diff -ur marco-1.22.1/src/core/main.c marco-1.22.1/src/core/main.c
--- marco-1.22.1/src/core/main.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/main.c	2019-10-07 17:13:36.158188465 +0000
@@ -49,6 +49,9 @@
 #include "util.h"
 #include "display-private.h"
 #include "errors.h"
+#ifdef HAVE_XTSOL
+#include "trusted.h"
+#endif
 #include "ui.h"
 #include "session.h"
 #include "prefs.h"
diff -ur marco-1.22.1/src/core/prefs.c marco-1.22.1/src/core/prefs.c
--- marco-1.22.1/src/core/prefs.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/prefs.c	2019-10-19 09:35:22.471733911 +0000
@@ -25,6 +25,11 @@
 
 #include <config.h>
 #include "prefs.h"
+#ifdef HAVE_XTSOL
+#include "trusted.h"
+#define HAVE_GCONF
+#include <gconf/gconf-client.h>
+#endif /* HAVE_XTSOL */
 #include "ui.h"
 #include "util.h"
 #include <gdk/gdk.h>
@@ -74,6 +79,12 @@
 #define KEY_MATE_MOUSE_CURSOR_THEME "cursor-theme"
 #define KEY_MATE_MOUSE_CURSOR_SIZE "cursor-size"
 
+#ifdef HAVE_XTSOL
+#define KEY_WORKSPACE_LABEL_PREFIX "/apps/metacity/workspace_labels/ws_"
+#define KEY_WORKSPACE_ROLE_PREFIX "/apps/metacity/workspace_roles/ws_"
+static GConfClient *default_client = NULL;
+#endif /* HAVE_XTSOL */
+
 #define SETTINGS(s) g_hash_table_lookup (settings_schemas, (s))
 
 static GSettings *settings_general;
@@ -135,6 +146,14 @@
 static char *terminal_command = NULL;
 
 static char *workspace_names[MAX_REASONABLE_WORKSPACES] = { NULL, };
+#ifdef HAVE_XTSOL
+/* these are only used for session managements
+ * workspace_labels are NOT used in metacity as the window label 
+ * is queried directly from the window
+ * ditto for the workspace_roles*/
+static char *workspace_labels[MAX_REASONABLE_WORKSPACES] = { NULL, };
+static char *workspace_roles[MAX_REASONABLE_WORKSPACES] = { NULL, };
+#endif /* HAVE_XTSOL */
 
 static gboolean handle_preference_update_enum (const gchar *key, GSettings *settings);
 
@@ -149,14 +168,25 @@
                            gchar *key,
                            gpointer user_data);
 
+#ifdef HAVE_XTSOL
+static void init_labels_roles_workspaces (void);
+static gboolean
+update_workspace_property (char **property,
+ 			   char *error_property_name,
+ 			   const char  *name,
+ 			   const char  *value);
+static char* gconf_key_for_workspace_label (int i);
+static char* gconf_key_for_workspace_role (int i);
+#ifdef HAVE_GCONF
+static void     cleanup_error             (GError **error);
+#endif
+
+#endif /*HAVE_XTSOL*/
+
 static char* settings_key_for_workspace_name (int i);
 
 static void queue_changed (MetaPreference  pref);
 
-#if 0
-static void     cleanup_error             (GError **error);
-#endif
-
 static void maybe_give_disable_workarounds_warning (void);
 
 static void titlebar_handler (MetaPreference, const gchar*, gboolean*);
@@ -768,6 +798,40 @@
 
   if (*cursor->target != value)
     {
+#ifdef HAVE_XTSOL
+      if (cursor->pref == META_PREF_NUM_WORKSPACES && tsol_use_trusted_extensions ())
+	{
+	  if (*cursor->target > value) /* remove a workspace blank label and role */
+	    {
+	      GError *err = NULL;
+	      char *key = gconf_key_for_workspace_label (value);
+	      gconf_client_unset (default_client,
+				  key, &err);
+	      update_workspace_property (workspace_labels,"Workspace Label",
+					 key, NULL);
+
+	      g_free (key);
+	      err = NULL;
+	      key = gconf_key_for_workspace_role (value);
+	      gconf_client_unset (default_client,
+				  key, &err);
+	      update_workspace_property (workspace_roles ,"Workspace roles",
+					 key, NULL);
+	      g_free (key);
+	    }
+	  else if (value > *cursor->target)	   /* add a workspace add default label, blank role */
+	    {
+	      GError *err = NULL;
+	      char *key = gconf_key_for_workspace_role (value-1);
+	      gconf_client_unset (default_client,
+				  key, &err);
+	      update_workspace_property (workspace_roles ,"Workspace roles",
+					 key, NULL);
+	      g_free (key);
+	      meta_prefs_change_workspace_label (value, tsol_label_get_min ());
+	    }
+	}
+#endif /* HAVE_XTSOL */  
       *cursor->target = value;
       queue_changed (cursor->pref);
     }
@@ -902,7 +966,7 @@
 {
   if (settings_general != NULL)
     return;
-
+  
   /* returns references which we hold forever */
   settings_general = g_settings_new (KEY_GENERAL_SCHEMA);
   settings_command = g_settings_new (KEY_COMMAND_SCHEMA);
@@ -946,6 +1010,12 @@
   init_window_bindings ();
   init_commands ();
   init_workspace_names ();
+  
+#ifdef HAVE_XTSOL
+  /* tsol labels and roles */
+  init_labels_roles_workspaces ();
+#endif /* HAVE_XTSOL */  
+  
 }
 
 /****************************************************************************/
@@ -1016,16 +1086,115 @@
 
       g_free(str);
     }
+ #ifdef HAVE_XTSOL
+   else if (g_str_has_prefix (key, KEY_WORKSPACE_LABEL_PREFIX))
+    {
+      const char *str;
+ 
+      if (!tsol_use_trusted_extensions ())
+        goto out;
+ 
+      /*
+	 GLENN
+      if (user_data && user_data->type != GCONF_VALUE_STRING)
+        {
+          meta_warning (_("GConf key \"%s\" is set to an invalid type\n"),
+                        key);
+          goto out;
+        }
+      */
+ 
+      str = user_data ? gconf_value_get_string (user_data) : NULL;
+ 
+      /* Check if the label is in range if not set it to USER_MIN_SL or role MIN label 
+       * NOTE : if USER_MIN_SL is not properly set you can have an infinite loop here */
+ 
+      if (str && !tsol_label_is_in_user_range (str))
+        {
+ 	 char *p; /* code from update_workspace_property */
+ 	 int i;
+ 	 
+ 	 p = strrchr (key, '_');
+ 	 if (p != NULL)
+ 	   {
+ 	     ++p;
+ 	     if (g_ascii_isdigit (*p))
+ 	       {
+ 		 i = atoi (p);
+ 		 i -= 1; /* count from 0 not 1 */
+ 		 
+ 		 if (i >= MAX_REASONABLE_WORKSPACES)
+ 		   {
+ 		     meta_topic (META_DEBUG_PREFS,
+ 				 "%s key %d is too highly numbered, ignoring\n", 
+ 				 "trusted workspace label", i);
+ 		   }
+ 		 else
+ 		   {
+ 		     char *name, *role_key;
+ 		     GError *err = NULL;
+ 		     role_key = gconf_key_for_workspace_role (i);
+ 		     name = gconf_client_get_string (default_client, role_key, &err);
+ 		     cleanup_error (&err);
+ 		     g_free (role_key);
+ 
+ 		     if (name)
+ 		       {
+ 			 char *min_role_label = NULL;
+ 			 if (!tsol_label_is_in_role_range (str, name, min_role_label))
+ 			   {
+ 			     if (min_role_label)
+ 			       meta_prefs_change_workspace_label (i, min_role_label);
+ 			     else
+ 			       meta_prefs_change_workspace_label (i, tsol_label_get_min ());
+ 			   }
+ 			 g_free (name);
+ 		       }
+ 		     else
+ 		       meta_prefs_change_workspace_label (i, tsol_label_get_min ());
+ 
+ 		   }
+ 	       }
+ 	   }
+        }
+ 
+      if (update_workspace_property (workspace_labels,"Workspace Label", key, str))
+        queue_changed (META_PREF_WORKSPACE_LABELS);
+    }
+   else if (g_str_has_prefix (key, KEY_WORKSPACE_ROLE_PREFIX))
+    {
+      const char *str;
+      
+      if (!tsol_use_trusted_extensions ())
+        goto out;
+ 
+      /*
+       * GLENN
+      if (value && value->type != GCONF_VALUE_STRING)
+        {
+          meta_warning (_("GConf key \"%s\" is set to an invalid type\n"),
+                        key);
+          goto out;
+        }
+      */
+ 
+      str = user_data ? gconf_value_get_string (user_data) : NULL;
+ 
+      if (update_workspace_property (workspace_roles ,"Workspace roles", key, str))
+        queue_changed (META_PREF_WORKSPACE_ROLES);
+    }
+ #endif /*HAVE_XTSOL*/
   else
     {
       /* Is this possible with GSettings? I dont think so! */
       meta_topic (META_DEBUG_PREFS, "Key %s doesn't mean anything to Marco\n",
                   key);
     }
+out:
   g_free (schema_name);
 }
 
-#if 0
+#ifdef HAVE_GCONF
 static void
 cleanup_error (GError **error)
 {
@@ -1652,6 +1821,16 @@
 
     case META_PREF_SHOW_DESKTOP_SKIP_LIST:
       return "SHOW_DESKTOP_SKIP_LIST";
+
+#ifdef HAVE_XTSOL
+    case META_PREF_WORKSPACE_LABELS:
+      return "WORKSPACE_LABELS";
+
+    case META_PREF_WORKSPACE_ROLES:
+      return "WORKSPACE_ROLES";
+
+#endif /*HAVE_XTSOL*/     
+    
     }
 
   return "(unknown)";
@@ -1730,9 +1909,53 @@
       update_command (*list, str_val);
       list++;
     }
+}
 
-  g_free (str_val);
+#ifdef HAVE_XTSOL
+ static void init_labels_roles_workspaces (void)
+ {
+#ifdef HAVE_GCONF
+   int i;
+   GError *err;
+
+   default_client = gconf_client_get_default();
+   if (!tsol_use_trusted_extensions ())
+     return;
+
+   i = 0;
+   while (i < MAX_REASONABLE_WORKSPACES)
+     {
+       char *str_val;
+       char *label_key, *role_key;
+
+       label_key = gconf_key_for_workspace_label (i);
+
+       err = NULL;
+       str_val = gconf_client_get_string (default_client, label_key, &err);
+       cleanup_error (&err);
+
+       update_workspace_property (workspace_labels,"Workspace Label",
+                                  label_key, str_val);
+
+       g_free (str_val);
+       g_free (label_key);
+
+       role_key = gconf_key_for_workspace_role (i);
+
+       err = NULL;
+       str_val = gconf_client_get_string (default_client, role_key, &err);
+       cleanup_error (&err);
+       update_workspace_property (workspace_roles ,"Workspace roles",
+				 role_key, str_val);
+
+      g_free (str_val);    
+      g_free (role_key);
+
+      ++i;
+    }
+#endif /* HAVE_GCONF */
 }
+#endif /* HAVE_XTSOL */
 
 static void
 init_workspace_names (void)
@@ -2024,13 +2247,79 @@
   return KEY_MATE_TERMINAL_COMMAND;
 }
 
+#ifdef HAVE_GCONF
+#ifdef HAVE_XTSOL
+static gboolean
+update_workspace_property (char **property,
+			   char *error_property_name,
+			   const char  *name,
+			   const char  *value)
+{
+  char *p;
+  int i;
+
+  if (!tsol_use_trusted_extensions ())
+    return FALSE;
+  
+  p = strrchr (name, '_');
+  if (p == NULL)
+    {
+      meta_topic (META_DEBUG_PREFS,
+                  "%s name %s has no underscore?\n", error_property_name, name);
+      return FALSE;
+    }
+  
+  ++p;
+
+  if (!g_ascii_isdigit (*p))
+    {
+      meta_topic (META_DEBUG_PREFS,
+                  "%s name %s doesn't end in number?\n", 
+		  error_property_name, name);
+      return FALSE;
+    }
+  
+  i = atoi (p);
+  i -= 1; /* count from 0 not 1 */
+  
+  if (i >= MAX_REASONABLE_WORKSPACES)
+    {
+      meta_topic (META_DEBUG_PREFS,
+                  "%s name %d is too highly numbered, ignoring\n", 
+		  error_property_name, i);
+      return FALSE;
+    }
+
+  if (property[i] && value && strcmp (property[i], value) == 0)
+    {
+      meta_topic (META_DEBUG_PREFS,
+                  "%s name %d is unchanged\n", error_property_name, i);
+      return FALSE;
+    }  
+
+  if (value != NULL && *value != '\0')
+    {
+      g_free (property[i]);
+      property[i] = g_strdup (value);
+    }
+  else
+    {
+      g_free (property[i]);
+      property[i] = NULL;
+    }
+  
+  return TRUE;
+}
+#endif /* HAVE_XTSOL */
+#endif /* HAVE_GCONF */
+
 static gboolean
 update_workspace_name (const char  *name,
                        const char  *value)
 {
   char *p;
   int i;
-
+  
   p = strrchr (name, '-');
   if (p == NULL)
     {
@@ -2038,7 +2327,8 @@
                   "Workspace name %s has no dash?\n", name);
       return FALSE;
     }
-
+  
+  ++p;
   ++p;
 
   if (!g_ascii_isdigit (*p))
@@ -2100,14 +2390,156 @@
 
   return TRUE;
 }
+#ifdef HAVE_XTSOL
+const char* meta_prefs_get_workspace_label    (int         i)
+{
+  g_return_val_if_fail (i >= 0 && i < MAX_REASONABLE_WORKSPACES, NULL);
+
+  if (!tsol_use_trusted_extensions ())
+    return NULL;
+
+  return workspace_labels [i];
+}
+void        
+meta_prefs_change_workspace_label (int         i,
+				   const char *name)
+{
+#ifdef HAVE_GCONF
+  char *key;
+  GError *err;
+  
+  g_return_if_fail (i >= 0 && i < MAX_REASONABLE_WORKSPACES);
+
+  if (!tsol_use_trusted_extensions ())
+    return;
+
+  meta_topic (META_DEBUG_PREFS,
+              "Changing name of workspace_labels %d to %s\n",
+              i, name ? name : "none");
+
+  /* This is a bad hack. We have to treat empty string as
+   * "unset" because the root window property can't contain
+   * null. So it gets empty string instead and we don't want
+   * that to result in setting the empty string as a value that
+   * overrides "unset".
+   */
+  if (name && *name == '\0')
+    name = NULL;
+  
+  if ((name == NULL && workspace_labels [i] == NULL) ||
+      (name && workspace_labels[i] && strcmp (name, workspace_labels[i]) == 0))
+    {
+      meta_topic (META_DEBUG_PREFS,
+                  "Workspace label %d already has name %s\n",
+                  i, name ? name : "none");
+      return;
+    }
+  
+  key = gconf_key_for_workspace_label (i);
+
+  err = NULL;
+  if (name != NULL)
+    gconf_client_set_string (default_client,
+                             key, name,
+                             &err);
+  else
+    gconf_client_unset (default_client,
+                        key, &err);
+
+  
+  if (err)
+    {
+      meta_warning (_("Error setting name for workspace label %d to \"%s\": %s\n"),
+                    i, name ? name : "none",
+                    err->message);
+      g_error_free (err);
+    }
+
+  update_workspace_property (workspace_labels,"Workspace Label",
+			     key, name);
+  
+  g_free (key);
+#endif /* HAVE_GCONF */
+}
+
+
+const char* meta_prefs_get_workspace_role    (int         i)
+{
+  g_return_val_if_fail (i >= 0 && i < MAX_REASONABLE_WORKSPACES, NULL);
+
+  if (!tsol_use_trusted_extensions ())
+    return NULL;
+
+  return workspace_roles [i];
+}
+
+void        meta_prefs_change_workspace_role (int         i,
+                                              const char *name)
+{
+#ifdef HAVE_GCONF
+  char *key;
+  GError *err;
+  
+  g_return_if_fail (i >= 0 && i < MAX_REASONABLE_WORKSPACES);
+ 
+  if (!tsol_use_trusted_extensions ())
+    return;
+
+  meta_topic (META_DEBUG_PREFS,
+              "Changing name of workspace_roles %d to %s\n",
+              i, name ? name : "none");
+
+  /* This is a bad hack. We have to treat empty string as
+   * "unset" because the root window property can't contain
+   * null. So it gets empty string instead and we don't want
+   * that to result in setting the empty string as a value that
+   * overrides "unset".
+   */
+  if (name && *name == '\0')
+    name = NULL;
+  
+  if ((name == NULL && workspace_roles [i] == NULL) ||
+      (name && workspace_roles [i] && strcmp (name, workspace_roles [i]) == 0))
+    {
+      meta_topic (META_DEBUG_PREFS,
+                  "Workspace role %d already has name %s\n",
+                  i, name ? name : "none");
+      return;
+    }
+  
+  key = gconf_key_for_workspace_role (i);
+
+  err = NULL;
+  if (name != NULL)
+    gconf_client_set_string (default_client,
+                             key, name,
+                             &err);
+  else
+    gconf_client_unset (default_client,
+                        key, &err);
+
+  
+  if (err)
+    {
+      meta_warning (_("Error setting name for workspace role %d to \"%s\": %s\n"),
+                    i, name ? name : "none",
+                    err->message);
+      g_error_free (err);
+    }
+  
+  g_free (key);
+#endif /* HAVE_GCONF */
+}
+#endif /* HAVE_XTSOL */
 
 const char*
 meta_prefs_get_workspace_name (int i)
 {
   g_return_val_if_fail (i >= 0 && i < MAX_REASONABLE_WORKSPACES, NULL);
 
+/*
   g_assert (workspace_names[i] != NULL);
-
+*/
   meta_topic (META_DEBUG_PREFS,
               "Getting workspace name for %d: \"%s\"\n",
               i, workspace_names[i]);
@@ -2163,6 +2595,27 @@
   return key;
 }
 
+#ifdef HAVE_XTSOL
+static char*
+gconf_key_for_workspace_label (int i)
+{
+  char *key;
+  
+  key = g_strdup_printf (KEY_WORKSPACE_LABEL_PREFIX"%d", i + 1);
+  
+  return key;
+}
+static char*
+gconf_key_for_workspace_role (int i)
+{
+  char *key;
+  
+  key = g_strdup_printf (KEY_WORKSPACE_ROLE_PREFIX"%d", i + 1);
+  
+  return key;
+}
+#endif /* HAVE_XTSOL */
+
 void
 meta_prefs_get_button_layout (MetaButtonLayout *button_layout_p)
 {
diff -ur marco-1.22.1/src/core/screen-private.h marco-1.22.1/src/core/screen-private.h
--- marco-1.22.1/src/core/screen-private.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/screen-private.h	2019-09-12 13:12:14.597552208 +0000
@@ -111,11 +111,13 @@
   /* Cache the current Xinerama */
   int last_xinerama_index;
 
+#if 0
 #ifdef HAVE_STARTUP_NOTIFICATION
   SnMonitorContext *sn_context;
   GSList *startup_sequences;
   guint startup_sequence_timeout;
 #endif
+#endif
 
 #ifdef HAVE_COMPOSITE_EXTENSIONS
   Atom wm_cm_atom;
diff -ur marco-1.22.1/src/core/screen.c marco-1.22.1/src/core/screen.c
--- marco-1.22.1/src/core/screen.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/screen.c	2019-10-07 17:13:36.158302003 +0000
@@ -64,6 +64,7 @@
 static void set_desktop_geometry_hint (MetaScreen *screen);
 static void set_desktop_viewport_hint (MetaScreen *screen);
 
+#undef HAVE_STARTUP_NOTIFICATION
 #ifdef HAVE_STARTUP_NOTIFICATION
 static void meta_screen_sn_event   (SnMonitorEvent *event,
                                     void           *user_data);
@@ -578,6 +579,17 @@
 
   set_workspace_names (screen);
 
+#ifdef HAVE_XTSOL
+  if (tsol_is_available ())
+    {
+      tsol_workspace_labels_atom_set (screen);
+      tsol_workspace_roles_atom_set (screen);
+      /* create a synch atom to indicate we are done setting up the
+         ws lables/roles */
+      XInternAtom (screen->display->xdisplay, "TX_WS_SETUP_DONE", FALSE);
+    }
+#endif /*HAVE_XTSOL */
+
   screen->all_keys_grabbed = FALSE;
   screen->keys_grabbed = FALSE;
   meta_screen_grab_keys (screen);
@@ -879,6 +891,16 @@
     {
       set_workspace_names (screen);
     }
+#ifdef HAVE_XTSOL
+  else if (pref == META_PREF_WORKSPACE_LABELS)
+    {
+      tsol_workspace_labels_atom_set (screen);
+    }
+  else if (pref == META_PREF_WORKSPACE_ROLES)
+    {
+      tsol_workspace_roles_atom_set (screen);
+    }
+#endif /*HAVE_XTSOL */
 }
 
 
@@ -1174,6 +1196,13 @@
     }
 
   set_number_of_spaces_hint (screen, new_num);
+#ifdef HAVE_XTSOL
+  if (tsol_is_available ())
+    {
+      tsol_workspace_labels_atom_set (screen);
+      tsol_workspace_roles_atom_set (screen);
+    }
+#endif /* HAVE_XTSOL */
 
   meta_screen_queue_workarea_recalc (screen);
 }
diff -ur marco-1.22.1/src/core/window-props.c marco-1.22.1/src/core/window-props.c
--- marco-1.22.1/src/core/window-props.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/window-props.c	2019-10-07 17:13:36.158566297 +0000
@@ -51,7 +51,7 @@
 #include <sys/types.h>
 #include <pwd.h>
 
-#ifdef HAVE_GTOP
+#ifdef HAVE_GTOPx
 #include <glibtop/procuid.h>
 #include <errno.h>
 #include <pwd.h>
@@ -394,7 +394,7 @@
 static gboolean
 owner_of_process (pid_t process, uid_t *result)
 {
-#ifdef HAVE_GTOP
+#ifdef HAVE_GTOPx
   glibtop_proc_uid process_details;
 
   glibtop_get_proc_uid (&process_details, process);
@@ -412,6 +412,11 @@
   /* I don't know, maybe we could do something hairy like see whether
    * /proc/$PID exists and who owns it, in case they have procfs.
    */
+  /* TODO
+   * open /proc/$PID/psinfo 
+   * read as typedef struct psinfo
+   * pr_uid pr pr_euid is of type uid_t
+   */
   return FALSE;
 #endif /* HAVE_GTOP */
 }
diff -ur marco-1.22.1/src/core/window.c marco-1.22.1/src/core/window.c
--- marco-1.22.1/src/core/window.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/window.c	2019-10-19 09:49:54.168693100 +0000
@@ -1355,14 +1355,6 @@
     }
 }
 
-gboolean
-meta_window_located_on_workspace (MetaWindow    *window,
-                                  MetaWorkspace *workspace)
-{
-  return (window->on_all_workspaces && window->screen == workspace->screen) ||
-    (window->workspace == workspace);
-}
-
 static gboolean
 is_minimized_foreach (MetaWindow *window,
                       void       *data)
@@ -3511,9 +3503,10 @@
               is_user_action ? " (user move/resize)" : "",
               old_rect.x, old_rect.y, old_rect.width, old_rect.height);
 
-  if (window->frame)
+  if (window->frame) {
     meta_frame_calc_geometry (window->frame,
                               &fgeom);
+  }
 
   new_rect.x = root_x_nw;
   new_rect.y = root_y_nw;
@@ -4464,6 +4457,13 @@
 meta_window_change_workspace (MetaWindow    *window,
                               MetaWorkspace *workspace)
 {
+#ifdef HAVE_XTSOL
+  if (tsol_is_available()) {
+	  if (!tsol_meta_window_can_move_to_workspace(window, workspace))
+	    return;
+  }
+#endif
+
   meta_window_change_workspace_without_transients (window, workspace);
 
   meta_window_foreach_transient (window, change_workspace_foreach,
@@ -6850,6 +6850,17 @@
 
   if (!window->on_all_workspaces)
     {
+#ifdef HAVE_XTSOL
+  if (tsol_is_available()) {
+       if (layout.current_col > 0 && tsol_meta_window_can_move_to_workspace (window, meta_workspace_get_neighbor (window->screen->active_workspace, META_MOTION_LEFT)))
+         ops |= META_MENU_OP_MOVE_LEFT;
+       if (layout.current_col < layout.cols - 1 && tsol_meta_window_can_move_to_workspace (window, meta_workspace_get_neighbor (window->screen->active_workspace, META_MOTION_RIGHT)))
+         ops |= META_MENU_OP_MOVE_RIGHT;
+       if (layout.current_row > 0 && tsol_meta_window_can_move_to_workspace (window, meta_workspace_get_neighbor (window->screen->active_workspace, META_MOTION_UP)))
+         ops |= META_MENU_OP_MOVE_UP;
+       if (layout.current_row < layout.rows - 1 && tsol_meta_window_can_move_to_workspace (window, meta_workspace_get_neighbor (window->screen->active_workspace, META_MOTION_DOWN)))
+         ops |= META_MENU_OP_MOVE_DOWN;
+  } else {
       ltr = meta_ui_get_direction() == META_UI_DIRECTION_LTR;
 
       if (layout.current_col > 0)
@@ -6862,6 +6873,21 @@
       if ((layout.current_row < layout.rows - 1) &&
           ((layout.current_row + 1) * layout.cols + layout.current_col < n_workspaces))
         ops |= META_MENU_OP_MOVE_DOWN;
+  }
+#else
+      ltr = meta_ui_get_direction() == META_UI_DIRECTION_LTR;
+
+      if (layout.current_col > 0)
+        ops |= ltr ? META_MENU_OP_MOVE_LEFT : META_MENU_OP_MOVE_RIGHT;
+      if ((layout.current_col < layout.cols - 1) &&
+          (layout.current_row * layout.cols + (layout.current_col + 1) < n_workspaces))
+        ops |= ltr ? META_MENU_OP_MOVE_RIGHT : META_MENU_OP_MOVE_LEFT;
+      if (layout.current_row > 0)
+        ops |= META_MENU_OP_MOVE_UP;
+      if ((layout.current_row < layout.rows - 1) &&
+          ((layout.current_row + 1) * layout.cols + layout.current_col < n_workspaces))
+        ops |= META_MENU_OP_MOVE_DOWN;
+#endif
     }
 
   meta_screen_free_workspace_layout (&layout);
@@ -8755,3 +8781,23 @@
    */
   return window->has_custom_frame_extents;
 }
+
+gboolean
+meta_window_located_on_workspace (MetaWindow    *window,
+                                  MetaWorkspace *workspace)
+{
+#ifdef HAVE_TSOL
+  if (tsol_meta_workspace_has_role (workspace))
+    {
+      /* SUN_BRANDING TJDS */
+      if (window->on_all_workspaces && window->decorated && 
+	      strcmp (tsol_meta_window_label_get_name (window), _("Trusted Path")) != 0)
+        {
+          /* printf ("meta_window_visible_on_workspace in ws role win (%s) is not TP\n", window->title); */
+          return FALSE;
+        }
+    }
+#endif
+  return (window->on_all_workspaces && window->screen == workspace->screen) ||
+    (window->workspace == workspace);
+}
diff -ur marco-1.22.1/src/core/workspace.c marco-1.22.1/src/core/workspace.c
--- marco-1.22.1/src/core/workspace.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/workspace.c	2019-10-07 17:13:36.158642267 +0000
@@ -120,6 +120,10 @@
    */
 
   tmp = workspace->windows;
+#ifdef HAVE_XTSOL
+  if (tsol_is_available ())
+    tmp = tsol_add_all_sticky_non_tp_windows (workspace->screen->display, tmp);
+#endif /*HAVE_XTSOL*/
   while (tmp != NULL)
     {
       GList *next;
diff -ur marco-1.22.1/src/core/workspace.h marco-1.22.1/src/core/workspace.h
--- marco-1.22.1/src/core/workspace.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/workspace.h	2019-09-29 17:54:01.598510215 +0000
@@ -105,6 +105,8 @@
 
 const char* meta_workspace_get_name (MetaWorkspace *workspace);
 
+gboolean meta_window_located_on_workspace (MetaWindow *window,
+                                  MetaWorkspace *workspace);
 #endif
 
 
diff -ur marco-1.22.1/src/include/prefs.h marco-1.22.1/src/include/prefs.h
--- marco-1.22.1/src/include/prefs.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/include/prefs.h	2019-09-11 12:44:57.025586255 +0000
@@ -31,6 +31,10 @@
 
 typedef enum
 {
+#ifdef HAVE_XTSOL
+  META_PREF_WORKSPACE_LABELS,
+  META_PREF_WORKSPACE_ROLES,
+#endif /*HAVE_XTSOL*/
   META_PREF_MOUSE_BUTTON_MODS,
   META_PREF_FOCUS_MODE,
   META_PREF_FOCUS_NEW_WINDOWS,
@@ -136,6 +140,15 @@
 gboolean    meta_prefs_show_tab_border (void);
 gboolean    meta_prefs_is_in_skip_list (char *class);
 
+#ifdef HAVE_XTSOL
+const char* meta_prefs_get_workspace_label    (int         i);
+void        meta_prefs_change_workspace_label (int         i,
+                                              const char *name);
+const char* meta_prefs_get_workspace_role    (int         i);
+void        meta_prefs_change_workspace_role (int         i,
+                                              const char *name);
+#endif /* HAVE_XTSOL */
+
 /**
  * Sets whether the compositor is turned on.
  *
diff -ur marco-1.22.1/src/include/ui.h marco-1.22.1/src/include/ui.h
--- marco-1.22.1/src/include/ui.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/include/ui.h	2019-09-11 22:39:08.265742522 +0000
@@ -178,6 +178,7 @@
 
 GdkPixbuf *meta_ui_get_pixbuf_from_surface (cairo_surface_t *surface);
 
+
 #include "tabpopup.h"
 #include "tile-preview.h"
 
diff -ur marco-1.22.1/src/tools/marco-window-demo.c marco-1.22.1/src/tools/marco-window-demo.c
--- marco-1.22.1/src/tools/marco-window-demo.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/tools/marco-window-demo.c	2019-09-11 12:44:57.055485498 +0000
@@ -911,27 +911,27 @@
 static GActionEntry demo_entries[] =
 {
   /* menubar */
-  { "dialog1",           dialog_cb,            NULL, NULL, NULL, {} },
-  { "dialog2",           modal_dialog_cb,      NULL, NULL, NULL, {} },
-  { "dialog3",           no_parent_dialog_cb,  NULL, NULL, NULL, {} },
-  { "utility",           utility_cb,           NULL, NULL, NULL, {} },
-  { "splashscreen",      splashscreen_cb,      NULL, NULL, NULL, {} },
-  { "top-dock",          dock_cb,              NULL, NULL, NULL, {} },
-  { "bottom-dock",       dock_cb,              NULL, NULL, NULL, {} },
-  { "left-dock",         dock_cb,              NULL, NULL, NULL, {} },
-  { "right-dock",        dock_cb,              NULL, NULL, NULL, {} },
-  { "all-docks",         dock_cb,              NULL, NULL, NULL, {} },
-  { "desktop",           desktop_cb,           NULL, NULL, NULL, {} },
-  { "menu",              menu_cb,              NULL, NULL, NULL, {} },
-  { "toolbar",           toolbar_cb,           NULL, NULL, NULL, {} },
-  { "override-redirect", override_redirect_cb, NULL, NULL, NULL, {} },
-  { "border-only",       border_only_cb,       NULL, NULL, NULL, {} },
+  { "dialog1",           dialog_cb,            NULL, NULL, NULL, {NULL} },
+  { "dialog2",           modal_dialog_cb,      NULL, NULL, NULL, {NULL} },
+  { "dialog3",           no_parent_dialog_cb,  NULL, NULL, NULL, {NULL} },
+  { "utility",           utility_cb,           NULL, NULL, NULL, {NULL} },
+  { "splashscreen",      splashscreen_cb,      NULL, NULL, NULL, {NULL} },
+  { "top-dock",          dock_cb,              NULL, NULL, NULL, {NULL} },
+  { "bottom-dock",       dock_cb,              NULL, NULL, NULL, {NULL} },
+  { "left-dock",         dock_cb,              NULL, NULL, NULL, {NULL} },
+  { "right-dock",        dock_cb,              NULL, NULL, NULL, {NULL} },
+  { "all-docks",         dock_cb,              NULL, NULL, NULL, {NULL} },
+  { "desktop",           desktop_cb,           NULL, NULL, NULL, {NULL} },
+  { "menu",              menu_cb,              NULL, NULL, NULL, {NULL} },
+  { "toolbar",           toolbar_cb,           NULL, NULL, NULL, {NULL} },
+  { "override-redirect", override_redirect_cb, NULL, NULL, NULL, {NULL} },
+  { "border-only",       border_only_cb,       NULL, NULL, NULL, {NULL} },
   /* toolbar */
-  { "new",               do_appwindow,         NULL, NULL, NULL, {} },
-  { "lock",              sleep_cb,             NULL, NULL, NULL, {} },
-  { "decorations",       toggle_decorated_cb,  NULL, NULL, NULL, {} },
-  { "quit",              clicked_toolbar_cb,   NULL, NULL, NULL, {} },
-  { "ratio",             toggle_aspect_ratio,  NULL, NULL, NULL, {} },
+  { "new",               do_appwindow,         NULL, NULL, NULL, {NULL} },
+  { "lock",              sleep_cb,             NULL, NULL, NULL, {NULL} },
+  { "decorations",       toggle_decorated_cb,  NULL, NULL, NULL, {NULL} },
+  { "quit",              clicked_toolbar_cb,   NULL, NULL, NULL, {NULL} },
+  { "ratio",             toggle_aspect_ratio,  NULL, NULL, NULL, {NULL} },
 };
 
 static GtkWidget *
diff -ur marco-1.22.1/src/ui/frames.c marco-1.22.1/src/ui/frames.c
--- marco-1.22.1/src/ui/frames.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/ui/frames.c	2019-10-19 10:33:26.987538362 +0000
@@ -33,6 +33,9 @@
 #include "fixedtip.h"
 #include "theme.h"
 #include "prefs.h"
+#ifdef HAVE_XTSOL
+#include "../core/trusted.h"
+#endif
 #include "ui.h"
 
 #ifdef HAVE_SHAPE
@@ -2494,7 +2497,12 @@
                                     frame->text_height,
                                     &button_layout,
                                     button_states,
-                                    mini_icon, icon);
+                                    mini_icon, icon
+#ifdef HAVE_XTSOL                            
+      				    ,GTK_WIDGET (frames),
+			            frame->label
+#endif
+				    );
 }
 
 static void
@@ -2869,4 +2877,22 @@
 {
   gdk_window_invalidate_rect (frame->window, NULL, FALSE);
   invalidate_cache (frames, frame);
+#ifdef HAVE_XTSOL
 }
+
+void
+meta_frames_set_label (MetaFrames *frames,
+		       Window      xwindow,
+		       MetaTrustedLabel *label)
+{
+  MetaUIFrame *frame;
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+  if (tsol_is_available()) {
+	  frame->label = label;
+  } else {
+	frame->label = NULL;
+  }
+}
+#endif
+
diff -ur marco-1.22.1/src/ui/frames.h marco-1.22.1/src/ui/frames.h
--- marco-1.22.1/src/ui/frames.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/ui/frames.h	2019-09-11 15:50:50.537060007 +0000
@@ -28,6 +28,9 @@
 #include <gdk/gdkx.h>
 #include "common.h"
 #include "theme.h"
+#ifdef HAVE_XTSOL
+#include "../core/trusted.h"
+#endif
 
 typedef enum
 {
@@ -78,6 +81,9 @@
   GdkWindow *window;
   GtkStyleContext *style;
   MetaFrameStyle *cache_style;
+#ifdef HAVE_XTSOL  
+  MetaTrustedLabel *label;
+#endif  
   PangoLayout *layout;
   int text_height;
   char *title; /* NULL once we have a layout */
@@ -160,4 +166,9 @@
 void meta_frames_push_delay_exposes (MetaFrames *frames);
 void meta_frames_pop_delay_exposes  (MetaFrames *frames);
 
+#ifdef HAVE_XTSOL
+void meta_frames_set_label (MetaFrames	     *frames, 
+			    Window	      xwindow,
+			    MetaTrustedLabel *label);
+#endif
 #endif
diff -ur marco-1.22.1/src/ui/preview-widget.c marco-1.22.1/src/ui/preview-widget.c
--- marco-1.22.1/src/ui/preview-widget.c	2019-12-19 13:54:27.798593945 +0000
+++ marco-1.22.1/src/ui/preview-widget.c	2019-10-19 10:34:12.851634647 +0000
@@ -25,7 +25,13 @@
 
 #include <math.h>
 #include <gtk/gtk.h>
+#include <gdk/gdkx.h>
 #include "preview-widget.h"
+#ifdef HAVE_XTSOL
+#include "../core/trusted.h"
+#include "../core/window-private.h"
+#include "../core/workspace.h"
+#endif
 
 static void     meta_preview_class_init    (MetaPreviewClass *klass);
 static void     meta_preview_init          (MetaPreview      *preview);
@@ -232,6 +238,20 @@
 
   if (preview->theme)
     {
+#ifdef HAVE_XTSOL
+      MetaTrustedLabel        *label = NULL;;
+if (tsol_is_available()) {
+            /* create new MetaTrustedLabel */
+      label = g_new0 (MetaTrustedLabel, 1);
+
+      label->name = "ADMIN_LOW";
+      label->color = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+      label->color->data.basic.color.red = 0.0;
+      label->color->data.basic.color.green = 0.0;
+      label->color->data.basic.color.blue = 0.0;
+}
+#endif
+
       border_width = gtk_container_get_border_width (GTK_CONTAINER (widget));
 
       meta_theme_draw_frame (preview->theme,
@@ -245,7 +265,10 @@
                              &preview->button_layout,
                              button_states,
                              meta_preview_get_mini_icon (),
-                             meta_preview_get_icon ());
+                             meta_preview_get_icon (),
+#ifdef HAVE_XTSOL
+			     label);
+#endif
     }
 
   cairo_restore (cr);
diff -ur marco-1.22.1/src/ui/theme-viewer.c marco-1.22.1/src/ui/theme-viewer.c
--- marco-1.22.1/src/ui/theme-viewer.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/ui/theme-viewer.c	2019-10-19 09:58:04.630019936 +0000
@@ -30,11 +30,19 @@
 #include <time.h>
 #include <stdlib.h>
 #include <string.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#ifdef HAVE_XTSOL
+#include "../core/trusted.h"
+#include "../core/window-private.h"
+#include "../core/workspace.h"
+#endif
 
 #include <libintl.h>
 #define _(x) dgettext (GETTEXT_PACKAGE, x)
 #define N_(x) x
 
+
 /* We need to compute all different button arrangements
  * in terms of button location. We don't care about
  * different arrangements in terms of button function.
@@ -51,6 +59,17 @@
 #define BUTTON_LAYOUT_COMBINATIONS ((MAX_BUTTONS_PER_CORNER+1)*(MAX_BUTTONS_PER_CORNER+1))
 #endif
 
+#ifdef HAVE_XTSOL
+void
+meta_quit ()
+{
+}
+void
+meta_restart (void)
+{
+}
+#endif
+
 enum
 {
   FONT_SIZE_SMALL,
@@ -1059,6 +1078,20 @@
   i = 0;
   while (i < ITERATIONS)
     {
+#ifdef HAVE_XTSOL
+      MetaTrustedLabel	      *label = NULL;;
+if (tsol_is_available()) {
+      /* create new MetaTrustedLabel */
+      label = g_new0 (MetaTrustedLabel, 1);
+
+      label->name = "ADMIN_LOW";
+      label->color = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+      label->color->data.basic.color.red = 0.0;
+      label->color->data.basic.color.green = 0.0;
+      label->color->data.basic.color.blue = 0.0;
+}
+#endif
+
       /* Creating the pixmap in the loop is right, since
        * GDK does the same with its double buffering.
        */
@@ -1079,8 +1112,11 @@
                              &button_layout,
                              button_states,
                              meta_preview_get_mini_icon (),
-                             meta_preview_get_icon ());
-
+                             meta_preview_get_icon ()
+#ifdef HAVE_XTSOL		       
+		             ,label
+#endif		       
+      );
       cairo_destroy (cr);
       cairo_surface_destroy (pixmap);
 
diff -ur marco-1.22.1/src/ui/theme.c marco-1.22.1/src/ui/theme.c
--- marco-1.22.1/src/ui/theme.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/ui/theme.c	2019-10-19 10:15:25.172711218 +0000
@@ -62,6 +62,14 @@
 #include <stdlib.h>
 #define __USE_XOPEN
 #include <math.h>
+#ifdef HAVE_XTSOL
+#include "prefs.h"
+#include "../core/trusted.h"
+#include "../core/window-private.h"
+#include "../core/workspace.h"
+
+static GtkWidget *trusted_widget;
+#endif
 
 #define GDK_COLOR_RGBA(color)                                           \
                          ((guint32) (0xff                         |     \
@@ -426,6 +434,10 @@
   if (top_height)
     {
       *top_height = MAX (buttons_height, title_height);
+#ifdef HAVE_XTSOL      
+      if (tsol_is_available ()) /*Trusted Frame Layout Modification TFLM*/
+        *top_height += *top_height - layout->title_border.bottom;
+#endif /* HAVE_XTSOL */
     }
 
   if (left_width)
@@ -494,7 +506,6 @@
                    MetaButtonFunction function,
                    MetaTheme         *theme)
 {
-
   /* Firstly, check version-specific things. */
 
   if (META_THEME_ALLOWS(theme, META_THEME_SHADE_STICK_ABOVE_BUTTONS))
@@ -550,7 +561,7 @@
         return NULL;
     case META_BUTTON_FUNCTION_MINIMIZE:
       if (flags & META_FRAME_ALLOWS_MINIMIZE)
-        return &fgeom->min_rect;
+	return &fgeom->min_rect;
       else
         return NULL;
     case META_BUTTON_FUNCTION_MAXIMIZE:
@@ -661,7 +672,10 @@
 
   fgeom->width = width;
   fgeom->height = height;
-
+#ifdef HAVE_XTSOL_debug 
+  if (tsol_is_available ())
+    fgeom->height = height + fgeom->top_height; /*Trusted Frame Layout Modification TFLM*/
+#endif  
   fgeom->top_titlebar_edge = layout->title_border.top;
   fgeom->bottom_titlebar_edge = layout->title_border.bottom;
   fgeom->left_titlebar_edge = layout->left_titlebar_edge;
@@ -865,9 +879,18 @@
   fgeom->n_right_buttons = n_right;
 
   /* center buttons vertically */
+#ifdef HAVE_XTSOL
+if (tsol_is_available()) {
+  button_y = layout->title_border.top;
+} else {
   button_y = (fgeom->top_height -
               (button_height + layout->button_border.top + layout->button_border.bottom)) / 2 + layout->button_border.top;
 
+}
+#else
+  button_y = (fgeom->top_height -
+              (button_height + layout->button_border.top + layout->button_border.bottom)) / 2 + layout->button_border.top;
+#endif
   /* right edge of farthest-right button */
   x = width - layout->right_titlebar_edge;
 
@@ -1109,7 +1132,6 @@
     case META_COLOR_SPEC_BASIC:
       size += sizeof (dummy.data.basic);
       break;
-
     case META_COLOR_SPEC_GTK:
       size += sizeof (dummy.data.gtk);
       break;
@@ -1144,7 +1166,6 @@
     case META_COLOR_SPEC_BASIC:
       DEBUG_FILL_STRUCT (&spec->data.basic);
       break;
-
     case META_COLOR_SPEC_GTK:
       DEBUG_FILL_STRUCT (&spec->data.gtk);
       break;
@@ -1623,7 +1644,6 @@
     case META_COLOR_SPEC_BASIC:
       *color = spec->data.basic.color;
       break;
-
     case META_COLOR_SPEC_GTK:
       meta_set_color_from_style (color,
                                  style,
@@ -2460,10 +2480,6 @@
         *result = env->title_width;
       else if (strcmp (t->d.v.name, "title_height") == 0)
         *result = env->title_height;
-      else if (strcmp (t->d.v.name, "frame_x_center") == 0)
-        *result = env->frame_x_center;
-      else if (strcmp (t->d.v.name, "frame_y_center") == 0)
-        *result = env->frame_y_center;
       else
         {
           g_set_error (err, META_THEME_ERROR,
@@ -3618,6 +3634,25 @@
 
   env->title_width = info->title_layout_width;
   env->title_height = info->title_layout_height;
+#ifdef HAVE_XTSOL
+if (tsol_is_available()) {
+  if (info->label && info->label->layout)
+    {
+      PangoRectangle extents;
+      
+      pango_layout_get_pixel_extents (info->label->layout,
+				      NULL, &extents);
+  
+      env->trusted_label_width =  extents.width;
+      env->trusted_label_height = extents.height;
+    }
+  else
+    {
+      env->trusted_label_width = 0;
+      env->trusted_label_height = 0;
+    }
+}
+#endif  
   env->theme = meta_current_theme;
 }
 
@@ -3967,7 +4002,11 @@
           {
             rx = parse_x_position_unchecked (op->data.icon.x, env);
             ry = parse_y_position_unchecked (op->data.icon.y, env);
-
+#ifdef HAVE_XTSOL
+if (tsol_is_available()) {
+	    ry = 26;
+}
+#endif
             gdk_cairo_set_source_pixbuf (cr, pixbuf, rx, ry);
             cairo_paint (cr);
 
@@ -3987,6 +4026,14 @@
 
           rx = parse_x_position_unchecked (op->data.title.x, env);
           ry = parse_y_position_unchecked (op->data.title.y, env);
+#ifdef HAVE_XTSOL
+if (tsol_is_available()) {
+	  ry = 26;
+
+	  env->rect.y = 21;
+	  env->rect.height = 22;
+}
+#endif
 
           if (op->data.title.ellipsize_width)
             {
@@ -4054,8 +4101,107 @@
            * if the width is already -1 */
           pango_layout_set_width (info->title_layout, -1);
         }
-      break;
+#ifdef HAVE_XTSOL
+if (tsol_is_available()) {
+      if (info->label->layout)
+        {
+          static MetaColorSpec *black = NULL;
+          static MetaColorSpec *white = NULL;
+          static GdkPixbuf   *shield_scaled = NULL;
+          int rx, ry;
+          int text_w, text_h;
+          MetaColorSpec *color;
+	  char *label_name;
+	  GdkRectangle area;
+	  GdkRGBA label_color;
+	  ConstraintImage *cimage = NULL;
+          gboolean black_text = tsol_should_label_layout_be_black (info->label->color);
+          GError **error = NULL;
+          int scaled_w, image_height;
+	  GdkPixbuf *shield_pixbuf;
+     
+          if (black == NULL)
+            {
+              black = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+              white = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+
+              gdk_rgba_parse (&black->data.basic.color, "black");
+              gdk_rgba_parse (&white->data.basic.color, "white");
+            }
+          pango_layout_get_pixel_size (info->label->layout,&text_w, &text_h);
+
+	  rect.height /= 2;
+          rx = ((rect.width - text_w) / 2 ) + rect.x;
+          ry = ((rect.height - text_h) / 2 ) + rect.y - 1;
+
+	  label_name = info->label->name;
+	  label_color.red = info->label->color->data.basic.color.red;
+	  label_color.green = info->label->color->data.basic.color.green;
+	  label_color.blue = info->label->color->data.basic.color.blue;
+	  label_color.alpha = info->label->color->data.basic.color.alpha;
+	  cimage = g_new0(ConstraintImage, 1);
+	  cimage->pixbuf = gdk_pixbuf_new_from_inline (-1, workspace_highlight,
+			  TRUE, NULL);
+	  area.x = rect.x;
+	  area.y = rect.y - 1;
+	  area.width = rect.width;
+	  area.height = rect.height;
+	  libgnome_tsol_constraint_image_set_border(cimage, 8, 8, 3, 3);
+	  libgnome_tsol_constraint_image_set_stretch (cimage, TRUE);
+	  libgnome_tsol_constraint_image_colorize (cimage, &label_color, 255, TRUE);
+	  
+	  libgnome_tsol_constraint_image_render (cr, cimage,
+			  gtk_widget_get_window(trusted_widget),
+			  &area,
+			  FALSE,
+			  area.x,
+			  area.y,
+			  area.width,
+			  area.height);
+	 
+
+	  if (shield_scaled == NULL) {
+	    shield_pixbuf = gdk_pixbuf_new_from_inline (-1, shield, FALSE, error);
+
+            image_height = rect.height - 6;
+
+            scaled_w = (gdk_pixbuf_get_width (shield_pixbuf) * image_height) /
+		    gdk_pixbuf_get_height (shield_pixbuf);
+
+            shield_scaled = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                                    TRUE,
+                                    8, scaled_w,
+                                    image_height);
+
+            gdk_pixbuf_scale (shield_pixbuf, shield_scaled, 0, 0,
+                          scaled_w, image_height, 0, 0,
+                      (double) image_height / gdk_pixbuf_get_height (shield_pixbuf),
+                      (double) image_height / gdk_pixbuf_get_height (shield_pixbuf),
+                          GDK_INTERP_HYPER);
+	    /* free shield_pixbuf */
+	  }
+
+	  if (strcmp (label_name, "Trusted Path") == 0) {
+	    gdk_cairo_set_source_pixbuf(cr, shield_scaled, rx - 24, ry + 1);
+	    cairo_paint(cr);
+	  }
+	  
+          if (black_text)
+            {
+              color = black;
+            }
+          else
+            {
+              color = white;
+            }
 
+	  gdk_cairo_set_source_rgba(cr, &color->data.basic.color);
+	  cairo_move_to(cr, rx, ry);
+	  pango_cairo_show_layout(cr, info->label->layout);
+        }
+}
+#endif
+      break;
     case META_DRAW_OP_LIST:
       {
         MetaRectangle d_rect;
@@ -4663,6 +4809,10 @@
                                   int                      client_width,
                                   int                      client_height,
                                   PangoLayout             *title_layout,
+#ifdef HAVE_XTSOL			    
+				  GtkWidget		   *widget,
+				  MetaTrustedLabel	   *label,
+#endif			    
                                   int                      text_height,
                                   MetaButtonState          button_states[META_BUTTON_TYPE_LAST],
                                   GdkPixbuf               *mini_icon,
@@ -4681,6 +4831,11 @@
 
   titlebar_rect.x = 0;
   titlebar_rect.y = 0;
+
+  /*
+  titlebar_rect.y = 23;
+   GLENN */
+
   titlebar_rect.width = fgeom->width;
   titlebar_rect.height = fgeom->top_height;
 
@@ -4729,7 +4884,19 @@
   draw_info.title_layout_width = title_layout ? extents.width : 0;
   draw_info.title_layout_height = title_layout ? extents.height : 0;
   draw_info.fgeom = fgeom;
-
+#ifdef HAVE_XTSOL  
+  if (tsol_is_available ())
+    {
+      draw_info.label = label;
+      if (!label->layout)
+	label->layout = gtk_widget_create_pango_layout (widget, label->name);
+      g_object_set_data (G_OBJECT (widget), "trusted_label", label);
+      trusted_widget = widget;
+    }
+  else
+    draw_info.label = NULL;
+#endif  
+  
   /* The enum is in the order the pieces should be rendered. */
   i = 0;
   while (i < META_FRAME_PIECE_LAST)
@@ -4747,6 +4914,8 @@
 
         case META_FRAME_PIECE_TITLEBAR:
           rect = titlebar_rect;
+	  rect.height /= 2;
+	  rect.y += 22;
           break;
 
         case META_FRAME_PIECE_LEFT_TITLEBAR_EDGE:
@@ -4900,6 +5069,9 @@
                        int                      client_width,
                        int                      client_height,
                        PangoLayout             *title_layout,
+#ifdef HAVE_XTSOL		       
+		       MetaTrustedLabel	       *label,
+#endif		       
                        int                      text_height,
                        MetaButtonState          button_states[META_BUTTON_TYPE_LAST],
                        GdkPixbuf               *mini_icon,
@@ -4909,7 +5081,12 @@
                                     gtk_widget_get_style_context (widget),
                                     cr,
                                     fgeom, client_width, client_height,
-                                    title_layout, text_height,
+                                    title_layout,
+#ifdef HAVE_XTSOL
+				    widget,
+				    label,
+#endif				    
+				    text_height,
                                     button_states, mini_icon, icon);
 }
 
@@ -5136,6 +5313,190 @@
   return meta_current_theme;
 }
 
+
+#ifdef HAVE_XTSOL
+static gint
+trusted_label_string_compare (MetaTrustedLabel *tmp, char *searched_label)
+{
+  return strcmp (searched_label, tmp->name);  
+}
+
+static char *
+get_window_label (Display *xdisplay, Window xwindow)
+{
+   m_label_t label;
+   int error;
+  
+  if (!tsol_is_available ())
+      return NULL;
+
+  if (libxtsol_XTSOLIsWindowTrusted (xdisplay, xwindow))
+    {
+      /* SUN_BRANDING TJDS */
+      return g_strdup (_("Trusted Path"));
+    }
+  else if (libxtsol_XTSOLgetResLabel (xdisplay, xwindow, IsWindow, &label))
+    {
+      char *string = NULL;
+      libtsol_label_to_str (&label, &string, M_LABEL, DEF_NAMES, &error);
+      return string;
+    }
+  else
+    return g_strdup ("didn't get the label\n");
+}
+
+static char *
+getlabelcolor(Display *xdisplay, Window xwindow)
+{
+#define DEFAULT_COLOR	"white"
+  char *colorname;
+  m_label_t label;
+  int error;
+  
+  if (!tsol_is_available ())
+    return NULL;
+  
+  if (libxtsol_XTSOLgetResLabel (xdisplay, xwindow, IsWindow, &label))
+    {
+      libtsol_label_to_str (&label, &colorname, M_COLOR, DEF_NAMES, &error);
+      if (colorname == NULL)
+	return g_strdup(DEFAULT_COLOR);
+      else
+	return g_strdup(colorname);
+    }
+  return NULL;
+}
+
+MetaTrustedLabel* tsol_xwindow_label_get (MetaDisplay *display, Window xwindow)
+{
+  MetaTrustedLabel *label = NULL;
+  GSList *stored_label = NULL;
+  char *label_name;
+  
+  if (!tsol_is_available ())
+    return NULL;
+
+  label_name = get_window_label (display->xdisplay, xwindow);
+  
+  /* Look if the label already exist */
+   stored_label = g_slist_find_custom (display->labels, label_name, (GCompareFunc)trusted_label_string_compare);
+
+  if (stored_label)
+    return (MetaTrustedLabel*) stored_label->data;
+
+  /* create new MetaTrustedLabel */
+  label = g_new0 (MetaTrustedLabel, 1);
+
+  label->name = label_name;
+  /* Layout is initialized in meta_frame_style_draw */ 
+
+  label->color = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+
+  if (!gdk_rgba_parse (&label->color->data.basic.color,
+    (const char*)getlabelcolor (display->xdisplay, xwindow)))
+    {
+      label->color->data.basic.color.red = 1.0;
+      label->color->data.basic.color.green = 1.0;
+      label->color->data.basic.color.blue = 1.0;
+      g_warning ("gdk_color_parse couldn't parse the label color\n");
+    }
+
+  display->labels = g_slist_append (display->labels, label);
+  
+  return label;
+}
+  
+const char * 
+tsol_meta_window_label_get_name (MetaWindow  *window)
+{
+  MetaTrustedLabel *label; 
+
+  if (!tsol_is_available ())
+    return NULL;
+
+  label = tsol_xwindow_label_get (window->display, window->xwindow);
+  return label->name;
+}
+
+MetaTrustedLabel* 
+tsol_meta_window_label_get (MetaWindow  *window)
+{
+  if (!tsol_is_available ())
+    return NULL;
+
+  return tsol_xwindow_label_get (window->display, window->xwindow);
+}
+
+gboolean tsol_should_label_layout_be_black (MetaColorSpec *bkg)
+{
+  double ntsc;
+  ntsc = ((bkg->data.basic.color.red) * .4450 +
+	   (bkg->data.basic.color.blue) * .030 +
+	   (bkg->data.basic.color.green) * .525);
+
+  /* printf ("ntsc %d ->",ntsc); */
+  
+  if ((1.0 - ntsc) < .61)
+    return TRUE;
+  return FALSE;
+}
+
+MetaTrustedLabel *
+tsol_workspace_get_label (MetaWorkspace *ws)
+{
+  int error;
+  MetaTrustedLabel *label = NULL;
+  m_label_t *mlabel = NULL;
+  GSList *stored_label = NULL;
+  const char *label_name = meta_prefs_get_workspace_label (meta_workspace_index (ws));
+  
+  /* Look if the label already exist */
+  
+  stored_label = g_slist_find_custom (ws->screen->display->labels, 
+				      label_name, 
+				      (GCompareFunc)trusted_label_string_compare);
+  
+  if (stored_label)
+    return (MetaTrustedLabel*) stored_label->data;
+
+  /* create a new one otherwise */
+
+  if (libtsol_str_to_label (label_name, &mlabel,
+			    MAC_LABEL, L_NO_CORRECTION, &error) == 0) 
+    {
+      char *colorname = NULL;
+      
+      libtsol_label_to_str (mlabel, &colorname, M_COLOR, DEF_NAMES, &error);
+      
+      #define DEFAULT_COLOR "white"	 
+      
+      if (colorname == NULL)
+	colorname = g_strdup(DEFAULT_COLOR);
+   
+      label = g_new0 (MetaTrustedLabel, 1);
+
+      label->name = (char*)label_name;
+      /* Layout is initialized in meta_frame_style_draw */ 
+      
+      label->color = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+      
+      if (!gdk_rgba_parse (&label->color->data.basic.color, (const char*)colorname))
+	{
+	  label->color->data.basic.color.red = 0.5;
+	  label->color->data.basic.color.green = 0.5;
+	  label->color->data.basic.color.blue = 0.5;
+	  g_warning ("gdk_rgba_parse couldn't parse the label color\n");
+	}
+      
+      ws->screen->display->labels = g_slist_append (ws->screen->display->labels, label);
+      
+      g_free (colorname);
+    }
+
+  return label;
+}
+#endif
+
 void
 meta_theme_set_current (const char *name,
                         gboolean    force_reload)
@@ -5522,7 +5883,12 @@
                                   const MetaButtonLayout *button_layout,
                                   MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
                                   GdkPixbuf              *mini_icon,
-                                  GdkPixbuf              *icon)
+                                  GdkPixbuf              *icon
+#ifdef HAVE_XTSOL		       
+				  ,GtkWidget		 *widget,
+				  MetaTrustedLabel	 *label
+#endif		       
+				  )
 {
   MetaFrameGeometry fgeom;
   MetaFrameStyle *style;
@@ -5549,6 +5915,10 @@
                                     &fgeom,
                                     client_width, client_height,
                                     title_layout,
+#ifdef HAVE_XTSOL
+				    widget,
+				    label,
+#endif				    
                                     text_height,
                                     button_states,
                                     mini_icon, icon);
@@ -5567,7 +5937,11 @@
                        const MetaButtonLayout *button_layout,
                        MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
                        GdkPixbuf              *mini_icon,
-                       GdkPixbuf              *icon)
+                       GdkPixbuf              *icon
+#ifdef HAVE_XTSOL		       
+		       ,MetaTrustedLabel	      *label
+#endif		       
+		      )
 {
   meta_theme_draw_frame_with_style (theme,
                                     gtk_widget_get_style_context (widget),
@@ -5575,7 +5949,12 @@
                                     type, flags, client_width, client_height,
                                     title_layout, text_height,
                                     button_layout, button_states,
-                                    mini_icon, icon);
+                                    mini_icon, icon
+#ifdef HAVE_XTSOL			     
+				    ,widget,
+				    label
+#endif									    
+				    );
 }
 
 void
@@ -5591,7 +5970,11 @@
                                const MetaButtonLayout *button_layout,
                                MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
                                GdkPixbuf              *mini_icon,
-                               GdkPixbuf              *icon)
+                               GdkPixbuf              *icon
+#ifdef HAVE_XTSOL		       
+			      ,MetaTrustedLabel	      *label
+#endif		       
+			       )
 {
   MetaFrameGeometry fgeom;
   MetaFrameStyle *style;
@@ -5616,6 +5999,9 @@
                          &fgeom,
                          client_width, client_height,
                          title_layout,
+#ifdef HAVE_XTSOL			 
+			 label,
+#endif			 
                          text_height,
                          button_states,
                          mini_icon, icon);
diff -ur marco-1.22.1/src/ui/theme.h marco-1.22.1/src/ui/theme.h
--- marco-1.22.1/src/ui/theme.h	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/ui/theme.h	2019-10-01 10:03:20.215294035 +0000
@@ -28,6 +28,9 @@
 #include "gradient.h"
 #include "common.h"
 #include <gtk/gtk.h>
+#include <config.h>
+#include "../core/display-private.h"
+#include "../core/screen-private.h"
 
 typedef struct _MetaFrameStyle MetaFrameStyle;
 typedef struct _MetaFrameStyleSet MetaFrameStyleSet;
@@ -43,6 +46,16 @@
 typedef struct _MetaPositionExprEnv MetaPositionExprEnv;
 typedef struct _MetaDrawInfo MetaDrawInfo;
 
+#ifdef HAVE_XTSOL
+struct _MetaTrustedLabel 
+{
+  char		*name;
+  PangoLayout	*layout;
+  MetaColorSpec *color;
+};
+typedef struct _MetaTrustedLabel  MetaTrustedLabel;
+#endif
+
 #define META_THEME_ERROR (g_quark_from_static_string ("meta-theme-error"))
 
 typedef enum
@@ -262,6 +275,11 @@
     struct {
       GdkRGBA color;
     } basic;
+#ifdef HAVE_XTSOL
+    struct {
+      gboolean dummy;
+    } label;
+#endif    
     struct {
       MetaGtkColorComponent component;
       GtkStateFlags state;
@@ -305,6 +323,9 @@
   int title_layout_width;
   int title_layout_height;
   const MetaFrameGeometry *fgeom;
+#ifdef HAVE_XTSOL 
+  MetaTrustedLabel *label;
+#endif 
 };
 
 /**
@@ -342,6 +363,11 @@
   META_DRAW_OP_LIST,
   /** tiled draw op list */
   META_DRAW_TILE
+#ifdef HAVE_XTSOL
+  ,
+  /* draw a string (used for trusted label) */
+  META_DRAW_TRUSTED_LABEL
+#endif
 } MetaDrawType;
 
 typedef enum
@@ -570,7 +596,15 @@
       MetaDrawSpec *tile_width;
       MetaDrawSpec *tile_height;
     } tile;
-
+    
+#ifdef HAVE_XTSOL    
+    struct {
+      MetaColorSpec *color_spec;
+      char *x;
+      char *y;
+    } trusted_label;
+#endif    
+    
   } data;
 };
 
@@ -860,6 +894,10 @@
   int bottom_height;
   int title_width;
   int title_height;
+#ifdef HAVE_XTSOL  
+  int trusted_label_width;
+  int trusted_label_height;
+#endif  
   int frame_x_center;
   int frame_y_center;
   int mini_icon_width;
@@ -972,6 +1010,25 @@
 void            meta_frame_style_ref   (MetaFrameStyle *style);
 void            meta_frame_style_unref (MetaFrameStyle *style);
 
+#ifdef HAVE_XTSOL
+
+
+MetaTrustedLabel*     tsol_meta_window_label_get (MetaWindow  *window);
+MetaTrustedLabel*     tsol_workspace_get_label (MetaWorkspace *ws);
+MetaTrustedLabel*     tsol_xwindow_label_get (MetaDisplay *display, 
+					      Window	   xwindow);
+
+gboolean tsol_should_label_layout_be_black (MetaColorSpec *bkg);
+MetaDrawOpList*	      tsol_theme_trusted_label_ops_get (MetaFrameFocus focus,
+							MetaTheme *theme);
+MetaDrawOpList*	      tsol_theme_trusted_title_ops_get (MetaFrameFocus focus,
+							MetaTheme *theme);
+void    meta_ui_set_frame_label  (MetaUI           *ui,
+                                  Window            xwindow,
+                                  MetaTrustedLabel *label);
+
+#endif
+
 void meta_frame_style_draw (MetaFrameStyle          *style,
                             GtkWidget               *widget,
                             cairo_t                 *cr,
@@ -979,6 +1036,9 @@
                             int                      client_width,
                             int                      client_height,
                             PangoLayout             *title_layout,
+#ifdef HAVE_XTSOL			    
+			    MetaTrustedLabel	    *label,
+#endif			    
                             int                      text_height,
                             MetaButtonState          button_states[META_BUTTON_TYPE_LAST],
                             GdkPixbuf               *mini_icon,
@@ -992,7 +1052,11 @@
                                        int                      client_width,
                                        int                      client_height,
                                        PangoLayout             *title_layout,
-                                       int                      text_height,
+#ifdef HAVE_XTSOL			    
+			    	       GtkWidget		*widget,
+				       MetaTrustedLabel	        *label,
+#endif			    
+				       int                      text_height,
                                        MetaButtonState          button_states[META_BUTTON_TYPE_LAST],
                                        GdkPixbuf               *mini_icon,
                                        GdkPixbuf               *icon);
@@ -1042,7 +1106,11 @@
                             const MetaButtonLayout *button_layout,
                             MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
                             GdkPixbuf              *mini_icon,
-                            GdkPixbuf              *icon);
+                            GdkPixbuf              *icon
+#ifdef HAVE_XTSOL
+                           ,MetaTrustedLabel       *label
+#endif
+                            );
 
 void meta_theme_draw_frame_by_name (MetaTheme              *theme,
                                     GtkWidget              *widget,
@@ -1056,7 +1124,11 @@
                                     const MetaButtonLayout *button_layout,
                                     MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
                                     GdkPixbuf              *mini_icon,
-                                    GdkPixbuf              *icon);
+                                    GdkPixbuf              *icon
+#ifdef HAVE_XTSOL
+				    ,MetaTrustedLabel       *label
+#endif
+				    );
 
 void meta_theme_draw_frame_with_style (MetaTheme              *theme,
                                        GtkStyleContext        *style_gtk,
@@ -1070,7 +1142,12 @@
                                        const MetaButtonLayout *button_layout,
                                        MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
                                        GdkPixbuf              *mini_icon,
-                                       GdkPixbuf              *icon);
+                                       GdkPixbuf              *icon
+#ifdef HAVE_XTSOL
+				       ,GtkWidget	      *widget,
+				       MetaTrustedLabel       *label
+#endif
+				       );
 
 void meta_theme_get_frame_borders (MetaTheme         *theme,
                                    MetaFrameType      type,
diff -ur marco-1.22.1/src/ui/ui.c marco-1.22.1/src/ui/ui.c
--- marco-1.22.1/src/ui/ui.c	2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/ui/ui.c	2019-10-07 16:57:20.308350637 +0000
@@ -21,6 +21,9 @@
  */
 
 #include "prefs.h"
+#ifdef HAVE_XTSOL
+#include "../core/trusted.h"
+#endif
 #include "ui.h"
 #include "frames.h"
 #include "util.h"
@@ -906,6 +909,16 @@
 	return threshold;
 }
 
+#ifdef HAVE_XTSOL
+void
+meta_ui_set_frame_label (MetaUI     *ui,
+                         Window      xwindow,
+                         MetaTrustedLabel *label)
+{
+  meta_frames_set_label (ui->frames, xwindow, label);
+}
+#endif
+
 MetaUIDirection meta_ui_get_direction(void)
 {
 	if (gtk_widget_get_default_direction() == GTK_TEXT_DIR_RTL)
--- marco-1.22.1/src/core/atomnames.h    2019-04-24 06:01:05.000000000 +0000
+++ marco-1.22.1/src/core/atomnames.h    2019-09-11 23:46:47.464554421 +0000
@@ -159,6 +159,11 @@
 item(_NET_WM_STATE_STICKY)
 item(_NET_WM_FULLSCREEN_MONITORS)
 item(_NET_WM_STATE_FOCUSED)
+#ifdef HAVE_XTSOL
+item(_NET_DESKTOP_ROLES)
+item(_NET_DESKTOP_LABELS)
+item(_NET_TRUSTED_ACTIVE_WINDOW)
+#endif
 
 #if 0
 /* We apparently never use: */
