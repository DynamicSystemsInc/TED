diff -ur a/tsol/TrustedExtensionsPolicy b/tsol/TrustedExtensionsPolicy
--- a/tsol/TrustedExtensionsPolicy	2019-12-05 17:02:30.809280551 +0000
+++ b/tsol/TrustedExtensionsPolicy	2020-04-08 23:15:47.478550541 +0000
@@ -189,16 +189,13 @@
 # Multilevel JDS/GNOME Support
 #
 property NAUTILUS_ACTIVE_DESKTOP_ID
-property _NET_WORKAREA
+property _NET_ACTIVE_WINDOW
 
 selection /^_DBUS_SESSION_BUS_SELECTION_/
+selection _NET_DESKTOP_MANAGER_S0
 
-selection Dtfile
-selection Dtpad
-selection _Frame_RPC
 selection _MOTIF_CLIP_LOCK
 
-
 #
 # Entries required to polyinstantiate applications 
 #
@@ -222,8 +219,9 @@
 selection /^wnn/
 selection /^com.sun.iiim/
 
-extension SYNC
+#extension SYNC
 extension XTEST
+#extension MIT-SHM
 
 privilege win_colormap
 privilege win_config
diff -ur a/tsol/auditwrite.c b/tsol/auditwrite.c
--- a/tsol/auditwrite.c	2019-12-05 17:02:30.794238470 +0000
+++ b/tsol/auditwrite.c	2020-01-12 23:24:35.646131051 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -40,12 +40,25 @@
 #include <thread.h>
 #include <synch.h>
 #include <bsm/audit.h>
+#include <bsm/adt.h>
 #include <bsm/audit_record.h>
 #include <bsm/libbsm.h>
 #include "auditwrite.h"
 #include <bsm/audit_uevents.h>
 #include <priv.h>
 #include <tsol/label.h>
+#include <sys/syscall.h>
+#include <sys/ipc.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/vnode.h>
+#include <malloc.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <netinet/in_pcb.h>
+#include <ucred.h>
+#include <zone.h>
 
 /*
  * invocation flags
@@ -380,7 +393,11 @@
 static void aw_debuglog(char *string, int rc, int param, va_list arglist);
 #endif
 
-extern int	cannot_audit(int);
+/* adt private */
+extern	void adt_get_asid(const adt_session_data_t *, au_asid_t *);
+extern	void adt_get_auid(const adt_session_data_t *, au_id_t *);
+extern	void adt_get_mask(const adt_session_data_t *, au_mask_t *);
+extern	void adt_get_termid(const adt_session_data_t *, au_tid_addr_t *);
 
 /*
  * a w _ g e t _ a r g s ( )
@@ -410,6 +427,1592 @@
 		(void) va_arg((arglist), void *); \
 }
 
+#define	NGROUPS		16	/* XXX - temporary */
+
+int
+audit(char *record, int length)
+{
+	return (syscall(SYS_auditsys, BSM_AUDIT, record, length));
+}
+
+/*
+ * adr_uid
+ */
+
+void
+adr_uid(adr_t *adr, uid_t *up, int count)
+{
+	int i;		/* index for counting */
+	uid_t l;	/* value for shifting */
+
+	for (; count-- > 0; up++) {
+		for (i = 0, l = *(uint32_t *)up; i < 4; i++) {
+			*adr->adr_now++ =
+			    (char)((uint32_t)(l & 0xff000000) >> 24);
+			l <<= 8;
+		}
+	}
+}
+
+/*
+ * adr_ushort - pull out ushorts
+ */
+void
+adr_ushort(adr_t *adr, ushort_t *sp, int count)
+{
+
+	for (; count-- > 0; sp++) {
+		*adr->adr_now++ = (char)((*sp >> 8) & 0x00ff);
+		*adr->adr_now++ = (char)(*sp & 0x00ff);
+	}
+}
+
+token_t *au_to_arg(char n, char *text, uint32_t v);
+#pragma weak au_to_arg = au_to_arg32
+token_t *au_to_return(char number, uint32_t value);
+#pragma weak au_to_return = au_to_return32
+
+static token_t *au_to_exec(char **, char);
+
+static token_t *
+get_token(int s)
+{
+	token_t *token;	/* Resultant token */
+
+	if ((token = (token_t *)malloc(sizeof (token_t))) == NULL)
+		return (NULL);
+	if ((token->tt_data = malloc(s)) == NULL) {
+		free(token);
+		return (NULL);
+	}
+	token->tt_size = s;
+	token->tt_next = NULL;
+	return (token);
+}
+
+/*
+ * au_to_header
+ * return s:
+ *	pointer to header token.
+ */
+token_t *
+au_to_header(au_event_t e_type, au_emod_t e_mod)
+{
+	adr_t adr;			/* adr memory stream header */
+	token_t *token;			/* token pointer */
+	char version = TOKEN_VERSION;	/* version of token family */
+	int32_t byte_count;
+	struct timeval tv;
+#ifdef _LP64
+	char data_header = AUT_HEADER64;	/* header for this token */
+
+	token = get_token(2 * sizeof (char) + sizeof (int32_t) +
+	    2 * sizeof (int64_t) + 2 * sizeof (short));
+#else
+	char data_header = AUT_HEADER32;
+
+	token = get_token(2 * sizeof (char) + 3 * sizeof (int32_t) +
+	    2 * sizeof (short));
+#endif
+
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);	/* token ID */
+	adr_int32(&adr, &byte_count, 1);	/* length of audit record */
+	adr_char(&adr, &version, 1);		/* version of audit tokens */
+	adr_ushort(&adr, &e_type, 1);		/* event ID */
+	adr_ushort(&adr, &e_mod, 1);		/* event ID modifier */
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&tv, 2);	/* time & date */
+#else
+	adr_int32(&adr, (int32_t *)&tv, 2);	/* time & date */
+#endif
+	return (token);
+}
+
+/*
+ * au_to_header_ex
+ * return s:
+ *	pointer to header token.
+ */
+token_t *
+au_to_header_ex(au_event_t e_type, au_emod_t e_mod)
+{
+	adr_t adr;			/* adr memory stream header */
+	token_t *token;			/* token pointer */
+	char version = TOKEN_VERSION;	/* version of token family */
+	int32_t byte_count;
+	struct timeval tv;
+	auditinfo_addr_t audit_info;
+	au_tid_addr_t	*host_info = &audit_info.ai_termid;
+#ifdef _LP64
+	char data_header = AUT_HEADER64_EX;	/* header for this token */
+#else
+	char data_header = AUT_HEADER32_EX;
+#endif
+
+	/* If our host address can't be determined, revert to un-extended hdr */
+
+	if (auditon(A_GETKAUDIT, (caddr_t)&audit_info,
+	    sizeof (audit_info)) < 0)
+		return (au_to_header(e_type, e_mod));
+
+	if (host_info->at_type == AU_IPv6)
+		if (IN6_IS_ADDR_UNSPECIFIED((in6_addr_t *)host_info->at_addr))
+			return (au_to_header(e_type, e_mod));
+	else
+		if (host_info->at_addr[0] == htonl(INADDR_ANY))
+			return (au_to_header(e_type, e_mod));
+
+#ifdef _LP64
+	token = get_token(2 * sizeof (char) + sizeof (int32_t) +
+	    2 * sizeof (int64_t) + 2 * sizeof (short) +
+	    sizeof (int32_t) + host_info->at_type);
+#else
+	token = get_token(2 * sizeof (char) + 3 * sizeof (int32_t) +
+	    2 * sizeof (short) + sizeof (int32_t) + host_info->at_type);
+#endif
+
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);	/* token ID */
+	adr_int32(&adr, &byte_count, 1);	/* length of audit record */
+	adr_char(&adr, &version, 1);		/* version of audit tokens */
+	adr_ushort(&adr, &e_type, 1);		/* event ID */
+	adr_ushort(&adr, &e_mod, 1);		/* event ID modifier */
+	adr_int32(&adr, (int32_t *)&host_info->at_type, 1);
+	adr_char(&adr, (char *)host_info->at_addr,
+	    (int)host_info->at_type);
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&tv, 2);	/* time & date */
+#else
+	adr_int32(&adr, (int32_t *)&tv, 2);	/* time & date */
+#endif
+	return (token);
+}
+
+/*
+ * au_to_trailer
+ * return s:
+ *	pointer to a trailer token.
+ */
+token_t *
+au_to_trailer(void)
+{
+	adr_t adr;				/* adr memory stream header */
+	token_t *token;				/* token pointer */
+	char data_header = AUT_TRAILER;		/* header for this token */
+	short magic = (short)AUT_TRAILER_MAGIC;	/* trailer magic number */
+	int32_t byte_count;
+
+	token = get_token(sizeof (char) + sizeof (int32_t) + sizeof (short));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);	/* token ID */
+	adr_short(&adr, &magic, 1);		/* magic number */
+	adr_int32(&adr, &byte_count, 1);	/* length of audit record */
+
+	return (token);
+}
+
+/*
+ * au_to_arg32
+ * return s:
+ *	pointer to an argument token.
+ */
+token_t *
+au_to_arg32(char n, char *text, uint32_t v)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_ARG32;	/* header for this token */
+	short bytes;			/* length of string */
+
+	bytes = strlen(text) + 1;
+
+	token = get_token((int)(2 * sizeof (char) + sizeof (int32_t) +
+	    sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);	/* token type */
+	adr_char(&adr, &n, 1);			/* argument id */
+	adr_int32(&adr, (int32_t *)&v, 1);	/* argument value */
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, text, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_arg64
+ * return s:
+ *	pointer to an argument token.
+ */
+token_t *
+au_to_arg64(char n, char *text, uint64_t v)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_ARG64;	/* header for this token */
+	short bytes;			/* length of string */
+
+	bytes = strlen(text) + 1;
+
+	token = get_token((int)(2 * sizeof (char) + sizeof (int64_t) +
+	    sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);	/* token type */
+	adr_char(&adr, &n, 1);			/* argument id */
+	adr_int64(&adr, (int64_t *)&v, 1);	/* argument value */
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, text, bytes);
+
+	return (token);
+}
+
+
+/*
+ * au_to_attr
+ * return s:
+ *	pointer to an attribute token.
+ */
+token_t *
+au_to_attr(struct stat64 *attr)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	int32_t value;
+#ifdef _LP64
+	char data_header = AUT_ATTR64;	/* header for this token */
+
+	token = get_token(sizeof (char) +
+	    sizeof (int32_t) * 4 +
+	    sizeof (int64_t) * 2);
+#else
+	char data_header = AUT_ATTR32;
+
+	token = get_token(sizeof (char) + sizeof (int32_t) * 5 +
+	    sizeof (int64_t));
+#endif
+#if 0
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	value = (int32_t)attr->va_mode;
+	adr_int32(&adr, &value, 1);
+	value = (int32_t)attr->va_uid;
+	adr_int32(&adr, &value, 1);
+	value = (int32_t)attr->va_gid;
+	adr_int32(&adr, &value, 1);
+	adr_int32(&adr, (int32_t *)&(attr->va_fsid), 1);
+	adr_int64(&adr, (int64_t *)&(attr->va_nodeid), 1);
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&(attr->va_rdev), 1);
+#else
+	adr_int32(&adr, (int32_t *)&(attr->va_rdev), 1);
+#endif
+#endif
+	return (token);
+}
+
+/*
+ * au_to_data
+ * return s:
+ *	pointer to a data token.
+ */
+token_t *
+au_to_data(char unit_print, char unit_type, char unit_count, char *p)
+{
+	adr_t adr;			/* adr memory stream header */
+	token_t *token;			/* token pointer */
+	char data_header = AUT_DATA;	/* header for this token */
+	int byte_count;			/* number of bytes */
+
+	if (p == NULL || unit_count < 1)
+		return (NULL);
+
+	/*
+	 * Check validity of print type
+	 */
+	if (unit_print < AUP_BINARY || unit_print > AUP_STRING)
+		return (NULL);
+
+	switch (unit_type) {
+	case AUR_SHORT:
+		byte_count = unit_count * sizeof (short);
+		break;
+	case AUR_INT32:
+		byte_count = unit_count * sizeof (int32_t);
+		break;
+	case AUR_INT64:
+		byte_count = unit_count * sizeof (int64_t);
+		break;
+	/* case AUR_CHAR: */
+	case AUR_BYTE:
+		byte_count = unit_count * sizeof (char);
+		break;
+	default:
+		return (NULL);
+	}
+
+	token = get_token((int)(4 * sizeof (char) + byte_count));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, &unit_print, 1);
+	adr_char(&adr, &unit_type, 1);
+	adr_char(&adr, &unit_count, 1);
+
+	switch (unit_type) {
+	case AUR_SHORT:
+		/* LINTED */
+		adr_short(&adr, (short *)p, unit_count);
+		break;
+	case AUR_INT32:
+		/* LINTED */
+		adr_int32(&adr, (int32_t *)p, unit_count);
+		break;
+	case AUR_INT64:
+		/* LINTED */
+		adr_int64(&adr, (int64_t *)p, unit_count);
+		break;
+	/* case AUR_CHAR: */
+	case AUR_BYTE:
+		adr_char(&adr, p, unit_count);
+		break;
+	}
+
+	return (token);
+}
+
+/*
+ * au_to_privset
+ *
+ * priv_type (LIMIT, INHERIT...) is the first string and privilege
+ * in translated into the second string.  The format is as follows:
+ *
+ *	token id	adr_char
+ *	priv type	adr_string (short, string)
+ *	priv set	adr_string (short, string)
+ *
+ * return s:
+ *	pointer to a AUT_PRIV token.
+ */
+token_t *
+au_to_privset(const char *priv_type, const priv_set_t *privilege)
+{
+	token_t	*token;			/* local token */
+	adr_t	adr;			/* adr memory stream header */
+	char	data_header = AUT_PRIV;	/* header for this token */
+	short	t_bytes;		/* length of type string */
+	short	p_bytes;		/* length of privilege string */
+	char	*priv_string;		/* privilege string */
+
+	t_bytes = strlen(priv_type) + 1;
+
+	if ((privilege == NULL) || (priv_string =
+	    priv_set_to_str(privilege, ',',
+	    PRIV_STR_LIT)) == NULL)
+		return (NULL);
+
+	p_bytes = strlen(priv_string) + 1;
+
+	token = get_token((int)(sizeof (char) + (2 * sizeof (short)) + t_bytes
+	    + p_bytes));
+	if (token == NULL)
+		return (NULL);
+
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &t_bytes, 1);
+	adr_char(&adr, (char *)priv_type, t_bytes);
+	adr_short(&adr, &p_bytes, 1);
+	adr_char(&adr, priv_string, p_bytes);
+
+	free(priv_string);
+
+	return (token);
+}
+
+/*
+ * au_to_process
+ * return s:
+ *	pointer to a process token.
+ */
+
+token_t *
+au_to_process(au_id_t auid, uid_t euid, gid_t egid, uid_t ruid, gid_t rgid,
+    pid_t pid, au_asid_t sid, au_tid_t *tid)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+#ifdef _LP64
+	char data_header = AUT_PROCESS64;	/* header for this token */
+
+	token = get_token(sizeof (char) + 8 * sizeof (int32_t) +
+	    sizeof (int64_t));
+#else
+	char data_header = AUT_PROCESS32;
+
+	token = get_token(sizeof (char) + 9 * sizeof (int32_t));
+#endif
+
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&auid, 1);
+	adr_int32(&adr, (int32_t *)&euid, 1);
+	adr_int32(&adr, (int32_t *)&egid, 1);
+	adr_int32(&adr, (int32_t *)&ruid, 1);
+	adr_int32(&adr, (int32_t *)&rgid, 1);
+	adr_int32(&adr, (int32_t *)&pid, 1);
+	adr_int32(&adr, (int32_t *)&sid, 1);
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&tid->port, 1);
+#else
+	adr_int32(&adr, (int32_t *)&tid->port, 1);
+#endif
+	adr_int32(&adr, (int32_t *)&tid->machine, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_process_ex
+ * return s:
+ *	pointer to a process_ex token.
+ */
+token_t *
+au_to_process_ex(au_id_t auid, uid_t euid, gid_t egid, uid_t ruid, gid_t rgid,
+    pid_t pid, au_asid_t sid, au_tid_addr_t *tid)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header;		/* header for this token */
+
+#ifdef _LP64
+	if (tid->at_type == AU_IPv6) {
+		data_header = AUT_PROCESS64_EX;
+		token = get_token(sizeof (char) + sizeof (int64_t) +
+		    12 * sizeof (int32_t));
+	} else {
+		data_header = AUT_PROCESS64;
+		token = get_token(sizeof (char) + sizeof (int64_t) +
+		    8 * sizeof (int32_t));
+	}
+#else
+	if (tid->at_type == AU_IPv6) {
+		data_header = AUT_PROCESS32_EX;
+		token = get_token(sizeof (char) + 13 * sizeof (int32_t));
+	} else {
+		data_header = AUT_PROCESS32;
+		token = get_token(sizeof (char) + 9 * sizeof (int32_t));
+	}
+#endif
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&auid, 1);
+	adr_int32(&adr, (int32_t *)&euid, 1);
+	adr_int32(&adr, (int32_t *)&egid, 1);
+	adr_int32(&adr, (int32_t *)&ruid, 1);
+	adr_int32(&adr, (int32_t *)&rgid, 1);
+	adr_int32(&adr, (int32_t *)&pid, 1);
+	adr_int32(&adr, (int32_t *)&sid, 1);
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&tid->at_port, 1);
+#else
+	adr_int32(&adr, (int32_t *)&tid->at_port, 1);
+#endif
+	if (tid->at_type == AU_IPv6) {
+		adr_int32(&adr, (int32_t *)&tid->at_type, 1);
+		adr_char(&adr, (char *)tid->at_addr, 16);
+	} else {
+		adr_char(&adr, (char *)tid->at_addr, 4);
+	}
+
+	return (token);
+}
+
+/*
+ * au_to_seq
+ * return s:
+ *	pointer to token chain containing a sequence token
+ */
+token_t *
+au_to_seq(int audit_count)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_SEQ;	/* header for this token */
+
+	token = get_token(sizeof (char) + sizeof (int32_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&audit_count, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_socket
+ * return s:
+ *	pointer to mbuf chain containing a socket token.
+ */
+token_t *
+au_to_socket(struct oldsocket *so)
+{
+	adr_t adr;
+	token_t *token;
+	char data_header = AUT_SOCKET;
+	struct inpcb *inp = so->so_pcb;
+
+	token = get_token(sizeof (char) + sizeof (short) * 3 +
+	    sizeof (int32_t) * 2);
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, (short *)&so->so_type, 1);
+	adr_short(&adr, (short *)&inp->inp_lport, 1);
+	adr_int32(&adr, (int32_t *)&inp->inp_laddr, 1);
+	adr_short(&adr, (short *)&inp->inp_fport, 1);
+	adr_int32(&adr, (int32_t *)&inp->inp_faddr, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_subject
+ * return s:
+ *	pointer to a process token.
+ */
+
+token_t *
+au_to_subject(au_id_t auid, uid_t euid, gid_t egid, uid_t ruid, gid_t rgid,
+    pid_t pid, au_asid_t sid, au_tid_t *tid)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+#ifdef _LP64
+	char data_header = AUT_SUBJECT64;	/* header for this token */
+
+	token = get_token(sizeof (char) + sizeof (int64_t) +
+	    8 * sizeof (int32_t));
+#else
+	char data_header = AUT_SUBJECT32;
+
+	token = get_token(sizeof (char) + 9 * sizeof (int32_t));
+#endif
+
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&auid, 1);
+	adr_int32(&adr, (int32_t *)&euid, 1);
+	adr_int32(&adr, (int32_t *)&egid, 1);
+	adr_int32(&adr, (int32_t *)&ruid, 1);
+	adr_int32(&adr, (int32_t *)&rgid, 1);
+	adr_int32(&adr, (int32_t *)&pid, 1);
+	adr_int32(&adr, (int32_t *)&sid, 1);
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&tid->port, 1);
+#else
+	adr_int32(&adr, (int32_t *)&tid->port, 1);
+#endif
+	adr_int32(&adr, (int32_t *)&tid->machine, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_subject_ex
+ * return s:
+ *	pointer to a process token.
+ */
+
+token_t *
+au_to_subject_ex(au_id_t auid, uid_t euid, gid_t egid, uid_t ruid, gid_t rgid,
+    pid_t pid, au_asid_t sid, au_tid_addr_t *tid)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+#ifdef _LP64
+	char data_header;		/* header for this token */
+
+	if (tid->at_type == AU_IPv6) {
+		data_header = AUT_SUBJECT64_EX;
+		token = get_token(sizeof (char) + sizeof (int64_t) +
+		    12 * sizeof (int32_t));
+	} else {
+		data_header = AUT_SUBJECT64;
+		token = get_token(sizeof (char) + sizeof (int64_t) +
+		    8 * sizeof (int32_t));
+	}
+#else
+	char data_header;		/* header for this token */
+
+	if (tid->at_type == AU_IPv6) {
+		data_header = AUT_SUBJECT32_EX;
+		token = get_token(sizeof (char) + 13 * sizeof (int32_t));
+	} else {
+		data_header = AUT_SUBJECT32;
+		token = get_token(sizeof (char) + 9 * sizeof (int32_t));
+	}
+#endif
+
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&auid, 1);
+	adr_int32(&adr, (int32_t *)&euid, 1);
+	adr_int32(&adr, (int32_t *)&egid, 1);
+	adr_int32(&adr, (int32_t *)&ruid, 1);
+	adr_int32(&adr, (int32_t *)&rgid, 1);
+	adr_int32(&adr, (int32_t *)&pid, 1);
+	adr_int32(&adr, (int32_t *)&sid, 1);
+#ifdef _LP64
+	adr_int64(&adr, (int64_t *)&tid->at_port, 1);
+#else
+	adr_int32(&adr, (int32_t *)&tid->at_port, 1);
+#endif
+	if (tid->at_type == AU_IPv6) {
+		adr_int32(&adr, (int32_t *)&tid->at_type, 1);
+		adr_char(&adr, (char *)tid->at_addr, 16);
+	} else {
+		adr_char(&adr, (char *)tid->at_addr, 4);
+	}
+
+	return (token);
+}
+
+/*
+ * au_to_me
+ * return s:
+ *	pointer to a process token.
+ */
+
+token_t *
+au_to_me(void)
+{
+#if 0
+	auditinfo_addr_t info;
+
+	if (getaudit_addr(&info, sizeof (info)))
+		return (NULL);
+	return (au_to_subject_ex(info.ai_auid, geteuid(), getegid(), getuid(),
+	    getgid(), getpid(), info.ai_asid, &info.ai_termid));
+#endif
+	return NULL;
+}
+/*
+ * au_to_text
+ * return s:
+ *	pointer to a text token.
+ */
+token_t *
+au_to_text(char *text)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_TEXT;	/* header for this token */
+	short bytes;			/* length of string */
+
+	bytes = strlen(text) + 1;
+	token = get_token((int)(sizeof (char) + sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, text, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_path
+ * return s:
+ *	pointer to a path token.
+ */
+token_t *
+au_to_path(char *path)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_PATH;	/* header for this token */
+	short bytes;			/* length of string */
+
+	bytes = (short)strlen(path) + 1;
+
+	token = get_token((int)(sizeof (char) +  sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, path, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_cmd
+ * return s:
+ *	pointer to an command line argument token
+ */
+token_t *
+au_to_cmd(int argc, char **argv, char **envp)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_CMD;	/* header for this token */
+	short len = 0;
+	short cnt = 0;
+	short envc = 0;
+	short largc = (short)argc;
+
+	/*
+	 * one char for the header, one short for argc,
+	 * one short for # envp strings.
+	 */
+	len = sizeof (char) + sizeof (short) + sizeof (short);
+
+	/* get sizes of strings */
+
+	for (cnt = 0; cnt < argc; cnt++) {
+		len += (short)sizeof (short) + (short)(strlen(argv[cnt]) + 1);
+	}
+
+	if (envp != NULL) {
+		for (envc = 0; envp[envc] != NULL; envc++) {
+			len += (short)sizeof (short) +
+			    (short)(strlen(envp[envc]) + 1);
+		}
+	}
+
+	token = get_token(len);
+	if (token == NULL)
+		return (NULL);
+
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+
+	adr_short(&adr, &largc, 1);
+
+	for (cnt = 0; cnt < argc; cnt++) {
+		len = (short)(strlen(argv[cnt]) + 1);
+		adr_short(&adr, &len, 1);
+		adr_char(&adr, argv[cnt], len);
+	}
+
+	adr_short(&adr, &envc, 1);
+
+	for (cnt = 0; cnt < envc; cnt++) {
+		len = (short)(strlen(envp[cnt]) + 1);
+		adr_short(&adr, &len, 1);
+		adr_char(&adr, envp[cnt], len);
+	}
+
+	return (token);
+}
+
+/*
+ * au_to_exit
+ * return s:
+ *	pointer to a exit value token.
+ */
+token_t *
+au_to_exit(int retval, int err)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_EXIT;	/* header for this token */
+
+	token = get_token(sizeof (char) + (2 * sizeof (int32_t)));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&retval, 1);
+	adr_int32(&adr, (int32_t *)&err, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_return
+ * return s:
+ *	pointer to a return  value token.
+ */
+token_t *
+au_to_return32(char number, uint32_t value)
+{
+	token_t *token;				/* local token */
+	adr_t adr;				/* adr memory stream header */
+	char data_header = AUT_RETURN32;	/* header for this token */
+
+	token = get_token(2 * sizeof (char) + sizeof (int32_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, &number, 1);
+	adr_int32(&adr, (int32_t *)&value, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_return
+ * return s:
+ *	pointer to a return  value token.
+ */
+token_t *
+au_to_return64(char number, uint64_t value)
+{
+	token_t *token;				/* local token */
+	adr_t adr;				/* adr memory stream header */
+	char data_header = AUT_RETURN64;	/* header for this token */
+
+	token = get_token(2 * sizeof (char) + sizeof (int64_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, &number, 1);
+	adr_int64(&adr, (int64_t *)&value, 1);
+
+	return (token);
+}
+
+
+/*
+ * au_to_opaque
+ * return s:
+ *	pointer to a opaque token.
+ */
+token_t *
+au_to_opaque(char *opaque, short bytes)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_OPAQUE;	/* header for this token */
+
+	if (bytes < 1)
+		return (NULL);
+
+	token = get_token((int)(sizeof (char) + sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, opaque, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_in_addr
+ * return s:
+ *	pointer to an internet address token
+ */
+token_t *
+au_to_in_addr(struct in_addr *internet_addr)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_IN_ADDR;	/* header for this token */
+
+	token = get_token(sizeof (char) + sizeof (struct in_addr));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, (char *)internet_addr, sizeof (struct in_addr));
+
+	return (token);
+}
+
+/*
+ * au_to_in_addr_ex
+ * return s:
+ *	pointer to an internet extended token
+ */
+token_t *
+au_to_in_addr_ex(struct in6_addr *addr)
+{
+	token_t *token;
+	adr_t adr;
+
+	if (IN6_IS_ADDR_V4MAPPED(addr)) {
+		ipaddr_t in4;
+
+		/*
+		 * An IPv4-mapped IPv6 address is really an IPv4 address
+		 * in IPv6 format.
+		 */
+
+		IN6_V4MAPPED_TO_IPADDR(addr, in4);
+		return (au_to_in_addr((struct in_addr *)&in4));
+
+	} else {
+		char data_header = AUT_IN_ADDR_EX;
+		int32_t	type = AU_IPv6;
+
+		if ((token = get_token(sizeof (char) + sizeof (int32_t) +
+		    sizeof (struct in6_addr))) == NULL) {
+			return (NULL);
+		}
+
+		adr_start(&adr, token->tt_data);
+		adr_char(&adr, &data_header, 1);
+		adr_int32(&adr, &type, 1);
+		adr_char(&adr, (char *)addr, sizeof (struct in6_addr));
+	}
+
+	return (token);
+}
+
+/*
+ * au_to_iport
+ * return s:
+ *	pointer to token chain containing a ip port address token
+ */
+token_t *
+au_to_iport(ushort_t iport)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_IPORT;	/* header for this token */
+
+	token = get_token(sizeof (char) + sizeof (short));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, (short *)&iport, 1);
+
+	return (token);
+}
+
+token_t *
+au_to_ipc(char type, int id)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_IPC;	/* header for this token */
+
+	token = get_token((2 * sizeof (char)) + sizeof (int32_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, &type, 1);
+	adr_int32(&adr, (int32_t *)&id, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_tid
+ *
+ * output format depends on type; at present only IP v4 and v6 addresses
+ * are defined.
+ *
+ * IPv4 -- tid type, 16 bit remote port, 16 bit local port, ip type,
+ *		32 bit IP address.
+ * IPv6 -- tid type, 16 bit remote port, 16 bit local port, ip type,
+ *		4 x 32 bit IP address.
+ *
+ */
+token_t *
+au_to_tid(au_generic_tid_t *tid)
+{
+	char		data_header = AUT_TID;	/* header for this token */
+	adr_t		adr;			/* adr memory stream header */
+	token_t		*token;			/* local token */
+	au_ip_t		*ip;
+
+	switch (tid->gt_type) {
+	case AU_IPADR:
+		ip = &(tid->gt_adr.at_ip);
+		token = get_token((int)(2 * sizeof (char) + 2 * sizeof (short) +
+		    sizeof (uint32_t) + ip->at_type));
+		if (token == NULL)
+			return (NULL);
+
+		adr_start(&adr, token->tt_data);
+		adr_char(&adr, &data_header, 1);
+		adr_char(&adr, (char *)&(tid->gt_type), 1);
+		adr_short(&adr, (short *)&(ip->at_r_port), 1);
+		adr_short(&adr, (short *)&(ip->at_l_port), 1);
+		adr_int32(&adr, (int32_t *)&(ip->at_type), 1);
+
+		adr_char(&adr, (char *)ip->at_addr, ip->at_type);
+
+		break;
+	default:
+		return (NULL);
+	}
+	return (token);
+}
+
+/*
+ * The Modifier tokens
+ */
+
+/*
+ * au_to_groups
+ * return s:
+ *	pointer to a group list token.
+ *
+ * This function is obsolete.  Please use au_to_newgroups.
+ */
+token_t *
+au_to_groups(int *groups)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_GROUPS;	/* header for this token */
+
+	token = get_token(sizeof (char) + NGROUPS * sizeof (int32_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)groups, NGROUPS);
+
+	return (token);
+}
+
+/*
+ * au_to_newgroups
+ * return s:
+ *	pointer to a group list token.
+ */
+token_t *
+au_to_newgroups(int n, gid_t *groups)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_NEWGROUPS;	/* header for this token */
+	short n_groups;
+
+	if (n < 0 || n > SHRT_MAX || groups == NULL)
+		return (NULL);
+	token = get_token(sizeof (char) + sizeof (short) + n * sizeof (gid_t));
+	if (token == NULL)
+		return (NULL);
+	n_groups = (short)n;
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &n_groups, 1);
+	adr_int32(&adr, (int32_t *)groups, n_groups);
+
+	return (token);
+}
+
+/*
+ * au_to_exec_args
+ * returns:
+ *	pointer to an exec args token.
+ */
+token_t *
+au_to_exec_args(char **argv)
+{
+	return (au_to_exec(argv, AUT_EXEC_ARGS));
+}
+
+/*
+ * au_to_exec_env
+ * returns:
+ *	pointer to an exec args token.
+ */
+token_t *
+au_to_exec_env(char **envp)
+{
+	return (au_to_exec(envp, AUT_EXEC_ENV));
+}
+
+/*
+ * au_to_exec
+ * returns:
+ *	pointer to an exec args token.
+ */
+static token_t *
+au_to_exec(char **v, char data_header)
+{
+	token_t *token;
+	adr_t adr;
+	char **p;
+	int32_t n = 0;
+	int len = 0;
+
+	for (p = v; *p != NULL; p++) {
+		len += strlen(*p) + 1;
+		n++;
+	}
+	token = get_token(sizeof (char) + sizeof (int32_t) + len);
+	if (token == (token_t *)NULL)
+		return ((token_t *)NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, &n, 1);
+	for (p = v; *p != NULL; p++) {
+		adr_char(&adr, *p, strlen(*p) + 1);
+	}
+	return (token);
+}
+
+/*
+ * au_to_uauth
+ * return s:
+ *	pointer to a uauth token.
+ */
+token_t *
+au_to_uauth(char *text)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_UAUTH;	/* header for this token */
+	short bytes;			/* length of string */
+
+	bytes = strlen(text) + 1;
+
+	token = get_token((int)(sizeof (char) + sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, text, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_upriv
+ * return s:
+ *	pointer to a use of privilege token.
+ */
+token_t *
+au_to_upriv(char sorf, char *priv)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_UPRIV;	/* header for this token */
+	short bytes;			/* length of string */
+
+	bytes = strlen(priv) + 1;
+
+	token = get_token(sizeof (char) + sizeof (char) + sizeof (short) +
+	    bytes);
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, &sorf, 1);	/* success/failure */
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, priv, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_xatom
+ * return s:
+ *	pointer to a xatom token.
+ */
+token_t *
+au_to_xatom(char *atom)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_XATOM;	/* header for this token */
+	short len;
+
+	len = strlen(atom) + 1;
+
+	token = get_token(sizeof (char) + sizeof (short) + len);
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, (short *)&len, 1);
+	adr_char(&adr, atom, len);
+
+	return (token);
+}
+
+/*
+ * au_to_xselect
+ * return s:
+ *	pointer to a X select token.
+ */
+token_t *
+au_to_xselect(char *propname, char *proptype, char *windata)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_XSELECT;	/* header for this token */
+	short proplen;
+	short typelen;
+	short datalen;
+
+	proplen = strlen(propname) + 1;
+	typelen = strlen(proptype) + 1;
+	datalen = strlen(windata) + 1;
+
+	token = get_token(sizeof (char) + (sizeof (short) * 3) +
+	    proplen + typelen + datalen);
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &proplen, 1);
+	adr_char(&adr, propname, proplen);
+	adr_short(&adr, &typelen, 1);
+	adr_char(&adr, proptype, typelen);
+	adr_short(&adr, &datalen, 1);
+	adr_char(&adr, windata, datalen);
+
+	return (token);
+}
+
+/*
+ * x_common
+ * return s:
+ *	pointer to a common X token.
+ */
+
+static token_t *
+x_common(char data_header, int32_t xid, uid_t cuid)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+
+	token = get_token(sizeof (char) + sizeof (int32_t) + sizeof (uid_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, &xid, 1);
+	adr_uid(&adr, &cuid, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_xcolormap
+ * return s:
+ *	pointer to a X Colormap token.
+ */
+
+token_t *
+au_to_xcolormap(int32_t xid, uid_t cuid)
+{
+	return (x_common(AUT_XCOLORMAP, xid, cuid));
+}
+
+/*
+ * au_to_xcursor
+ * return s:
+ *	pointer to a X Cursor token.
+ */
+
+token_t *
+au_to_xcursor(int32_t xid, uid_t cuid)
+{
+	return (x_common(AUT_XCURSOR, xid, cuid));
+}
+
+/*
+ * au_to_xfont
+ * return s:
+ *	pointer to a X Font token.
+ */
+
+token_t *
+au_to_xfont(int32_t xid, uid_t cuid)
+{
+	return (x_common(AUT_XFONT, xid, cuid));
+}
+
+/*
+ * au_to_xgc
+ * return s:
+ *	pointer to a X Graphic Context token.
+ */
+
+token_t *
+au_to_xgc(int32_t xid, uid_t cuid)
+{
+	return (x_common(AUT_XGC, xid, cuid));
+}
+
+/*
+ * au_to_xpixmap
+ * return s:
+ *	pointer to a X Pixal Map token.
+ */
+
+token_t *
+au_to_xpixmap(int32_t xid, uid_t cuid)
+{
+	return (x_common(AUT_XPIXMAP, xid, cuid));
+}
+
+/*
+ * au_to_xwindow
+ * return s:
+ *	pointer to a X Window token.
+ */
+
+token_t *
+au_to_xwindow(int32_t xid, uid_t cuid)
+{
+	return (x_common(AUT_XWINDOW, xid, cuid));
+}
+
+/*
+ * au_to_xproperty
+ * return s:
+ *	pointer to a X Property token.
+ */
+
+token_t *
+au_to_xproperty(int32_t xid, uid_t cuid, char *propname)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_XPROPERTY;	/* header for this token */
+	short proplen;
+
+	proplen = strlen(propname) + 1;
+
+	token = get_token(sizeof (char) + sizeof (int32_t) + sizeof (uid_t) +
+	    sizeof (short) + proplen);
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, &xid, 1);
+	adr_uid(&adr, &cuid, 1);
+	adr_short(&adr, &proplen, 1);
+	adr_char(&adr, propname, proplen);
+
+	return (token);
+}
+
+/*
+ * au_to_xclient
+ * return s:
+ *	pointer to a X Client token
+ */
+
+token_t *
+au_to_xclient(uint32_t client)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_XCLIENT;	/* header for this token */
+
+	token = get_token(sizeof (char) + sizeof (uint32_t));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_int32(&adr, (int32_t *)&client, 1);
+
+	return (token);
+}
+
+/*
+ * au_to_label
+ * return s:
+ *	pointer to a label token.
+ */
+token_t *
+au_to_label(m_label_t *label)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_LABEL;	/* header for this token */
+	size32_t llen = blabel_size();
+
+	token = get_token(sizeof (char) + llen);
+	if (token == NULL) {
+		return (NULL);
+	} else if (label == NULL) {
+		free(token);
+		return (NULL);
+	}
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_char(&adr, (char *)label, llen);
+
+	return (token);
+}
+
+/*
+ * au_to_mylabel
+ * return s:
+ *	pointer to a label token.
+ */
+token_t *
+au_to_mylabel(void)
+{
+	ucred_t		*uc;
+	token_t		*token;
+
+	if ((uc = ucred_get(P_MYID)) == NULL) {
+		return (NULL);
+	}
+
+	token = au_to_label(ucred_getlabel(uc));
+	ucred_free(uc);
+	return (token);
+}
+
+/*
+ * au_to_zonename
+ * return s:
+ *	pointer to a zonename token.
+ */
+token_t *
+au_to_zonename(char *name)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_ZONENAME;	/* header for this token */
+	short bytes;			/* length of string */
+
+	if (name == NULL)
+		return (NULL);
+
+	bytes = strlen(name) + 1;
+	token = get_token((int)(sizeof (char) + sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, name, bytes);
+
+	return (token);
+}
+
+/*
+ * au_to_fmri
+ * return s:
+ *	pointer to a fmri token.
+ */
+token_t *
+au_to_fmri(char *fmri)
+{
+	token_t *token;			/* local token */
+	adr_t adr;			/* adr memory stream header */
+	char data_header = AUT_FMRI;	/* header for this token */
+	short bytes;			/* length of string */
+
+	if (fmri == NULL)
+		return (NULL);
+
+	bytes = strlen(fmri) + 1;
+	token = get_token((int)(sizeof (char) + sizeof (short) + bytes));
+	if (token == NULL)
+		return (NULL);
+	adr_start(&adr, token->tt_data);
+	adr_char(&adr, &data_header, 1);
+	adr_short(&adr, &bytes, 1);
+	adr_char(&adr, fmri, bytes);
+
+	return (token);
+}
+
+void
+audit_use_of_x_privilege(uid_t uid, uid_t euid, gid_t gid, gid_t egid, au_id_t auid,
+	m_label_t *label, pid_t pid, int xevent_num, priv_set_t *priv) {
+	
+	adt_event_data_t *event;
+	au_asid_t asid;
+	au_tid_addr_t tid;
+	token_t *token1;
+	token_t *token2;
+	token_t *token3;
+	static int rd = -1;
+	char *privilege;
+
+	static adt_session_data_t *audit_handle = NULL;
+
+        if (!audit_handle) {
+                if (adt_start_session (&audit_handle, NULL,
+                                       ADT_USE_PROC_DATA) != 0) {
+                        audit_handle = NULL;
+                        return;
+                }
+        }
+        adt_set_user (audit_handle, uid, gid, euid,
+                      egid, NULL, ADT_UPDATE);
+
+        adt_get_asid(audit_handle, &asid);
+        adt_get_termid(audit_handle, &tid);
+        adt_get_auid(audit_handle, &auid);
+
+        event = adt_alloc_event (audit_handle, xevent_num);
+	adt_put_event (event, 0, 0);
+	adt_free_event (event);
+
+	rd = au_open ();
+	au_write (rd, au_to_subject_ex(
+		/*
+		 * The audit uid isn't valid in the caller, so
+		 * we're just using the real uid instead.
+		 * auid,
+		 */
+		uid,
+		uid,
+		gid,
+		euid,
+		egid,
+		pid,
+		asid,
+		&tid));
+
+	token1 = au_to_label (label);
+	au_write(rd, token1);
+	/*
+	token2 = au_to_privset("Inheritable", priv);
+	*/
+	privilege = priv_set_to_str(priv, ',', PRIV_STR_LIT);
+	token2 = au_to_upriv(1, privilege);
+	au_write(rd, token2);
+	token3 = au_to_return64(ADT_SUCCESS, (uint64_t)0);
+	au_write(rd, token3);
+	au_close (rd, AU_TO_WRITE, xevent_num, 2);
+	aw_free_tok(token1);
+	aw_free_tok(token2);
+	aw_free_tok(token3);
+	free(privilege);
+}
+
+
 /*
  * a u d i t w r i t e ( )
  *
@@ -425,9 +2028,11 @@
 	register int i;		/* counter */
 	int retval;		/* return value */
 
-	/* Is auditing even enabled?  If not, just exit */
-	if (cannot_audit(0) == 1)
-		AW_GEN_ERR(AW_ERR_AUDITON_FAIL);
+	/*
+	 * Using audit_use_of_x_privilege() instead because
+	 * of missing functionality in Solaris 11.4
+	 */
+	return (AW_SUCCESS_RTN);
 
 	/* Grab the lock */
 	(void) mutex_lock(&mutex_auditwrite);
@@ -574,18 +2179,18 @@
 		break;
 
 	case AW_NOPRESELECT_FLAG: {
-		auditinfo_addr_t auinfo;	/* temporary holder */
-
-		pmask.am_success = pmask.am_failure = 0;
+		adt_session_data_t	*ah;
 
 		/* Get the info from the proc */
-		if (getaudit_addr(&auinfo, sizeof (auinfo)) == -1) {
+		if (adt_start_session(&ah, NULL, ADT_USE_PROC_DATA) != 0) {
 			aw_set_err(AW_ERR_GETAUDIT_FAIL);
 			retval = AW_ERR_RTN;
 		}
 
 		/* Stuff the real values in */
-		pmask = auinfo.ai_mask;
+		adt_get_mask(ah, &pmask);
+
+		(void) adt_end_session(ah);
 
 		aw_static_flags &= ~AW_PRESELECT_FLAG;
 		break;
@@ -980,7 +2585,10 @@
 {
 	token_t *tokp;
 	gid_t gidset[NGROUPS_MAX];
-	auditinfo_addr_t auinfo;
+	adt_session_data_t      *ah;
+	au_asid_t		asid;
+	au_id_t			auid;
+	au_tid_addr_t		tid;
 	bslabel_t label_p;
 
 	/*
@@ -990,25 +2598,33 @@
 	if (AW_REC_SUBJECT_FLAG & aw_recs[rd]->aflags)
 		return (AW_SUCCESS_RTN);
 
-	if (getaudit_addr(&auinfo, sizeof (auinfo)) != 0)
+	if (adt_start_session(&ah, NULL, ADT_USE_PROC_DATA) != 0) {
 		AW_GEN_ERR(AW_ERR_GETAUDIT_FAIL);
+	} 
+	adt_get_asid(ah, &asid);
+	adt_get_termid(ah, &tid);
+	adt_get_auid(ah, &auid);
 
 	/*
 	 * Add the subject token using the values we have.
 	 * Append them to the record under construction
 	 */
 
-	if ((tokp = au_to_subject_ex(auinfo.ai_auid, geteuid(),
+	if ((tokp = au_to_subject_ex(auid, geteuid(),
 		    getegid(), getuid(), getgid(), getpid(),
-		    auinfo.ai_asid, &auinfo.ai_termid))
-		    == (token_t *)0)
+		    asid, &tid))
+		    == (token_t *)0) {
+		(void) adt_end_session(ah);
 		AW_GEN_ERR(AW_ERR_ALLOC_FAIL);
+	}
 	if (aw_buf_append(&(aw_recs[rd]->buf), &(aw_recs[rd]->len),
 		tokp->tt_data, (int)tokp->tt_size) ==
 		AW_ERR_RTN) {
+		(void) adt_end_session(ah);
 		aw_free_tok(tokp);
 		return (AW_ERR_RTN);
 	}
+	(void) adt_end_session(ah);
 	aw_free_tok(tokp);
 
 	/* Go grab the sensitivity label for this process */
@@ -1174,7 +2790,7 @@
 static int
 aw_gen_rec(int param, va_list arglist)
 {
-	void *ad[8];			/* attribute data */
+	void *ad[8] = { NULL };		/* attribute data */
 	token_t *tokp;			/* token for converted data */
 	int a;				/* invocation line argument */
 	au_event_ent_t *auevent;	/* event for this call */
@@ -1217,6 +2833,7 @@
 			 * simply allocate a new vattr and stuff
 			 * values in.
 			 */
+#if 0
 			vattr_t attr;
 
 			if (aw_chk_addr((caddr_t)ad[6]) == AW_ERR_RTN)
@@ -1238,6 +2855,7 @@
 				return (AW_ERR_RTN);
 			}
 			aw_free_tok(tokp);
+#endif
 			break;
 
 		}
@@ -1899,7 +3517,7 @@
 {
 	int a;
 	au_event_ent_t *auevent;
-	void *ad[8]; /* argument data */
+	void *ad[8] = { NULL }; /* argument data */
 
 	/*
 	 * During the port from TS 2, we had to slightly reorg code, thus
@@ -2221,8 +3839,8 @@
 	rec->context.static_flags = AW_NO_FLAGS;
 	rec->context.save_rd = AW_NO_RD;
 	rec->context.aw_errno = AW_ERR_NO_ERROR;
-	rec->context.pmask.am_success = 0;
-	rec->context.pmask.am_failure = 0;
+	rec->context.pmask.am_success = AU_MASK_NONE;
+	rec->context.pmask.am_failure = AU_MASK_NONE;
 }
 /*
  * a w _ r e c _ a l l o c ( )
@@ -2429,7 +4047,7 @@
 static int
 aw_init(void)
 {
-	auditinfo_addr_t auinfo;	/* tmp holder for masks */
+	adt_session_data_t	*ah;
 
 	aw_errno = AW_ERR_NO_ERROR;	/* No error so far */
 
@@ -2460,11 +4078,14 @@
 	 * to reduce system call overhead. If they change, we will be
 	 * auditing with stale values.
 	 */
-	if (getaudit_addr(&auinfo, sizeof (auinfo)) == -1)
+	if (adt_start_session(&ah, NULL, ADT_USE_PROC_DATA) != 0) {
 		AW_GEN_ERR(AW_ERR_GETAUDIT_FAIL);
+	}
 
 	/* Stuff the real values in */
-	pmask = auinfo.ai_mask;
+	adt_get_mask(ah, &pmask);
+
+	(void) adt_end_session(ah);
 
 	if (auditon(A_GETPOLICY, (caddr_t)&audit_policies, 0) == -1)
 		AW_GEN_ERR(AW_ERR_AUDIT_FAIL);
@@ -2485,7 +4106,7 @@
 aw_set_context(int param, va_list arglist)
 {
 	int a;
-	void *ad[8]; /* argument data */
+	void *ad[8] = { NULL }; /* argument data */
 
 	a = param;
 
diff -ur a/tsol/tsol.h b/tsol/tsol.h
--- a/tsol/tsol.h	2019-12-05 17:02:30.809986849 +0000
+++ b/tsol/tsol.h	2020-01-12 23:24:35.646924100 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -54,7 +54,7 @@
 
 #ifndef CALLBACK
 # define CALLBACK(name) void \
-name(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
+name(CallbackListPtr *pcbl, void *nulldata, void *calldata)
 #endif
 
 /* tsolutils.c */
@@ -98,7 +98,7 @@
 /* tsolprotocol.c */
 extern void UpdateTsolNode(Atom thisAtom, ClientPtr client);
 extern int TsolChangeWindowProperty(ClientPtr, WindowPtr, Atom, Atom, int, int,
-	unsigned long, pointer, Bool);
+	unsigned long, void *, Bool);
 extern int TsolDeleteProperty(ClientPtr, WindowPtr, Atom);
 extern int TsolInitWindow(ClientPtr, WindowPtr);
 extern int TsolInitPixmap(ClientPtr, PixmapPtr);
diff -ur a/tsol/tsolextension.c b/tsol/tsolextension.c
--- a/tsol/tsolextension.c	2019-12-05 17:02:30.814784883 +0000
+++ b/tsol/tsolextension.c	2020-01-13 09:04:36.803657703 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -155,11 +155,11 @@
 
 extern int tsol_check_policy(TsolInfoPtr tsolinfo, TsolResPtr tsolres,
 	xpolicy_t flags, int reqcode);
-extern void TsolCheckDrawableAccess(CallbackListPtr *pcbl, pointer nulldata,
-	pointer calldata);
-extern void TsolCheckXIDAccess(CallbackListPtr *pcbl, pointer nulldata,
-	pointer calldata);
-extern Bool client_has_privilege(TsolInfoPtr tsolinfo, priv_set_t *priv);
+extern void TsolCheckDrawableAccess(CallbackListPtr *pcbl, void *nulldata,
+	void *calldata);
+extern void TsolCheckXIDAccess(CallbackListPtr *pcbl, void *nulldata,
+	void *calldata);
+extern Bool client_has_privilege(TsolInfoPtr tsolinfo, priv_set_t *priv, int reqcode);
 
 extern priv_set_t *pset_win_mac_write;
 extern priv_set_t *pset_win_dac_write;
@@ -287,8 +287,6 @@
 	XaceRegisterCallback(XACE_SERVER_ACCESS, TsolCheckServerAccess, NULL);
 	XaceRegisterCallback(XACE_CLIENT_ACCESS, TsolCheckClientAccess, NULL);
 	XaceRegisterCallback(XACE_KEY_AVAIL, TsolProcessKeyboard, NULL);
-	XaceRegisterCallback(XACE_AUDIT_BEGIN, TsolAuditStart, NULL);
-	XaceRegisterCallback(XACE_AUDIT_END, TsolAuditEnd, NULL);
 
 	/* Save original Proc vectors */
 	for (i = 0; i < PROCVECTORSIZE; i++) {
@@ -399,8 +397,8 @@
 			priv_freeset(tsolinfo->privs);
 		}
 		/* Audit disconnect */
-		if (system_audit_on && (au_preselect(AUE_ClientDisconnect, &(tsolinfo->amask),
-                              AU_PRS_BOTH, AU_PRS_USECACHE) == 1)) {
+		if (au_preselect(AUE_ClientDisconnect, &(tsolinfo->amask),
+				 AU_PRS_BOTH, AU_PRS_USECACHE) == 1) {
 			auditwrite(AW_PRESELECT, &(tsolinfo->amask),AW_END);
 			auditwrite(AW_EVENTNUM, AUE_ClientDisconnect,
                                AW_XCLIENT, client->index,
@@ -439,8 +437,6 @@
     XaceDeleteCallback(XACE_SERVER_ACCESS, TsolCheckServerAccess, NULL);
     XaceDeleteCallback(XACE_CLIENT_ACCESS, TsolCheckClientAccess, NULL);
     XaceDeleteCallback(XACE_KEY_AVAIL, TsolProcessKeyboard, NULL);
-    XaceDeleteCallback(XACE_AUDIT_BEGIN, TsolAuditStart, NULL);
-    XaceDeleteCallback(XACE_AUDIT_END, TsolAuditEnd, NULL);
 }
 
 /*
@@ -704,7 +700,7 @@
     REQUEST_AT_LEAST_SIZE(xSetPolyInstInfoReq);
 
      /* Requires win_mac_write privilege */
-    if (!client_has_privilege(tsolinfo, pset_win_mac_write)) {
+    if (!client_has_privilege(tsolinfo, pset_win_mac_write, MAJOROP)) {
         return (BadAccess);
     }
 
@@ -764,7 +760,7 @@
     }
 
      /* Requires win_mac_write privilege */
-    if (!client_has_privilege(tsolinfo, pset_win_mac_write)) {
+    if (!client_has_privilege(tsolinfo, pset_win_mac_write, MAJOROP)) {
         return (BadAccess);
     }
 
@@ -826,7 +822,7 @@
     }
 
      /* Requires win_mac_write privilege */
-    if (!client_has_privilege(tsolinfo, pset_win_mac_write)) {
+    if (!client_has_privilege(tsolinfo, pset_win_mac_write, MAJOROP)) {
         return (BadAccess);
     }
 
@@ -854,7 +850,7 @@
     REQUEST_AT_LEAST_SIZE(xSetResLabelReq);
 
      /* Requires win_mac_write privilege */
-    if (!client_has_privilege(tsolinfo, pset_win_mac_write)) {
+    if (!client_has_privilege(tsolinfo, pset_win_mac_write, MAJOROP)) {
         return (BadAccess);
     }
 
@@ -1003,7 +999,7 @@
     }
 
      /* Requires win_dac_write privilege */
-    if (!client_has_privilege(tsolinfo, pset_win_dac_write)) {
+    if (!client_has_privilege(tsolinfo, pset_win_dac_write, MAJOROP)) {
         return (BadAccess);
     }
 
@@ -1380,7 +1376,7 @@
         PanoramiXRes     *panres = NULL;
         int         j;
 
-	rc = dixLookupResourceByType((pointer *) &panres, stuff->id,
+	rc = dixLookupResourceByType((void *) &panres, stuff->id,
 				     XRT_WINDOW, client, DixWriteAccess);
 	if (rc != Success)
 	    return rc;
@@ -1498,8 +1494,15 @@
     }
 
     tsolinfo = GetClientTsolInfo(client);
+    /*
+     * Why should this policy be enforced ?
+     *
+     * Seens to ignore the window parameter in stuff->id
+     * rc = dixLookupWindow(&pWin, stuff->id, client, DixWriteAccess);
+     *
     if (!HasTrustedPath(tsolinfo))
 	return (BadAccess);
+	*/
 
     tsolinfo->forced_trust = 0;
     tsolinfo->trusted_path = FALSE;
@@ -1539,7 +1542,7 @@
  */
 extern au_id_t ucred_getauid(const ucred_t *uc);
 extern au_asid_t ucred_getasid(const ucred_t *uc);
-extern const au_mask_t *ucred_getamask(const ucred_t *uc);
+extern const au_mask32_t *ucred_getamask(const ucred_t *uc);
 extern tsol_host_type_t tsol_getrhtype(char *);
 
 static void
@@ -1548,10 +1551,8 @@
 	bslabel_t *sl;
 	bslabel_t admin_low;
 	priv_set_t *privs;
-	const au_mask_t *amask;
+	const au_mask32_t *amask;
 	socklen_t namelen;
-	struct auditinfo auinfo;
-	struct auditinfo *pauinfo;
 	OsCommPtr oc = (OsCommPtr)client->osPrivate;
 	int fd = oc->fd;
 	ucred_t *uc = NULL;
@@ -1622,6 +1623,8 @@
 		tsolinfo->trusted_path = TRUE;
 	}else {
 		tsolinfo->trusted_path = FALSE;
+        	tsolinfo->flags |= TSOL_AUDITEVENT;
+        	tsolinfo->flags |= TSOL_DOXAUDIT;
 	}
 
 	if (tsolinfo->trusted_path || !tsolMultiLevel)
@@ -1661,11 +1664,6 @@
 	}
 
 	/* setup audit context */
-	if (getaudit(&auinfo) == 0) {
-	    pauinfo = &auinfo;
-	} else {
-	    pauinfo = NULL;
-	}
 
 	/* Audit id */
 	tsolinfo->auid = ucred_getauid(uc);
@@ -1678,14 +1676,14 @@
 
 	/* Audit mask */
 	if ((amask = ucred_getamask(uc)) != NULL) {
-	    tsolinfo->amask = *amask;
+	    tsolinfo->amask.am_failure = AU_CLASS_64(amask->am_failure_lo,
+	        amask->am_failure_hi);
+	    tsolinfo->amask.am_success = AU_CLASS_64(amask->am_success_lo,
+	        amask->am_success_hi);
 	} else {
-	    if (pauinfo != NULL) {
-	        tsolinfo->amask = pauinfo->ai_mask;
-	    } else {
-	        tsolinfo->amask.am_failure = 0; /* clear the masks */
-	        tsolinfo->amask.am_success = 0;
-	    }
+	    /* clear the masks */
+	    tsolinfo->amask.am_failure = AU_MASK_NONE;
+	    tsolinfo->amask.am_success = AU_MASK_NONE;
 	}
 
 	tsolinfo->asaverd = 0;
@@ -1754,7 +1752,7 @@
 }
 
 static Bool
-TsolCheckNetName (unsigned char *addr, short len, pointer closure)
+TsolCheckNetName (unsigned char *addr, short len, void *closure)
 {
     return (len == (short) strlen ((char *) closure) &&
             strncmp ((char *) addr, (char *) closure, len) == 0);
@@ -1779,24 +1777,6 @@
 	XID	auth_token = (XID)(-1);
 	TsolInfoPtr tsolinfo = GetClientTsolInfo(client);
 
-	if (tsolinfo->uid == (uid_t) -1) {
-		/* Retrieve uid from SecureRPC */
-		if (strncmp(name, SECURE_RPC_AUTH, (size_t)name_length) == 0) {
-			fullname = tsol_authdes_decode(data, data_length);
-			if (fullname == NULL) {
-				ErrorF("Unable to authenticate Secure RPC client");
-			} else {
-				if (netname2user(fullname,
-					&client_uid, &client_gid,
-					&client_gidlen, &client_gidlist)) {
-					tsolinfo->uid = client_uid;
-				} else {
-					ErrorF("netname2user failed");
-				}
-			}
-		}
-	}
-
 	if (tsolinfo->uid == (uid_t)-1) {
 		tsolinfo->uid = UID_NOBODY; /* uid not available */
 	}
@@ -1816,35 +1796,13 @@
 		 * Workstation Owner set, client must be within label
 		 * range or have trusted path
 		 */
-		if (tsolinfo->uid == OwnerUID) {
-			if ((tsolinfo->sl != NULL &&
-			     (bldominates(tsolinfo->sl, &SessionLO) &&
-			      bldominates(&SessionHI, tsolinfo->sl))) ||
-			    (HasTrustedPath(tsolinfo))) {
-			    auth_token = (XID)(tsolinfo->uid);
-			}
+		if ((tsolinfo->sl != NULL &&
+		     (bldominates(tsolinfo->sl, &SessionLO) &&
+		      bldominates(&SessionHI, tsolinfo->sl))) ||
+		    (HasTrustedPath(tsolinfo))) {
+			auth_token = (XID)(tsolinfo->uid);
 		} else {
-			/* Allow root from global zone */
-			if (tsolinfo->uid == 0 && HasTrustedPath(tsolinfo)) {
-				auth_token = (XID)(tsolinfo->uid);
-			} else {
-				/*
-				 * Access check based on uid. Check if
-				 * roles or other uids have  been added by
-				 * xhost +role@
-				 */
-				getdomainname(domainname, sizeof(domainname));
-				if (!user2netname(netname, tsolinfo->uid, domainname)) {
-					return ((XID)-1);
-				}
-				if (ForEachHostInFamily (FamilyNetname, TsolCheckNetName,
-						(pointer) netname)) {
-					return ((XID)(tsolinfo->uid));
-				} else {
-					return (CheckAuthorization(name_length, name, data_length,
-						data, client, reason));
-				}
-			}
+			auth_token = ((XID)-1);
 		}
 	}
 
@@ -1857,9 +1815,8 @@
 		audit_val = 0;
 	}
 
-	if (system_audit_on &&
-		(au_preselect(AUE_ClientConnect, &(tsolinfo->amask),
-                      AU_PRS_BOTH, AU_PRS_USECACHE) == 1)) {
+	if (au_preselect(AUE_ClientConnect, &(tsolinfo->amask),
+			 AU_PRS_BOTH, AU_PRS_USECACHE) == 1) {
 		int status;
 		ushort_t connect_port = 0;
 		struct in_addr *connect_addr = NULL;
@@ -2174,6 +2131,13 @@
 	        flags = (TSOL_MAC|TSOL_DAC|TSOL_WRITEOP);
 
 	    retcode = tsol_check_policy(tsolinfo, tsolprop, flags, MAJOROP_CODE);
+	    /*
+	     * cleanup properties created by gdm (uid = 50) 
+	     */
+	    if (retcode == Success && (access_mode & DixWriteAccess) &&
+		WindowIsRoot(pWin) && tsolprop->uid == 50)
+		    tsolprop->uid = tsolinfo->uid;
+
 	    if (retcode != Success && (access_mode & DixGetAttrAccess)) {
 		/* If current property is not accessible, move on to
 		 *  next one for ListProperty
diff -ur a/tsol/tsolextension.h b/tsol/tsolextension.h
--- a/tsol/tsolextension.h	2019-12-05 17:02:30.815249756 +0000
+++ b/tsol/tsolextension.h	2020-01-12 23:24:35.647779692 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -40,5 +40,5 @@
 #include <X11/extensions/Xtsolproto.h>
 
 /* tsolextension.c */
-extern void TsolExtensionInit(void);
+_X_EXPORT extern void TsolExtensionInit(void);
 #endif /* _XORG_TSOL_EXTENSION_H */
diff -ur a/tsol/tsolinfo.h b/tsol/tsolinfo.h
--- a/tsol/tsolinfo.h	2019-12-05 17:02:30.824378910 +0000
+++ b/tsol/tsolinfo.h	2020-01-12 23:24:35.647967665 +0000
@@ -337,7 +337,6 @@
 extern  int PolySelection(Atom atom);
 extern  TsolPolyInstInfoRec tsolpolyinstinfo;
 extern  uid_t OwnerUID;                 /* Workstation owner uid */
-extern Bool system_audit_on;
 
 /*********************************
  *
diff -ur a/tsol/tsolpolicy.c b/tsol/tsolpolicy.c
--- a/tsol/tsolpolicy.c	2019-12-05 17:02:30.829452198 +0000
+++ b/tsol/tsolpolicy.c	2020-01-12 23:24:35.648186023 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -86,12 +86,13 @@
 #endif /* NO_TSOL_DEBUG_MESSAGES */
 
 extern int tsol_mac_enabled;
+extern void tsol_audit_priv(TsolInfoPtr tsolinfo, int protocol, priv_set_t *priv);
 
 static void
 set_audit_flags(TsolInfoPtr tsolinfo)
 {
-    if (tsolinfo->flags & TSOL_AUDITEVENT)
-        tsolinfo->flags &= ~TSOL_AUDITEVENT;
+    if (!tsolinfo->flags & TSOL_AUDITEVENT)
+        tsolinfo->flags |= TSOL_AUDITEVENT;
     if (!(tsolinfo->flags & TSOL_DOXAUDIT))
         tsolinfo->flags |= TSOL_DOXAUDIT;
 
@@ -113,7 +114,7 @@
  */
 
 Bool
-client_has_privilege(TsolInfoPtr tsolinfo, priv_set_t *priv)
+client_has_privilege(TsolInfoPtr tsolinfo, priv_set_t *priv, int reqcode)
 {
 
 	if (tsolinfo->privs == NULL) {
@@ -122,8 +123,11 @@
 
 	if (priv_issubset(priv, tsolinfo->privs)) {
 		if (tsolinfo->flags & TSOL_AUDITEVENT) {
+			tsol_audit_priv(tsolinfo, reqcode, priv);
+			/*
 			auditwrite(AW_USEOFPRIV, AUDIT_SUCCESS, priv,
 				AW_APPEND, AW_END);
+			*/
 		}
 
 		return TRUE;
@@ -154,8 +158,8 @@
 				reqcode != X_GetImage) ||
 			    ((flags & TSOL_DOMINATE) &&
 				bldominates(tsolinfo->sl, tsolres->sl)) ||
-			    client_has_privilege(tsolinfo, pset_win_mac_read) ||
-			    HasTrustedPath(tsolinfo)) {
+			        HasTrustedPath(tsolinfo) ||
+			        client_has_privilege(tsolinfo, pset_win_mac_read, reqcode)) {
 
 				status = Success;
 			} else {
@@ -165,7 +169,7 @@
 
 		if (flags & TSOL_WRITEOP) {
 			if (blequal(tsolinfo->sl, tsolres->sl) ||
-			    client_has_privilege(tsolinfo, pset_win_mac_write)) {
+			    client_has_privilege(tsolinfo, pset_win_mac_write, reqcode)) {
 				status = Success;
 			} else {
 				goto bad;
@@ -181,7 +185,7 @@
 			    ((tsolres->uid == OwnerUID) &&
 			    /* ((tsolres->uid == OwnerUID || tsolres->uid == DEF_UID) &&  */
 			    blequal(tsolres->sl, &PublicObjSL)) ||
-			    client_has_privilege(tsolinfo, pset_win_dac_read)) {
+			    client_has_privilege(tsolinfo, pset_win_dac_read, reqcode)) {
 
 				status = Success;
 			} else {
@@ -193,7 +197,7 @@
 			if ((tsolinfo->uid == tsolres->uid) ||
 			   (tsolinfo->uid == OwnerUID &&
                                reqcode == X_ChangeWindowAttributes) ||
-			    client_has_privilege(tsolinfo, pset_win_dac_write)) {
+			    client_has_privilege(tsolinfo, pset_win_dac_write, reqcode)) {
 
 				status = Success;
 			} else {
@@ -298,7 +302,7 @@
 }
 
 void
-TsolCheckDrawableAccess(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
+TsolCheckDrawableAccess(CallbackListPtr *pcbl, void *nulldata, void *calldata)
 {
 	XaceResourceAccessRec *rec = calldata;
 	ClientPtr client = rec->client;
@@ -315,7 +319,7 @@
 
 	Mask check_mode = access_mode;
 	TsolInfoPtr tsolinfo = GetClientTsolInfo(client);
-	TsolResPtr  tsolres;
+	TsolResPtr  tsolres = NULL;
 	xpolicy_t flags;
 	int reqtype;
 
@@ -396,7 +400,7 @@
 		modes = (DixManageAccess|DixSetAttrAccess);
 		if (check_mode & modes) {
 			if (priv_win_config ||
-				client_has_privilege(tsolinfo, pset_win_config)) {
+				client_has_privilege(tsolinfo, pset_win_config, reqtype)) {
 				status = Success;
 			}
 			check_mode &= ~modes;
@@ -497,7 +501,7 @@
 }
 
 void
-TsolCheckXIDAccess(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
+TsolCheckXIDAccess(CallbackListPtr *pcbl, void *nulldata, void *calldata)
 {
 	XaceResourceAccessRec *rec = calldata;
 	ClientPtr client = rec->client;
@@ -537,6 +541,7 @@
 		break;
 	default:
 		err_code = BadValue;
+		object_code = AW_END;
 		break;
 	}
 
@@ -550,7 +555,7 @@
 	modes = (DixReadAccess|DixGetAttrAccess|DixUseAccess);
 	if (check_mode & modes) {
 		if (!client_private(client, id) &&
-			(!client_has_privilege(tsolinfo, pset_win_dac_read))) {
+			(!client_has_privilege(tsolinfo, pset_win_dac_read, reqtype))) {
 			rec->status = err_code;
 		}
 		check_mode &= ~modes;
@@ -559,7 +564,7 @@
 	modes = (DixWriteAccess|DixSetAttrAccess|DixDestroyAccess);
 	if (check_mode & modes) {
 		if (!client_private(client, id) &&
-			(!client_has_privilege(tsolinfo, pset_win_dac_write))) {
+			(!client_has_privilege(tsolinfo, pset_win_dac_write, reqtype))) {
 			rec->status = err_code;
 		}
 		check_mode &= ~modes;
@@ -596,7 +601,7 @@
 }
 
 void
-TsolCheckServerAccess(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
+TsolCheckServerAccess(CallbackListPtr *pcbl, void *nulldata, void *calldata)
 {
 	XaceServerAccessRec *rec = calldata;
 	ClientPtr client = rec->client;
@@ -624,7 +629,7 @@
 		case X_SetFontPath:
 			if (priv_win_fontpath ||
 				client_has_privilege(tsolinfo,
-						     pset_win_fontpath)) {
+						     pset_win_fontpath, reqtype)) {
 				rec->status = Success;
 			}
 			object_code = AW_XFONT;
@@ -634,7 +639,7 @@
 		case X_SetAccessControl:
 			if (priv_win_config ||
 				client_has_privilege(tsolinfo,
-						     pset_win_config)) {
+						     pset_win_config, reqtype)) {
 				rec->status = Success;
 			}
 			object_code = AW_XCLIENT;
@@ -683,7 +688,7 @@
 }
 
 void
-TsolCheckClientAccess(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
+TsolCheckClientAccess(CallbackListPtr *pcbl, void *nulldata, void *calldata)
 {
 	XaceClientAccessRec *rec = calldata;
 	ClientPtr client = rec->client;
@@ -705,7 +710,7 @@
 	modes = (DixManageAccess|DixDestroyAccess);
 	if (check_mode & modes) {
 		if (priv_win_config ||
-		    client_has_privilege(tsolinfo, pset_win_config)) {
+		    client_has_privilege(tsolinfo, pset_win_config, reqtype)) {
 			rec->status = Success;
 		}
 		check_mode &= ~modes;
@@ -744,7 +749,7 @@
 }
 
 void
-TsolCheckDeviceAccess(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
+TsolCheckDeviceAccess(CallbackListPtr *pcbl, void *nulldata, void *calldata)
 {
 	XaceDeviceAccessRec *rec = (XaceDeviceAccessRec *) calldata;
 	ClientPtr client = rec->client;
@@ -783,7 +788,7 @@
 		 DixWriteAccess);
 	if (check_mode & modes) {
 		if (priv_win_devices ||
-		    client_has_privilege(tsolinfo, pset_win_devices))
+		    client_has_privilege(tsolinfo, pset_win_devices, reqtype))
 			rec->status = Success;
 		if (tsolinfo->flags & TSOL_AUDITEVENT) {
 		    set_audit_flags(tsolinfo);
diff -ur a/tsol/tsolprotocol.c b/tsol/tsolprotocol.c
--- a/tsol/tsolprotocol.c	2019-12-05 17:02:30.830734998 +0000
+++ b/tsol/tsolprotocol.c	2020-01-12 23:24:35.648855069 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -175,7 +175,9 @@
 extern TsolResPtr TsolDrawablePrivateate(DrawablePtr pDraw, ClientPtr client);
 extern int tsol_check_policy(TsolInfoPtr tsolinfo, TsolResPtr tsolres,
 			     xpolicy_t flags, int reqcode);
-extern Bool client_has_privilege(TsolInfoPtr tsolinfo, priv_set_t *priv);
+extern Bool client_has_privilege(TsolInfoPtr tsolinfo, priv_set_t *priv, int reqcode);
+extern void audit_use_of_x_privilege(uid_t uid, uid_t euid, gid_t gid, gid_t egid,
+	au_id_t auid, m_label_t *label, pid_t pid, int xevent_num, priv_set_t *priv);
 
 
 #define INITIAL_TSOL_NODELENGTH 1500
@@ -456,7 +458,7 @@
 	int         j;
 
 	if (tpwin) {
-	    rc = dixLookupResourceByType((pointer *) &panres,
+	    rc = dixLookupResourceByType((void *) &panres,
 					 tpwin->drawable.id, XRT_WINDOW,
 					 client, DixReadAccess);
 	    if (rc != Success)
@@ -688,7 +690,7 @@
     REQUEST_SIZE_MATCH(xReq);
 
     if (priv_win_config ||
-		client_has_privilege(tsolinfo, pset_win_config)) {
+		client_has_privilege(tsolinfo, pset_win_config, MAJOROP)) {
     	return (*TsolSavedProcVector[X_GrabServer])(client);
     } else {
 	/* turn off auditing because operation ignored */
@@ -708,7 +710,7 @@
     REQUEST_SIZE_MATCH(xReq);
 
     if (priv_win_config ||
-		client_has_privilege(tsolinfo, pset_win_config)) {
+		client_has_privilege(tsolinfo, pset_win_config, MAJOROP)) {
         return (*TsolSavedProcVector[X_UngrabServer])(client);
     } else {
 	/* turn off auditing because operation ignored */
@@ -822,8 +824,7 @@
     Bool audit_event = FALSE;
     TsolInfoPtr tsolinfo = (TsolInfoPtr)NULL;
     tsolinfo = GetClientTsolInfo(client);
-    if (system_audit_on &&
-	(tsolinfo->amask.am_success || tsolinfo->amask.am_failure)) {
+    if (tsolinfo->amask.am_success || tsolinfo->amask.am_failure) {
 
 	do_x_audit = TRUE;
         auditwrite(AW_PRESELECT, &(tsolinfo->amask), AW_END);
@@ -878,7 +879,7 @@
     ClientPtr client = rec->client;
     int result = rec->requestResult;
 
-    char audit_ret = (char)NULL;
+    char audit_ret = 0;
     TsolInfoPtr tsolinfo = GetClientTsolInfo(client);
 
     if (tsolinfo->flags & TSOL_DOXAUDIT)
@@ -1030,7 +1031,7 @@
     if (tsol_check_policy(tsolinfo, tsolres, flags, MAJOROP_CODE) == Success)
     {
 	return DoGetImage(client, format, drawable, x, y,
-		width, height, planemask, im_return);
+		width, height, planemask);
     }
 
     if (pDraw->type == DRAWABLE_WINDOW)
@@ -1221,7 +1222,7 @@
 				         nlines,
 				         format,
 				         planemask,
-				         (pointer) pBuf);
+				         (void *) pBuf);
 #ifdef TSOL
         if (not_root_window)
         {
@@ -1279,7 +1280,7 @@
 				                 nlines,
 				                 format,
 				                 plane,
-				                 (pointer)pBuf);
+				                 (void *)pBuf);
 #ifdef TSOL
                 if (not_root_window)
                 {
@@ -1502,3 +1503,37 @@
 
     return (status);
 }
+
+void
+tsol_audit_priv(TsolInfoPtr tsolinfo, int protocol, priv_set_t *priv) {
+    int xevent_num = 0;
+    uid_t uid, euid;
+    gid_t gid, egid;
+    pid_t pid;
+    au_id_t auid;
+    m_label_t *label;
+    int count;
+
+
+	if (protocol > X_NoOperation) {
+             xevent_num = audit_eventsid[MAX_AUDIT_EVENTS - 1][1];
+	} else {
+            for (count = 0; count < MAX_AUDIT_EVENTS; count++) {
+                 if (protocol == audit_eventsid[count][0]) {
+                 	xevent_num = audit_eventsid[count][1];
+                        break;
+                  }
+	    }
+	}
+	if (xevent_num == 0)
+		return;
+	uid = tsolinfo->uid;
+	euid = tsolinfo->euid;
+	gid = tsolinfo->gid;
+	egid = tsolinfo->egid;
+	pid = tsolinfo->pid;
+	auid = tsolinfo->auid;
+	label = tsolinfo->sl;
+
+	audit_use_of_x_privilege(uid, euid, gid, egid, auid, label, pid, xevent_num, priv);
+}
diff -ur a/tsol/tsolutils.c b/tsol/tsolutils.c
--- a/tsol/tsolutils.c	2019-12-05 17:02:30.831534519 +0000
+++ b/tsol/tsolutils.c	2020-01-12 23:24:35.649097075 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2015, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -62,7 +62,6 @@
 	( ((b1)->y2 <= (b2)->y1)) || \
 	( ((b1)->y1 >= (b2)->y2)) ) )
 
-Bool system_audit_on = FALSE;
 Bool priv_win_colormap = FALSE;
 Bool priv_win_config = FALSE;
 Bool priv_win_devices = FALSE;
@@ -410,8 +409,6 @@
 	return (0);
 }
 
-extern int cannot_audit(int);	/* bsm function */
-
 void
 init_xtsol(void)
 {
@@ -421,11 +418,6 @@
 	init_TSOL_cached_SL();
 	init_TSOL_uid_table();
 
-	if (cannot_audit(TRUE))
-		system_audit_on = FALSE;
-	else
-		system_audit_on = TRUE;
-
 	auditwrite(AW_QUEUE, XAUDIT_Q_SIZE, AW_END);
 }
 
@@ -638,6 +630,7 @@
 		value = strtok(NULL, " \t\n");
 		UpdateTsolConfig(keyword, value);
 	}
+	fclose(fp);
 
 	InitPrivileges();
 }
