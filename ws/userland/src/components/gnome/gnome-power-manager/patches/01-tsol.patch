diff -urN ../g1/gnome-power-manager-2.24.4/Makefile.am gnome-power-manager-2.24.4/Makefile.am
--- ../g1/gnome-power-manager-2.24.4/Makefile.am	2008-09-04 03:05:20.000000000 +0000
+++ gnome-power-manager-2.24.4/Makefile.am	2020-04-05 17:21:08.000000000 +0000
@@ -1,5 +1,20 @@
 
 ACLOCAL_AMFLAGS = -I m4
+LIBNOTIFY_CFLAGS = -D_REENTRANT -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+HAL_CFLAGS = -DDBUS_API_SUBJECT_TO_CHANGE -I/usr/include/hal -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include
+GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+GDK_CFLAGS = -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -I/usr/include/gtk-3.0 -I/usr/include/gio-unix-2.0/ -I/usr/include/cairo -I/usr/include/pango-1.0 -I/usr/include/harfbuzz -I/usr/include/pango-1.0 -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/cairo -I/usr/include/pixman-1 -I/usr/include/freetype2 -I/usr/include/libdrm -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+DBUS_CFLAGS = -D_REENTRANT -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+
+GLIB_LIBS = -L/usr/lib/amd64 -lgobject-2.0 -lglib-2.0
+GPM_EXTRA_LIBS = -lresolv -lXext -lkstat -lgconf-2
+HAL_LIBS = -L/usr/lib/amd64 -lhal -ldbus-1
+LIBNOTIFY_LIBS = -L/usr/lib/amd64 -lnotify
+XRANDR_LIBS = -lXrandr -lXrender -lX11
+X_PRE_LIBS =  -lSM -lICE
+CAIRO_LIBS = -L/usr/lib/amd64 -lcairo -lpangocairo-1.0 -lpango-1.0 -latk-1.0 -lcairo-gobject -lgdk_pixbuf-2.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0
+DBUS_LIBS =  -L/usr/lib/amd64 -ldbus-glib-1 -lgobject-2.0 -ldbus-1 -lgthread-2.0
+GDK_LIBS = -L/usr/lib/amd64 -lgdk-3 -lgdk_pixbuf-2.0  -lgobject-2.0 -lglib-2.0
 
 SUBDIRS =						\
 	libdbus-glib					\
@@ -11,13 +26,8 @@
 	docs						\
 	man						\
 	data						\
-	help						\
 	tools
 
-if HAVE_APPLETS
-SUBDIRS += applets
-endif
-
 if HAVE_TESTS
 SUBDIRS += test
 endif
diff -urN ../g1/gnome-power-manager-2.24.4/Makefile.in gnome-power-manager-2.24.4/Makefile.in
--- ../g1/gnome-power-manager-2.24.4/Makefile.in	2009-02-12 03:47:35.000000000 +0000
+++ gnome-power-manager-2.24.4/Makefile.in	2020-04-06 12:43:17.000000000 +0000
@@ -31,7 +31,6 @@
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
-@HAVE_APPLETS_TRUE@am__append_1 = applets
 @HAVE_TESTS_TRUE@am__append_2 = test
 subdir = .
 DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
@@ -66,7 +65,7 @@
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = libdbus-glib libhal-glib libidletime libunique src po \
-	docs man data help tools applets test
+	docs man data tools test
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -98,8 +97,8 @@
 CYGPATH_W = @CYGPATH_W@
 DATADIR = @DATADIR@
 DATADIRNAME = @DATADIRNAME@
-DBUS_CFLAGS = @DBUS_CFLAGS@
-DBUS_LIBS = @DBUS_LIBS@
+DBUS_CFLAGS = -D_REENTRANT -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+DBUS_LIBS = -L/usr/lib/amd64 -ldbus-glib-1 -lgobject-2.0 -ldbus-1 -lgthread-2.0
 DBUS_REQUIRED = @DBUS_REQUIRED@
 DBUS_SERVICES_DIR = @DBUS_SERVICES_DIR@
 DEFS = @DEFS@
@@ -119,26 +118,26 @@
 GCONFTOOL = @GCONFTOOL@
 GCONF_SCHEMA_CONFIG_SOURCE = @GCONF_SCHEMA_CONFIG_SOURCE@
 GCONF_SCHEMA_FILE_DIR = @GCONF_SCHEMA_FILE_DIR@
-GDK_CFLAGS = @GDK_CFLAGS@
-GDK_LIBS = @GDK_LIBS@
+GDK_CFLAGS = -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -I/usr/include/gtk-3.0 -I/usr/include/gio-unix-2.0/ -I/usr/include/cairo -I/usr/include/pango-1.0 -I/usr/include/harfbuzz -I/usr/include/pango-1.0 -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/cairo -I/usr/include/pixman-1 -I/usr/include/freetype2 -I/usr/include/libdrm -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+GDK_LIBS = -L/usr/lib/amd64 -lgdk-3 -lgdk_pixbuf-2.0  -lgobject-2.0 -lglib-2.0
 GDK_REQUIRED = @GDK_REQUIRED@
 GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
 GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GLIB_LIBS = @GLIB_LIBS@
+GLIB_LIBS = -L/usr/lib/amd64 -lgobject-2.0 -lglib-2.0
 GLIB_REQUIRED = @GLIB_REQUIRED@
 GMOFILES = @GMOFILES@
 GMSGFMT = @GMSGFMT@
 GNOME_CFLAGS = @GNOME_CFLAGS@
 GNOME_LIBS = @GNOME_LIBS@
-GPM_EXTRA_LIBS = @GPM_EXTRA_LIBS@
+GPM_EXTRA_LIBS = -lresolv -lXext -lkstat -lgconf-2 -lm
 GREP = @GREP@
 GSTREAMER_CFLAGS = @GSTREAMER_CFLAGS@
 GSTREAMER_LIBS = @GSTREAMER_LIBS@
 GSTREAMER_REQUIRED = @GSTREAMER_REQUIRED@
 GTK_REQUIRED = @GTK_REQUIRED@
-HAL_CFLAGS = @HAL_CFLAGS@
-HAL_LIBS = @HAL_LIBS@
+HAL_CFLAGS = -DDBUS_API_SUBJECT_TO_CHANGE -I/usr/include/hal -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include
+HAL_LIBS = -L/usr/lib/amd64 -lhal -ldbus-1
 HAL_REQUIRED = @HAL_REQUIRED@
 HELP_DIR = @HELP_DIR@
 INSTALL = @INSTALL@
@@ -174,10 +173,9 @@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
 LIBGLADE_REQUIRED = @LIBGLADE_REQUIRED@
-LIBGNOMEUI_REQUIRED = @LIBGNOMEUI_REQUIRED@
 LIBGNOME_REQUIRED = @LIBGNOME_REQUIRED@
-LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
-LIBNOTIFY_LIBS = @LIBNOTIFY_LIBS@
+LIBNOTIFY_CFLAGS = -D_REENTRANT -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+LIBNOTIFY_LIBS = -L/usr/lib/amd64 -lnotify
 LIBNOTIFY_REQUIRED = @LIBNOTIFY_REQUIRED@
 LIBOBJS = @LIBOBJS@
 LIBPANEL_REQUIRED = @LIBPANEL_REQUIRED@
@@ -234,12 +232,12 @@
 XMKMF = @XMKMF@
 XMLTO = @XMLTO@
 XRANDR_CFLAGS = @XRANDR_CFLAGS@
-XRANDR_LIBS = @XRANDR_LIBS@
+XRANDR_LIBS = -lXrandr -lXrender -lX11
 XRANDR_REQUIRED = @XRANDR_REQUIRED@
 X_CFLAGS = @X_CFLAGS@
 X_EXTRA_LIBS = @X_EXTRA_LIBS@
 X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
+X_PRE_LIBS = -lSM -lICE
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
 abs_top_builddir = @abs_top_builddir@
@@ -293,8 +291,9 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 ACLOCAL_AMFLAGS = -I m4
+CAIRO_LIBS = -L/usr/lib/amd64 -lcairo -lpangocairo-1.0 -lpango-1.0 -latk-1.0 -lcairo-gobject -lgdk_pixbuf-2.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0
 SUBDIRS = libdbus-glib libhal-glib libidletime libunique src po docs \
-	man data help tools $(am__append_1) $(am__append_2)
+	man data tools $(am__append_2)
 EXTRA_DIST = \
 	HACKING						\
 	MAINTAINERS					\
diff -urN ../g1/gnome-power-manager-2.24.4/configure gnome-power-manager-2.24.4/configure
--- ../g1/gnome-power-manager-2.24.4/configure	2009-02-12 03:47:36.000000000 +0000
+++ gnome-power-manager-2.24.4/configure	2020-04-06 12:32:30.000000000 +0000
@@ -12449,7 +12449,7 @@
 
 
 if test "$GCC" = "yes"; then
-    CPPFLAGS="$CPPFLAGS -Werror -Wcast-align -Wno-uninitialized"
+    CPPFLAGS="$CPPFLAGS -Wcast-align -Wno-uninitialized"
     CPPFLAGS="$CPPFLAGS -Wall -Wformat-security -Wno-strict-aliasing"
 fi
 
@@ -14054,20 +14054,20 @@
 
 
 GLIB_REQUIRED=2.13.0
-GTK_REQUIRED=2.11.0
-GDK_REQUIRED=2.11.0
-GNOME_KEYRING_REQUIRED=0.6.0
+GTK_REQUIRED=3.0.0
+GDK_REQUIRED=3.0.0
+GNOME_KEYRING_REQUIRED=3.0.0
 LIBGNOME_REQUIRED=2.14.0
 LIBGNOMEUI_REQUIRED=2.14.0
 HAL_REQUIRED=0.5.8
-DBUS_REQUIRED=0.70
+DBUS_REQUIRED=1.0.0
 LIBGLADE_REQUIRED=2.5.0
 LIBNOTIFY_REQUIRED=0.4.3
-LIBWNCK_REQUIRED=2.10.0
+LIBWNCK_REQUIRED=3.0.0
 CAIRO_REQUIRED=1.0.0
 UNIQUE_REQUIRED=0.9.4
 LIBPANEL_REQUIRED=2.0.0
-GSTREAMER_REQUIRED=0.10
+GSTREAMER_REQUIRED=1.0
 XRANDR_REQUIRED=1.2.0
 POLKIT_GNOME_REQUIRED=0.8
 
@@ -14321,12 +14321,12 @@
     pkg_cv_GSTREAMER_CFLAGS="$GSTREAMER_CFLAGS"
  elif test -n "$PKG_CONFIG"; then
     if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gstreamer-0.10 >= \$GSTREAMER_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED") 2>&5
+    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gstreamer-1.0 >= \$GSTREAMER_REQUIRED\"") >&5
+  ($PKG_CONFIG --exists --print-errors "gstreamer-1.0 >= $GSTREAMER_REQUIRED") 2>&5
   ac_status=$?
   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_GSTREAMER_CFLAGS=`$PKG_CONFIG --cflags "gstreamer-0.10 >= $GSTREAMER_REQUIRED" 2>/dev/null`
+  pkg_cv_GSTREAMER_CFLAGS=`$PKG_CONFIG --cflags "gstreamer-1.0 >= $GSTREAMER_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -14337,12 +14337,12 @@
     pkg_cv_GSTREAMER_LIBS="$GSTREAMER_LIBS"
  elif test -n "$PKG_CONFIG"; then
     if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gstreamer-0.10 >= \$GSTREAMER_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED") 2>&5
+    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gstreamer-1.0 >= \$GSTREAMER_REQUIRED\"") >&5
+  ($PKG_CONFIG --exists --print-errors "gstreamer-1.0 >= $GSTREAMER_REQUIRED") 2>&5
   ac_status=$?
   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_GSTREAMER_LIBS=`$PKG_CONFIG --libs "gstreamer-0.10 >= $GSTREAMER_REQUIRED" 2>/dev/null`
+  pkg_cv_GSTREAMER_LIBS=`$PKG_CONFIG --libs "gstreamer-1.0 >= $GSTREAMER_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -14360,14 +14360,14 @@
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        GSTREAMER_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED" 2>&1`
+	        GSTREAMER_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gstreamer-1.0 >= $GSTREAMER_REQUIRED" 2>&1`
         else
-	        GSTREAMER_PKG_ERRORS=`$PKG_CONFIG --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED" 2>&1`
+	        GSTREAMER_PKG_ERRORS=`$PKG_CONFIG --print-errors "gstreamer-1.0 >= $GSTREAMER_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$GSTREAMER_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gstreamer-0.10 >= $GSTREAMER_REQUIRED) were not met:
+	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gstreamer-1.0 >= $GSTREAMER_REQUIRED) were not met:
 
 $GSTREAMER_PKG_ERRORS
 
@@ -14378,7 +14378,7 @@
 and GSTREAMER_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 " >&5
-$as_echo "$as_me: error: Package requirements (gstreamer-0.10 >= $GSTREAMER_REQUIRED) were not met:
+$as_echo "$as_me: error: Package requirements (gstreamer-1.0 >= $GSTREAMER_REQUIRED) were not met:
 
 $GSTREAMER_PKG_ERRORS
 
@@ -14576,31 +14576,22 @@
  elif test -n "$PKG_CONFIG"; then
     if test -n "$PKG_CONFIG" && \
     { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"
- libgnomeui-2.0 >= \$LIBGNOMEUI_REQUIRED
- libglade-2.0 >= \$LIBGLADE_REQUIRED
- libwnck-1.0 >= \$LIBWNCK_REQUIRED
- gtk+-2.0 >= \$GTK_REQUIRED
+ libwnck-3.0 >= \$LIBWNCK_REQUIRED
+ gtk+-3.0 >= \$GTK_REQUIRED
  gnome-keyring-1 >= \$GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= \$LIBPANEL_REQUIRED
  cairo >= \$CAIRO_REQUIRED\"") >&5
   ($PKG_CONFIG --exists --print-errors "
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED") 2>&5
   ac_status=$?
   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   pkg_cv_GNOME_CFLAGS=`$PKG_CONFIG --cflags "
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
@@ -14613,31 +14604,22 @@
  elif test -n "$PKG_CONFIG"; then
     if test -n "$PKG_CONFIG" && \
     { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"
- libgnomeui-2.0 >= \$LIBGNOMEUI_REQUIRED
- libglade-2.0 >= \$LIBGLADE_REQUIRED
- libwnck-1.0 >= \$LIBWNCK_REQUIRED
- gtk+-2.0 >= \$GTK_REQUIRED
+ libwnck-3.0 >= \$LIBWNCK_REQUIRED
+ gtk+-3.0 >= \$GTK_REQUIRED
  gnome-keyring-1 >= \$GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= \$LIBPANEL_REQUIRED
  cairo >= \$CAIRO_REQUIRED\"") >&5
   ($PKG_CONFIG --exists --print-errors "
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED") 2>&5
   ac_status=$?
   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   pkg_cv_GNOME_LIBS=`$PKG_CONFIG --libs "
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
@@ -14657,33 +14639,24 @@
 fi
         if test $_pkg_short_errors_supported = yes; then
 	        GNOME_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED" 2>&1`
         else
 	        GNOME_PKG_ERRORS=`$PKG_CONFIG --print-errors "
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$GNOME_PKG_ERRORS" >&5
 
 	{ { $as_echo "$as_me:$LINENO: error: Package requirements (
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED) were not met:
 
 $GNOME_PKG_ERRORS
@@ -14696,12 +14669,9 @@
 See the pkg-config man page for more details.
 " >&5
 $as_echo "$as_me: error: Package requirements (
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
  cairo >= $CAIRO_REQUIRED) were not met:
 
 $GNOME_PKG_ERRORS
diff -urN ../g1/gnome-power-manager-2.24.4/configure.ac gnome-power-manager-2.24.4/configure.ac
--- ../g1/gnome-power-manager-2.24.4/configure.ac	2009-02-12 03:47:24.000000000 +0000
+++ gnome-power-manager-2.24.4/configure.ac	2020-04-05 17:47:22.000000000 +0000
@@ -22,7 +22,7 @@
 dnl - Extra verbose warning switches
 dnl ---------------------------------------------------------------------------
 if test "$GCC" = "yes"; then
-    CPPFLAGS="$CPPFLAGS -Werror -Wcast-align -Wno-uninitialized"
+    CPPFLAGS="$CPPFLAGS -Wcast-align -Wno-uninitialized"
     CPPFLAGS="$CPPFLAGS -Wall -Wformat-security -Wno-strict-aliasing"
 fi
 
@@ -51,11 +51,10 @@
 dnl - Library dependencies
 dnl ---------------------------------------------------------------------------
 GLIB_REQUIRED=2.13.0
-GTK_REQUIRED=2.11.0
-GDK_REQUIRED=2.11.0
+GTK_REQUIRED=3.0.0
+GDK_REQUIRED=3.0.0
 GNOME_KEYRING_REQUIRED=0.6.0
 LIBGNOME_REQUIRED=2.14.0
-LIBGNOMEUI_REQUIRED=2.14.0
 HAL_REQUIRED=0.5.8
 DBUS_REQUIRED=0.70
 LIBGLADE_REQUIRED=2.5.0
@@ -64,7 +63,9 @@
 CAIRO_REQUIRED=1.0.0
 UNIQUE_REQUIRED=0.9.4
 LIBPANEL_REQUIRED=2.0.0
-GSTREAMER_REQUIRED=0.10
+GSTREAMER_REQUIRED=1.0
+GSTREAMER_CFLAGS=
+GSTREAMER_LIBS=
 XRANDR_REQUIRED=1.2.0
 POLKIT_GNOME_REQUIRED=0.8
 
@@ -75,7 +76,6 @@
 AC_SUBST(GTK_REQUIRED)
 AC_SUBST(GDK_REQUIRED)
 AC_SUBST(LIBGNOME_REQUIRED)
-AC_SUBST(LIBGNOMEUI_REQUIRED)
 AC_SUBST(HAL_REQUIRED)
 AC_SUBST(DBUS_REQUIRED)
 AC_SUBST(LIBGLADE_REQUIRED)
@@ -99,7 +99,6 @@
 AC_SUBST(HAL_CFLAGS)
 AC_SUBST(HAL_LIBS)
 
-PKG_CHECK_MODULES(GSTREAMER, gstreamer-0.10 >= $GSTREAMER_REQUIRED)
 AC_SUBST(GSTREAMER_CFLAGS)
 AC_SUBST(GSTREAMER_LIBS)
 
@@ -111,19 +110,14 @@
 AC_SUBST(DBUS_LIBS)
 
 PKG_CHECK_MODULES(GNOME, [
- libgnomeui-2.0 >= $LIBGNOMEUI_REQUIRED
- libglade-2.0 >= $LIBGLADE_REQUIRED
- libwnck-1.0 >= $LIBWNCK_REQUIRED
- gtk+-2.0 >= $GTK_REQUIRED
- gnome-keyring-1 >= $GNOME_KEYRING_REQUIRED
- libpanelapplet-2.0 >= $LIBPANEL_REQUIRED
+ libwnck-3.0 >= $LIBWNCK_REQUIRED
+ gtk+-3.0 >= $GTK_REQUIRED
  cairo >= $CAIRO_REQUIRED])
 AC_SUBST(GNOME_CFLAGS)
 AC_SUBST(GNOME_LIBS)
 
 PKG_CHECK_MODULES(GDK, [
- gdk-2.0 >= $GDK_REQUIRED
- gdk-x11-2.0 >= $GDK_REQUIRED])
+ gdk-3.0 >= $GDK_REQUIRED])
 AC_SUBST(GDK_CFLAGS)
 AC_SUBST(GDK_LIBS)
 
@@ -139,6 +133,9 @@
 AC_PATH_XTRA
 
 ALL_X_LIBS="$X_LIBS $X_PRE_LIBS -lX11 $X_EXTRA_LIBS"
+CAIRO_LIBS=-L/usr/lib/amd64 -lgtk-3 -lgdk-3 -lpangocairo-1.0 -lpango-1.0 -latk-1.0 -lcairo-gobject -lgdk_pixbuf-2.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0 -lcairo
+GDK_LIBS=-L/usr/lib/amd64 -lgdk-3 -lpangocairo-1.0 -lpango-1.0 -lgdk_pixbuf-2.0 -lcairo-gobject -lcairo -lgobject-2.0 -lglib-2.0
+X_LIBS=-lX11
 
 dnl ---------------------------------------------------------------------------
 dnl - Make paths available for source files
diff -urN ../g1/gnome-power-manager-2.24.4/libhal-glib/Makefile.am gnome-power-manager-2.24.4/libhal-glib/Makefile.am
--- ../g1/gnome-power-manager-2.24.4/libhal-glib/Makefile.am	2008-09-04 03:05:17.000000000 +0000
+++ gnome-power-manager-2.24.4/libhal-glib/Makefile.am	2020-04-05 16:11:01.000000000 +0000
@@ -11,11 +11,27 @@
 	$(top_builddir)/libdbus-glib/libdbus-proxy.la
 
 noinst_LTLIBRARIES =						\
+	libhal-gcpufreq.la					\
 	libhal-gmanager.la					\
 	libhal-gdevice.la					\
 	libhal-gdevicestore.la					\
 	libhal-gpower.la
 
+libhal_gcpufreq_la_SOURCES =					\
+	libhal-marshal.h					\
+	libhal-marshal.c					\
+	libhal-gdevice.c					\
+	libhal-gdevice.h					\
+	libhal-gcpufreq.c					\
+	libhal-gcpufreq.h					\
+	libhal-gmanager.c					\
+	libhal-gmanager.h
+libhal_gcpufreq_la_LIBADD =					\
+	$(LOCAL_LIBDBUS_LIBS)					\
+	$(DBUS_LIBS)						\
+	$(INTLLIBS)						\
+	$(GLIB_LIBS)
+
 libhal_gmanager_la_SOURCES =					\
 	libhal-marshal.h					\
 	libhal-marshal.c					\
diff -urN ../g1/gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.c gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.c
--- ../g1/gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.c	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.c	2020-04-05 16:11:21.000000000 +0000
@@ -0,0 +1,608 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2007 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <string.h>
+#include <glib.h>
+#include <dbus/dbus-glib.h>
+#include <glib/gi18n.h>
+#include <libdbus-proxy.h>
+
+#include "libhal-marshal.h"
+#include "libhal-gpower.h"
+#include "libhal-gdevice.h"
+#include "libhal-gcpufreq.h"
+#include "libhal-gmanager.h"
+
+static void     hal_gcpufreq_class_init (HalGCpufreqClass *klass);
+static void     hal_gcpufreq_init       (HalGCpufreq      *hal);
+static void     hal_gcpufreq_finalize   (GObject	  *object);
+
+#define LIBHAL_CPUFREQ_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), LIBHAL_TYPE_CPUFREQ, HalGCpufreqPrivate))
+
+struct HalGCpufreqPrivate
+{
+	DbusProxy		*gproxy;
+	guint			 available_governors;
+	HalGCpufreqType		 current_governor;
+};
+
+G_DEFINE_TYPE (HalGCpufreq, hal_gcpufreq, G_TYPE_OBJECT)
+
+static gpointer hal_gcpufreq_object = NULL;
+
+/**
+ * hal_gcpufreq_string_to_enum:
+ * @governor: The cpufreq kernel governor, e.g. "powersave"
+ * Return value: The HalGCpufreqType value, e.g. LIBHAL_CPUFREQ_POWERSAVE
+ **/
+HalGCpufreqType
+hal_gcpufreq_string_to_enum (const gchar *governor)
+{
+	HalGCpufreqType cpufreq_type = LIBHAL_CPUFREQ_UNKNOWN;
+	if (governor == NULL) {
+		cpufreq_type = LIBHAL_CPUFREQ_NOTHING;
+	} else if (strcmp (governor, CODE_CPUFREQ_ONDEMAND) == 0) {
+		cpufreq_type = LIBHAL_CPUFREQ_ONDEMAND;
+	} else if (strcmp (governor, CODE_CPUFREQ_CONSERVATIVE) == 0) {
+		cpufreq_type = LIBHAL_CPUFREQ_CONSERVATIVE;
+	} else if (strcmp (governor, CODE_CPUFREQ_POWERSAVE) == 0) {
+		cpufreq_type = LIBHAL_CPUFREQ_POWERSAVE;
+	} else if (strcmp (governor, CODE_CPUFREQ_USERSPACE) == 0) {
+		cpufreq_type = LIBHAL_CPUFREQ_USERSPACE;
+	} else if (strcmp (governor, CODE_CPUFREQ_PERFORMANCE) == 0) {
+		cpufreq_type = LIBHAL_CPUFREQ_PERFORMANCE;
+	} else if (strcmp (governor, CODE_CPUFREQ_NOTHING) == 0) {
+		cpufreq_type = LIBHAL_CPUFREQ_NOTHING;
+	}
+	return cpufreq_type;
+}
+
+/**
+ * hal_gcpufreq_string_to_enum:
+ * @cpufreq_type: The HalGCpufreqType value, e.g. LIBHAL_CPUFREQ_POWERSAVE
+ * Return value: The cpufreq kernel governor, e.g. "powersave"
+ **/
+const gchar *
+hal_gcpufreq_enum_to_string (HalGCpufreqType cpufreq_type)
+{
+	const char *governor;
+	if (cpufreq_type == LIBHAL_CPUFREQ_ONDEMAND) {
+		governor = CODE_CPUFREQ_ONDEMAND;
+	} else if (cpufreq_type == LIBHAL_CPUFREQ_CONSERVATIVE) {
+		governor = CODE_CPUFREQ_CONSERVATIVE;
+	} else if (cpufreq_type == LIBHAL_CPUFREQ_POWERSAVE) {
+		governor = CODE_CPUFREQ_POWERSAVE;
+	} else if (cpufreq_type == LIBHAL_CPUFREQ_USERSPACE) {
+		governor = CODE_CPUFREQ_USERSPACE;
+	} else if (cpufreq_type == LIBHAL_CPUFREQ_PERFORMANCE) {
+		governor = CODE_CPUFREQ_PERFORMANCE;
+	} else if (cpufreq_type == LIBHAL_CPUFREQ_NOTHING) {
+		governor = CODE_CPUFREQ_NOTHING;
+	} else {
+		governor = "unknown";
+	}
+	return governor;
+}
+
+/**
+ * hal_gcpufreq_set_performance:
+ *
+ * @cpufreq: This class instance
+ * @performance: The percentage perfomance figure
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_set_performance (HalGCpufreq *cpufreq, guint performance)
+{
+	GError *error = NULL;
+	gboolean ret;
+	HalGCpufreqType cpufreq_type;
+	DBusGProxy *proxy;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+	g_return_val_if_fail (performance >= 0, FALSE);
+	g_return_val_if_fail (performance <= 100, FALSE);
+
+	/* we need to find the current governor to see if it's sane */
+	if (cpufreq->priv->current_governor == LIBHAL_CPUFREQ_UNKNOWN) {
+		hal_gcpufreq_get_governor (cpufreq, &cpufreq_type);
+	}
+
+	/* only applies to some governors */
+	if (cpufreq->priv->current_governor == LIBHAL_CPUFREQ_PERFORMANCE ||
+	    cpufreq->priv->current_governor == LIBHAL_CPUFREQ_POWERSAVE) {
+		return FALSE;
+	}
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "SetCPUFreqPerformance", &error,
+				 G_TYPE_INT, performance,
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		return FALSE;
+	}
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_set_governor:
+ *
+ * @cpufreq: This class instance
+ * @cpufreq_type: The CPU governor type, e.g. LIBHAL_CPUFREQ_CONSERVATIVE
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_set_governor (HalGCpufreq    *cpufreq,
+			   HalGCpufreqType cpufreq_type)
+{
+	GError *error = NULL;
+	gboolean ret;
+	const gchar *governor;
+	DBusGProxy *proxy;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+	g_return_val_if_fail (cpufreq_type != LIBHAL_CPUFREQ_UNKNOWN, FALSE);
+
+	governor = hal_gcpufreq_enum_to_string (cpufreq_type);
+	g_return_val_if_fail (governor != NULL, FALSE);
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "SetCPUFreqGovernor", &error,
+				 G_TYPE_STRING, governor,
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		return FALSE;
+	}
+
+	/* save the cache */
+	cpufreq->priv->current_governor = cpufreq_type;
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_get_governors:
+ *
+ * @cpufreq: This class instance
+ * @cpufreq_type: Return variable, The CPU governor type as an combined bitwise type
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_get_governors (HalGCpufreq     *cpufreq,
+			    HalGCpufreqType *cpufreq_type)
+{
+	GError *error = NULL;
+	gboolean ret;
+	char **strlist;
+	int i = 0;
+	DBusGProxy *proxy;
+	HalGCpufreqType types = LIBHAL_CPUFREQ_UNKNOWN;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+	g_return_val_if_fail (cpufreq_type != NULL, FALSE);
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		*cpufreq_type = LIBHAL_CPUFREQ_UNKNOWN;
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "GetCPUFreqAvailableGovernors", &error,
+				 G_TYPE_INVALID,
+				 G_TYPE_STRV, &strlist,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		*cpufreq_type = LIBHAL_CPUFREQ_UNKNOWN;
+		return FALSE;
+	}
+
+	/* treat as binary flags */
+	while (strlist && strlist[i]) {
+		types += hal_gcpufreq_string_to_enum (strlist[i]);
+		++i;
+	}
+
+	/* when we have conservative and ondemand available, only expose
+	   ondemand in the UI. They are too similar and ondemand is better. */
+	if (types & LIBHAL_CPUFREQ_ONDEMAND && types & LIBHAL_CPUFREQ_CONSERVATIVE) {
+		types -= LIBHAL_CPUFREQ_CONSERVATIVE;
+	}
+
+	/* We never allow the user to use userspace. */
+	if (types & LIBHAL_CPUFREQ_USERSPACE) {
+		types -= LIBHAL_CPUFREQ_USERSPACE;
+	}
+
+	*cpufreq_type = types;
+	cpufreq->priv->available_governors = i;
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_get_number_governors:
+ *
+ * @cpufreq: This class instance
+ * @use_cache: if we should force a cache update
+ * Return value: the number of available governors
+ **/
+guint
+hal_gcpufreq_get_number_governors (HalGCpufreq *cpufreq,
+				   gboolean    use_cache)
+{
+	HalGCpufreqType cpufreq_type;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+
+	if (use_cache == FALSE || cpufreq->priv->available_governors == -1) {
+		hal_gcpufreq_get_governors (cpufreq, &cpufreq_type);
+	}
+	return cpufreq->priv->available_governors;
+}
+
+/**
+ * hal_gcpufreq_get_consider_nice:
+ *
+ * @cpufreq: This class instance
+ * @consider_nice: Return variable, if consider niced processes
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_get_consider_nice (HalGCpufreq *cpufreq,
+			        gboolean      *consider_nice)
+{
+	GError *error = NULL;
+	gboolean ret;
+	HalGCpufreqType cpufreq_type;
+	DBusGProxy *proxy;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+	g_return_val_if_fail (consider_nice != NULL, FALSE);
+
+	/* we need to find the current governor to see if it's sane */
+	if (cpufreq->priv->current_governor == LIBHAL_CPUFREQ_UNKNOWN) {
+		hal_gcpufreq_get_governor (cpufreq, &cpufreq_type);
+	}
+
+	/* only applies to some governors */
+	if (cpufreq->priv->current_governor != LIBHAL_CPUFREQ_ONDEMAND &&
+	    cpufreq->priv->current_governor != LIBHAL_CPUFREQ_CONSERVATIVE) {
+		*consider_nice = FALSE;
+		return FALSE;
+	}
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "GetCPUFreqConsiderNice", &error,
+				 G_TYPE_INVALID,
+				 G_TYPE_BOOLEAN, consider_nice,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		return FALSE;
+	}
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_get_performance:
+ *
+ * @cpufreq: This class instance
+ * @performance: Return variable, the percentage performance
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_get_performance (HalGCpufreq *cpufreq,
+		              guint         *performance)
+{
+	GError *error = NULL;
+	gboolean ret;
+	HalGCpufreqType cpufreq_type;
+	DBusGProxy *proxy;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+	g_return_val_if_fail (performance != NULL, FALSE);
+
+	/* we need to find the current governor to see if it's sane */
+	if (cpufreq->priv->current_governor == LIBHAL_CPUFREQ_UNKNOWN) {
+		hal_gcpufreq_get_governor (cpufreq, &cpufreq_type);
+	}
+
+	/* only applies to some governors */
+	if (cpufreq->priv->current_governor != LIBHAL_CPUFREQ_USERSPACE) {
+		*performance = -1;
+		return FALSE;
+	}
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "GetCPUFreqPerformance", &error,
+				 G_TYPE_INVALID,
+				 G_TYPE_INT, performance,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		return FALSE;
+	}
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_get_governor:
+ *
+ * @cpufreq: This class instance
+ * @cpufreq_type: Return variable, the governor type, e.g. LIBHAL_CPUFREQ_POWERSAVE
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_get_governor (HalGCpufreq     *cpufreq,
+			   HalGCpufreqType *cpufreq_type)
+{
+	GError *error = NULL;
+	gboolean ret;
+	gchar *governor;
+	DBusGProxy *proxy;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+	g_return_val_if_fail (cpufreq_type, FALSE);
+
+	*cpufreq_type = LIBHAL_CPUFREQ_UNKNOWN;
+
+	/* use the cache */
+	if (cpufreq->priv->current_governor != LIBHAL_CPUFREQ_UNKNOWN) {
+		return cpufreq->priv->current_governor;
+	}
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "GetCPUFreqGovernor", &error,
+				 G_TYPE_INVALID,
+				 G_TYPE_STRING, &governor,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		return FALSE;
+	}
+
+	/* convert to enumerated type */
+	if (governor != NULL) {
+		*cpufreq_type = hal_gcpufreq_string_to_enum (governor);
+		cpufreq->priv->current_governor = *cpufreq_type;
+		g_free (governor);
+	}
+
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_set_consider_nice:
+ *
+ * @cpufreq: This class instance
+ * @enable: True to consider nice processes
+ * Return value: If the method succeeded
+ **/
+gboolean
+hal_gcpufreq_set_consider_nice (HalGCpufreq *cpufreq,
+			        gboolean    consider_nice)
+{
+	GError *error = NULL;
+	gboolean ret;
+	HalGCpufreqType cpufreq_type;
+	DBusGProxy *proxy;
+
+	g_return_val_if_fail (cpufreq != NULL, FALSE);
+	g_return_val_if_fail (LIBHAL_IS_CPUFREQ (cpufreq), FALSE);
+
+	/* we need to find the current governor to see if it's sane */
+	if (cpufreq->priv->current_governor == LIBHAL_CPUFREQ_UNKNOWN) {
+		hal_gcpufreq_get_governor (cpufreq, &cpufreq_type);
+	}
+
+	/* only applies to some governors */
+	if (cpufreq->priv->current_governor != LIBHAL_CPUFREQ_ONDEMAND &&
+	    cpufreq->priv->current_governor != LIBHAL_CPUFREQ_CONSERVATIVE) {
+		return FALSE;
+	}
+
+	proxy = dbus_proxy_get_proxy (cpufreq->priv->gproxy);
+	if (proxy == NULL) {
+		g_warning ("not connected");
+		return FALSE;
+	}
+
+	ret = dbus_g_proxy_call (proxy, "SetCPUFreqConsiderNice", &error,
+				 G_TYPE_BOOLEAN, consider_nice,
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+	if (error) {
+		g_warning ("ERROR: %s", error->message);
+		g_error_free (error);
+	}
+	if (ret == FALSE) {
+		/* abort as the DBUS method failed */
+		return FALSE;
+	}
+	return TRUE;
+}
+
+/**
+ * hal_gcpufreq_class_init:
+ * @klass: This class instance
+ **/
+static void
+hal_gcpufreq_class_init (HalGCpufreqClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	object_class->finalize = hal_gcpufreq_finalize;
+	g_type_class_add_private (klass, sizeof (HalGCpufreqPrivate));
+}
+
+/**
+ * hal_gcpufreq_init:
+ *
+ * @cpufreq: This class instance
+ **/
+static void
+hal_gcpufreq_init (HalGCpufreq *cpufreq)
+{
+	cpufreq->priv = LIBHAL_CPUFREQ_GET_PRIVATE (cpufreq);
+
+	cpufreq->priv->gproxy = dbus_proxy_new ();
+	dbus_proxy_assign (cpufreq->priv->gproxy,
+			  DBUS_PROXY_SYSTEM,
+			  HAL_DBUS_SERVICE,
+			  HAL_ROOT_COMPUTER,
+			  HAL_DBUS_INTERFACE_CPUFREQ);
+
+	/* set defaults */
+	cpufreq->priv->available_governors = -1;
+	cpufreq->priv->current_governor = LIBHAL_CPUFREQ_UNKNOWN;
+}
+
+/**
+ * hal_gcpufreq_finalize:
+ * @object: This class instance
+ **/
+static void
+hal_gcpufreq_finalize (GObject *object)
+{
+	HalGCpufreq *cpufreq;
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (LIBHAL_IS_CPUFREQ (object));
+
+	cpufreq = LIBHAL_CPUFREQ (object);
+	cpufreq->priv = LIBHAL_CPUFREQ_GET_PRIVATE (cpufreq);
+
+	if (cpufreq->priv->gproxy != NULL) {
+		g_object_unref (cpufreq->priv->gproxy);
+	}
+
+	G_OBJECT_CLASS (hal_gcpufreq_parent_class)->finalize (object);
+}
+
+/**
+ * hal_gcpufreq_has_hw:
+ *
+ * Self contained function that works out if we have the hardware.
+ * If not, we return FALSE and the module is unloaded.
+ **/
+gboolean
+hal_gcpufreq_has_hw (void)
+{
+	HalGManager *hal_manager;
+	gchar **names;
+	gboolean ret = TRUE;
+
+	/* okay, as singleton */
+	hal_manager = hal_gmanager_new ();
+	ret = hal_gmanager_find_capability (hal_manager, "cpufreq_control", &names, NULL);
+
+	/* nothing found */
+	if (names == NULL || names[0] == NULL) {
+		ret = FALSE;
+	}
+	hal_gmanager_free_capability (names);
+	g_object_unref (hal_manager);
+
+	return ret;
+}
+
+/**
+ * hal_gcpufreq_new:
+ * Return value: new HalGCpufreq instance.
+ **/
+HalGCpufreq *
+hal_gcpufreq_new (void)
+{
+	if (hal_gcpufreq_object != NULL) {
+		g_object_ref (hal_gcpufreq_object);
+	} else {
+		/* only load an instance of this module if we have the hardware */
+		if (hal_gcpufreq_has_hw () == FALSE) {
+			return NULL;
+		}
+		hal_gcpufreq_object = g_object_new (LIBHAL_TYPE_CPUFREQ, NULL);
+		g_object_add_weak_pointer (hal_gcpufreq_object, &hal_gcpufreq_object);
+	}
+	return LIBHAL_CPUFREQ (hal_gcpufreq_object);
+}
+
diff -urN ../g1/gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.h gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.h
--- ../g1/gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.h	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/libhal-glib/libhal-gcpufreq.h	2020-04-05 16:11:15.000000000 +0000
@@ -0,0 +1,93 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2007 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __LIBHAL_GCPUFREQ_H
+#define __LIBHAL_GCPUFREQ_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define LIBHAL_TYPE_CPUFREQ		(hal_gcpufreq_get_type ())
+#define LIBHAL_CPUFREQ(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), LIBHAL_TYPE_CPUFREQ, HalGCpufreq))
+#define LIBHAL_CPUFREQ_CLASS(k)		(G_TYPE_CHECK_CLASS_CAST((k), LIBHAL_TYPE_CPUFREQ, HalGCpufreqClass))
+#define LIBHAL_IS_CPUFREQ(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), LIBHAL_TYPE_CPUFREQ))
+#define LIBHAL_IS_CPUFREQ_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), LIBHAL_TYPE_CPUFREQ))
+#define LIBHAL_CPUFREQ_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), LIBHAL_TYPE_CPUFREQ, HalGCpufreqClass))
+
+typedef struct HalGCpufreqPrivate HalGCpufreqPrivate;
+
+typedef struct
+{
+	GObject			 parent;
+	HalGCpufreqPrivate	*priv;
+} HalGCpufreq;
+
+
+typedef struct
+{
+	GObjectClass	parent_class;
+} HalGCpufreqClass;
+
+/* types of governor */
+typedef enum {
+	LIBHAL_CPUFREQ_UNKNOWN = 0,
+	LIBHAL_CPUFREQ_ONDEMAND = 1,
+	LIBHAL_CPUFREQ_CONSERVATIVE = 2,
+	LIBHAL_CPUFREQ_POWERSAVE = 4,
+	LIBHAL_CPUFREQ_USERSPACE = 8,
+	LIBHAL_CPUFREQ_PERFORMANCE = 16,
+	LIBHAL_CPUFREQ_NOTHING = 32,
+} HalGCpufreqType;
+
+#define CODE_CPUFREQ_ONDEMAND		"ondemand"
+#define CODE_CPUFREQ_CONSERVATIVE	"conservative"
+#define CODE_CPUFREQ_POWERSAVE		"powersave"
+#define CODE_CPUFREQ_USERSPACE		"userspace"
+#define CODE_CPUFREQ_PERFORMANCE	"performance"
+#define CODE_CPUFREQ_NOTHING		"nothing"
+
+GType		 hal_gcpufreq_get_type			(void);
+HalGCpufreq	*hal_gcpufreq_new			(void);
+gboolean	 hal_gcpufreq_has_hw			(void);
+
+const gchar	*hal_gcpufreq_enum_to_string		(HalGCpufreqType  cpufreq_type);
+HalGCpufreqType	 hal_gcpufreq_string_to_enum		(const gchar	*governor);
+gboolean	 hal_gcpufreq_get_governors		(HalGCpufreq	*cpufreq,
+							 HalGCpufreqType *cpufreq_type);
+gboolean	 hal_gcpufreq_get_governor		(HalGCpufreq	*cpufreq,
+							 HalGCpufreqType *cpufreq_type);
+gboolean	 hal_gcpufreq_set_governor		(HalGCpufreq	*cpufreq,
+							 HalGCpufreqType  governor_enum);
+gboolean	 hal_gcpufreq_get_consider_nice		(HalGCpufreq	*cpufreq,
+							 gboolean	*consider_nice);
+gboolean	 hal_gcpufreq_set_consider_nice		(HalGCpufreq	*cpufreq,
+							 gboolean	 consider_nice);
+gboolean	 hal_gcpufreq_get_performance		(HalGCpufreq	*cpufreq,
+							 guint		*performance);
+gboolean	 hal_gcpufreq_set_performance		(HalGCpufreq	*cpufreq,
+							 guint		 performance);
+guint		 hal_gcpufreq_get_number_governors	(HalGCpufreq	*cpufreq,
+							 gboolean	 use_cache);
+
+G_END_DECLS
+
+#endif	/* __LIBHAL_GCPUFREQ_H */
diff -urN ../g1/gnome-power-manager-2.24.4/libidletime/libidletime.c gnome-power-manager-2.24.4/libidletime/libidletime.c
--- ../g1/gnome-power-manager-2.24.4/libidletime/libidletime.c	2008-09-04 03:05:14.000000000 +0000
+++ gnome-power-manager-2.24.4/libidletime/libidletime.c	2020-04-05 16:08:53.000000000 +0000
@@ -368,7 +368,7 @@
 	idletime->priv->idle_counter = None;
 	idletime->priv->last_event = 0;
 	idletime->priv->sync_event = 0;
-	idletime->priv->dpy = GDK_DISPLAY ();
+	idletime->priv->dpy = GDK_DISPLAY_XDISPLAY (gdk_display_get_default());
 
 	/* get the sync event */
 	if (!XSyncQueryExtension (idletime->priv->dpy, &idletime->priv->sync_event, &sync_error)) {
diff -urN ../g1/gnome-power-manager-2.24.4/src/Makefile.am gnome-power-manager-2.24.4/src/Makefile.am
--- ../g1/gnome-power-manager-2.24.4/src/Makefile.am	2008-11-17 02:06:02.000000000 +0000
+++ gnome-power-manager-2.24.4/src/Makefile.am	2020-04-05 17:23:10.000000000 +0000
@@ -9,36 +9,111 @@
 	gpm-marshal.list				\
 	$(NULL)
 
-INCLUDES =						\
-	$(GLIB_CFLAGS)					\
-	$(HAL_CFLAGS)					\
-	$(DBUS_CFLAGS)					\
-	$(GNOME_CFLAGS)					\
-	$(XRANDR_CFLAGS)				\
-	$(LIBNOTIFY_CFLAGS)				\
-	$(UNIQUE_CFLAGS)				\
-	$(GSTREAMER_CFLAGS)				\
-	$(POLKIT_CFLAGS)				\
-	$(POLKIT_GNOME_CFLAGS)				\
-	-DBINDIR=\"$(bindir)\"			 	\
-	-DGNOMELOCALEDIR=\""$(datadir)/locale"\"	\
-	-DDATADIR=\"$(datadir)\"			\
-	-DPREFIX=\""$(prefix)"\" 			\
-	-DSYSCONFDIR=\""$(sysconfdir)"\" 		\
-	-DLIBDIR=\""$(libdir)"\" 			\
-	-DVERSION="\"$(VERSION)\"" 			\
-	-DGPM_DATA=\"$(pkgdatadir)\"			\
-	-DEGG_LOG_FILE=\""$(PK_LOG_DIR)/gnome-power-manager"\"	\
-	-I$(top_srcdir)					\
-	-I$(top_srcdir)/libunique			\
-	-I$(top_srcdir)/libhal-glib			\
-	-I$(top_srcdir)/libdbus-glib			\
-	$(NULL)
+LIBNOTIFY_CFLAGS = -D_REENTRANT -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+HAL_CFLAGS = -DDBUS_API_SUBJECT_TO_CHANGE -I/usr/include/hal -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include
+GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+GDK_CFLAGS = -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -I/usr/include/gtk-3.0 -I/usr/include/gio-unix-2.0/ -I/usr/include/cairo -I/usr/include/pango-1.0 -I/usr/include/harfbuzz -I/usr/include/pango-1.0 -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/cairo -I/usr/include/pixman-1 -I/usr/include/freetype2 -I/usr/include/libdrm -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+DBUS_CFLAGS = -D_REENTRANT -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+
+GLIB_LIBS = -L/usr/lib/amd64 -lgobject-2.0 -lglib-2.0
+GPM_EXTRA_LIBS = -lresolv -lXext -lkstat -lgconf-2 -lm
+HAL_LIBS = -L/usr/lib/amd64 -lhal -ldbus-1
+LIBNOTIFY_LIBS = -L/usr/lib/amd64 -lnotify
+XRANDR_LIBS = -lXrandr -lXrender -lX11
+X_PRE_LIBS =  -lSM -lICE
+CAIRO_LIBS = -L/usr/lib/amd64 -lcairo -lpangocairo-1.0 -lpango-1.0 -latk-1.0 -lcairo-gobject -lgdk_pixbuf-2.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0
+DBUS_LIBS =  -L/usr/lib/amd64 -ldbus-glib-1 -lgobject-2.0 -ldbus-1 -lgthread-2.0
+GDK_LIBS = -L/usr/lib/amd64 -lgdk-3 -lgdk_pixbuf-2.0  -lgobject-2.0 -lglib-2.0
+GSTREAMER_LIBS = -lgstreamer-1.0
+
+INCLUDES =                                              \
+        $(GLIB_CFLAGS)                                  \
+        $(HAL_CFLAGS)                                   \
+        $(DBUS_CFLAGS)                                  \
+        $(GNOME_CFLAGS)                                 \
+        $(XRANDR_CFLAGS)                                \
+        $(LIBNOTIFY_CFLAGS)                             \
+        $(UNIQUE_CFLAGS)                                \
+        $(POLKIT_CFLAGS)                                \
+        $(POLKIT_GNOME_CFLAGS)                          \
+        -DBINDIR=\"$(bindir)\"                          \
+        -DGNOMELOCALEDIR=\""$(datadir)/locale"\"        \
+        -DDATADIR=\"$(datadir)\"                        \
+        -DPREFIX=\""$(prefix)"\"                        \
+        -DSYSCONFDIR=\""$(sysconfdir)"\"                \
+        -DLIBDIR=\""$(libdir)"\"                        \
+        -DVERSION="\"$(VERSION)\""                      \
+        -DGPM_DATA=\"$(pkgdatadir)\"                    \
+        -DEGG_LOG_FILE=\""$(PK_LOG_DIR)/gnome-power-manager"\"  \
+        -I$(top_srcdir)                                 \
+        -I$(top_srcdir)/libunique                       \
+        -I$(top_srcdir)/libhal-glib                     \
+        -I$(top_srcdir)/libdbus-glib                    \
+        -I/usr/include/dbus-1.0                                 \
+        -I/usr/lib/amd64/dbus-1.0/include                       \
+        -I/usr/include/glib-2.0                                 \
+        -I/usr/lib/amd64/glib-2.0/include                       \
+        -I/usr/include/pcre                                     \
+        -I/usr/include/gtk-3.0                                  \
+        -I/usr/include/gio-unix-2.0                             \
+        -I/usr/include/cairo                                    \
+        -I/usr/include/pango-1.0                                \
+        -I/usr/include/gdk-pixbuf-2.0                           \
+        -I/usr/include/libpng14                                 \
+        -I/usr/include/pixman-1                                 \
+        -I/usr/include/atk-1.0                                  \
+        -I/usr/include/gconf/2                                  \
+        -I/usr/include/gstreamer-1.0                            \
+        $(NULL)
+
+gnome_power_preferences_LDADD = $(GLIB_LIBS) $(GNOME_LIBS) $(HAL_LIBS) \
+        $(DBUS_LIBS) $(POLKIT_LIBS) $(GPM_EXTRA_LIBS) \
+        $(LOCAL_LIBHAL_LIBS) $(LOCAL_LIBDBUS_LIBS) $(XRANDR_LIBS) \
+        $(LOCAL_LIBUNIQUE_LIBS) $(CAIRO_LIBS) $(NULL) $(am__append_2)
+
+gnome_power_manager_LDADD =                             \
+        $(GLIB_LIBS)                                    \
+        $(GSTREAMER_LIBS)                               \
+        $(GNOME_LIBS)                                   \
+        $(HAL_LIBS)                                     \
+        $(POLKIT_LIBS)                                  \
+        $(DBUS_LIBS)                                    \
+        $(XRANDR_LIBS)                                  \
+        $(GPM_EXTRA_LIBS)                               \
+        $(LOCAL_LIBHAL_LIBS)                            \
+        $(LOCAL_LIBDBUS_LIBS)                           \
+        $(GDK_LIBS)                                     \
+        $(X_LIBS)                                       \
+        $(CAIRO_LIBS)                                   \
+	$(LIBNOTIFY_LIBS)					\
+	$(GSTREAMER_LIBS)				\
+        $(am__append_3)                                 \
+        $(NULL)
+
+gnome_power_statistics_LDADD = $(GLIB_LIBS) $(GNOME_LIBS) $(DBUS_LIBS) \
+        $(LOCAL_LIBDBUS_LIBS) $(LOCAL_LIBUNIQUE_LIBS) $(NULL) \
+        $(CAIRO_LIBS) $(XRANDR_LIBS) $(GPM_EXTRA_LIBS) \
+        $(am__append_1)
+
+gnome_power_self_test_LDADD = \
+        $(GLIB_LIBS)                                    \
+        $(GNOME_LIBS)                                   \
+        $(GSTREAMER_LIBS)                               \
+        $(POLKIT_GNOME_LIBS)                            \
+        $(DBUS_LIBS)                                    \
+        $(LIBNOTIFY_LIBS)                               \
+        $(LOCAL_LIBDBUS_LIBS)                           \
+        $(LOCAL_LIBHAL_LIBS)                            \
+        $(GPM_EXTRA_LIBS)                               \
+        $(XRANDR_LIBS)                                  \
+        $(CAIRO_LIBS)                                   \
+        $(NULL)
 
 LOCAL_LIBHAL_LIBS =					\
 	$(top_builddir)/libhal-glib/libhal-gdevice.la	\
 	$(top_builddir)/libhal-glib/libhal-gdevicestore.la	\
 	$(top_builddir)/libhal-glib/libhal-gmanager.la	\
+	$(top_builddir)/libhal-glib/libhal-gcpufreq.la	\
 	$(top_builddir)/libhal-glib/libhal-gpower.la
 
 LOCAL_LIBDBUS_LIBS =						\
@@ -64,6 +139,8 @@
 	egg-color.h					\
 	egg-debug.h					\
 	egg-debug.c					\
+        egg-precision.h                                 \
+        egg-precision.c                                 \
 	gpm-statistics.c				\
 	gpm-statistics-core.h				\
 	gpm-statistics-core.c				\
@@ -79,21 +156,10 @@
 	gpm-conf.c					\
 	gpm-common.h					\
 	gpm-common.c					\
+        gpm-point-obj.c					\
+        gpm-point-obj.h					\
 	$(NULL)
 
-gnome_power_statistics_LDADD =				\
-	$(GLIB_LIBS)					\
-	$(GNOME_LIBS)					\
-	$(DBUS_LIBS)					\
-	$(LOCAL_LIBDBUS_LIBS)				\
-	$(LOCAL_LIBUNIQUE_LIBS)				\
-	$(NULL)
-
-if HAVE_UNIQUE
-gnome_power_statistics_LDADD +=				\
-	$(UNIQUE_LIBS)
-endif
-
 gnome_power_preferences_SOURCES =			\
 	egg-debug.h					\
 	egg-debug.c					\
@@ -111,29 +177,18 @@
 	gpm-prefs-core.c				\
 	gpm-marshal.h					\
 	gpm-marshal.c					\
+	gpm-control.h					\
+	gpm-control.c					\
+	gpm-networkmanager.h				\
+	gpm-networkmanager.c				\
+	gpm-button.c					\
+	gpm-button.h					\
 	gpm-common.h					\
 	gpm-common.c					\
 	gpm-screensaver.h				\
 	gpm-screensaver.c				\
 	$(NULL)
 
-gnome_power_preferences_LDADD =				\
-	$(GLIB_LIBS)					\
-	$(GNOME_LIBS)					\
-	$(HAL_LIBS)					\
-	$(DBUS_LIBS)					\
-	$(POLKIT_GNOME_LIBS)				\
-	$(GPM_EXTRA_LIBS)				\
-	$(LOCAL_LIBHAL_LIBS)				\
-	$(LOCAL_LIBDBUS_LIBS)				\
-	$(LOCAL_LIBUNIQUE_LIBS)				\
-	$(NULL)
-
-if HAVE_UNIQUE
-gnome_power_preferences_LDADD +=			\
-	$(UNIQUE_LIBS)
-endif
-
 gnome_power_manager_SOURCES =				\
 	egg-color.c					\
 	egg-color.h					\
@@ -165,6 +220,8 @@
 	gpm-srv-brightness-kbd.c			\
 	gpm-srv-screensaver.h				\
 	gpm-srv-screensaver.c				\
+	gpm-cpufreq.c					\
+	gpm-cpufreq.h					\
 	gpm-conf.h					\
 	gpm-conf.c					\
 	gpm-idle.h					\
@@ -217,29 +274,18 @@
 	gpm-inhibit.c					\
 	gpm-graph-widget.h				\
 	gpm-graph-widget.c				\
-	gpm-feedback-widget.h				\
-	gpm-feedback-widget.c				\
-	$(NULL)
-
-gnome_power_manager_LDADD =				\
-	$(GLIB_LIBS)					\
-	$(GSTREAMER_LIBS)				\
-	$(GNOME_LIBS)					\
-	$(HAL_LIBS)					\
-	$(POLKIT_LIBS)					\
-	$(DBUS_LIBS)					\
-	$(XRANDR_LIBS)					\
-	$(GPM_EXTRA_LIBS)				\
-	$(LOCAL_LIBHAL_LIBS)				\
-	$(LOCAL_LIBDBUS_LIBS)				\
+	egg-array-float.h                               \
+        egg-array-float.c                               \
+        egg-precision.h                                 \
+        egg-precision.c                                 \
+        gpm-session.h                                   \
+        gpm-session.c                                   \
+        gpm-feedback-widget.c                           \
+        gpm-feedback-widget.h                           \
+        gpm-point-obj.c					\
+        gpm-point-obj.h					\
 	$(NULL)
 
-if HAVE_LIBNOTIFY
-gnome_power_manager_LDADD +=				\
-	$(LIBNOTIFY_LIBS)				\
-	$(NULL)
-endif
-
 gnome_power_self_test_SOURCES =				\
 	egg-color.c					\
 	egg-color.h					\
@@ -301,18 +347,6 @@
 	gpm-graph-widget.c				\
 	$(NULL)
 
-gnome_power_self_test_LDADD =				\
-	$(GLIB_LIBS)					\
-	$(GNOME_LIBS)					\
-	$(GSTREAMER_LIBS)				\
-	$(POLKIT_GNOME_LIBS)				\
-	$(DBUS_LIBS)					\
-	$(LIBNOTIFY_LIBS)				\
-	$(LOCAL_LIBDBUS_LIBS)				\
-	$(LOCAL_LIBHAL_LIBS)				\
-	$(GPM_EXTRA_LIBS)				\
-	$(NULL)
-
 gnome_power_self_test_CPPFLAGS=	\
 	-DGPM_BUILD_TESTS
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/Makefile.in gnome-power-manager-2.24.4/src/Makefile.in
--- ../g1/gnome-power-manager-2.24.4/src/Makefile.in	2009-02-12 03:47:35.000000000 +0000
+++ gnome-power-manager-2.24.4/src/Makefile.in	2020-04-06 14:22:01.000000000 +0000
@@ -36,16 +36,6 @@
 	gnome-power-preferences$(EXEEXT) \
 	gnome-power-statistics$(EXEEXT) $(am__EXEEXT_1)
 check_PROGRAMS = gnome-power-self-test$(EXEEXT)
-@HAVE_UNIQUE_TRUE@am__append_1 = \
-@HAVE_UNIQUE_TRUE@	$(UNIQUE_LIBS)
-
-@HAVE_UNIQUE_TRUE@am__append_2 = \
-@HAVE_UNIQUE_TRUE@	$(UNIQUE_LIBS)
-
-@HAVE_LIBNOTIFY_TRUE@am__append_3 = \
-@HAVE_LIBNOTIFY_TRUE@	$(LIBNOTIFY_LIBS)				\
-@HAVE_LIBNOTIFY_TRUE@	$(NULL)
-
 TESTS = gnome-power-self-test$(EXEEXT)
 subdir = src
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
@@ -72,8 +62,8 @@
 	gpm-cell-array.$(OBJEXT) gpm-warnings.$(OBJEXT) \
 	gpm-backlight.$(OBJEXT) gpm-prefs-server.$(OBJEXT) \
 	gpm-srv-brightness-kbd.$(OBJEXT) gpm-srv-screensaver.$(OBJEXT) \
-	gpm-conf.$(OBJEXT) gpm-idle.$(OBJEXT) gpm-load.$(OBJEXT) \
-	gpm-profile.$(OBJEXT) gpm-control.$(OBJEXT) \
+	gpm-cpufreq.$(OBJEXT) gpm-conf.$(OBJEXT) gpm-idle.$(OBJEXT) \
+	gpm-load.$(OBJEXT) gpm-profile.$(OBJEXT) gpm-control.$(OBJEXT) \
 	gpm-refcount.$(OBJEXT) gpm-button.$(OBJEXT) \
 	gpm-brightness.$(OBJEXT) gpm-brightness-hal.$(OBJEXT) \
 	gpm-brightness-xrandr.$(OBJEXT) gpm-brightness-kbd.$(OBJEXT) \
@@ -84,12 +74,12 @@
 	gpm-sound.$(OBJEXT) gpm-networkmanager.$(OBJEXT) \
 	gpm-info.$(OBJEXT) gpm-array.$(OBJEXT) \
 	gpm-array-float.$(OBJEXT) gpm-inhibit.$(OBJEXT) \
-	gpm-graph-widget.$(OBJEXT) gpm-feedback-widget.$(OBJEXT) \
+	gpm-graph-widget.$(OBJEXT) egg-array-float.$(OBJEXT) \
+	egg-precision.$(OBJEXT) gpm-session.$(OBJEXT) \
+	gpm-feedback-widget.$(OBJEXT) gpm-point-obj.$(OBJEXT) \
 	$(am__objects_1)
 gnome_power_manager_OBJECTS = $(am_gnome_power_manager_OBJECTS)
 am__DEPENDENCIES_1 =
-@HAVE_LIBNOTIFY_TRUE@am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1) \
-@HAVE_LIBNOTIFY_TRUE@	$(am__DEPENDENCIES_1)
 gnome_power_manager_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
@@ -101,17 +91,18 @@
 	gpm-dpms.$(OBJEXT) gpm-conf.$(OBJEXT) gpm-idle.$(OBJEXT) \
 	gpm-load.$(OBJEXT) gpm-prefs.$(OBJEXT) \
 	gpm-prefs-core.$(OBJEXT) gpm-marshal.$(OBJEXT) \
-	gpm-common.$(OBJEXT) gpm-screensaver.$(OBJEXT) \
-	$(am__objects_1)
+	gpm-control.$(OBJEXT) gpm-networkmanager.$(OBJEXT) \
+	gpm-button.$(OBJEXT) gpm-common.$(OBJEXT) \
+	gpm-screensaver.$(OBJEXT) $(am__objects_1)
 gnome_power_preferences_OBJECTS =  \
 	$(am_gnome_power_preferences_OBJECTS)
-@HAVE_UNIQUE_TRUE@am__DEPENDENCIES_3 = $(am__DEPENDENCIES_1)
 gnome_power_preferences_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(LOCAL_LIBHAL_LIBS) \
-	$(LOCAL_LIBDBUS_LIBS) $(LOCAL_LIBUNIQUE_LIBS) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_3)
+	$(LOCAL_LIBDBUS_LIBS) $(am__DEPENDENCIES_1) \
+	$(LOCAL_LIBUNIQUE_LIBS) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
 am_gnome_power_self_test_OBJECTS =  \
 	gnome_power_self_test-egg-color.$(OBJEXT) \
 	gnome_power_self_test-gpm-ac-adapter.$(OBJEXT) \
@@ -149,13 +140,15 @@
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(LOCAL_LIBDBUS_LIBS) \
 	$(LOCAL_LIBHAL_LIBS) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1)
 am_gnome_power_statistics_OBJECTS = egg-color.$(OBJEXT) \
-	egg-debug.$(OBJEXT) gpm-statistics.$(OBJEXT) \
-	gpm-statistics-core.$(OBJEXT) gpm-array.$(OBJEXT) \
-	gpm-array-float.$(OBJEXT) gpm-graph-widget.$(OBJEXT) \
-	gpm-marshal.$(OBJEXT) gpm-conf.$(OBJEXT) gpm-common.$(OBJEXT) \
-	$(am__objects_1)
+	egg-debug.$(OBJEXT) egg-precision.$(OBJEXT) \
+	gpm-statistics.$(OBJEXT) gpm-statistics-core.$(OBJEXT) \
+	gpm-array.$(OBJEXT) gpm-array-float.$(OBJEXT) \
+	gpm-graph-widget.$(OBJEXT) gpm-marshal.$(OBJEXT) \
+	gpm-conf.$(OBJEXT) gpm-common.$(OBJEXT) \
+	gpm-point-obj.$(OBJEXT) $(am__objects_1)
 gnome_power_statistics_OBJECTS = $(am_gnome_power_statistics_OBJECTS)
 gnome_power_statistics_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
@@ -214,13 +207,14 @@
 CYGPATH_W = @CYGPATH_W@
 DATADIR = @DATADIR@
 DATADIRNAME = @DATADIRNAME@
-DBUS_CFLAGS = @DBUS_CFLAGS@
-DBUS_LIBS = @DBUS_LIBS@
+DBUS_CFLAGS = -D_REENTRANT -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+DBUS_LIBS = -L/usr/lib/amd64 -ldbus-glib-1 -lgobject-2.0 -ldbus-1 -lgthread-2.0
 DBUS_REQUIRED = @DBUS_REQUIRED@
 DBUS_SERVICES_DIR = @DBUS_SERVICES_DIR@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 DISTCHECK_CONFIGURE_FLAGS = @DISTCHECK_CONFIGURE_FLAGS@
+DLLTOOL = @DLLTOOL@
 DOCBOOK2MAN = @DOCBOOK2MAN@
 DOCDIR = @DOCDIR@
 DOC_USER_FORMATS = @DOC_USER_FORMATS@
@@ -235,26 +229,26 @@
 GCONFTOOL = @GCONFTOOL@
 GCONF_SCHEMA_CONFIG_SOURCE = @GCONF_SCHEMA_CONFIG_SOURCE@
 GCONF_SCHEMA_FILE_DIR = @GCONF_SCHEMA_FILE_DIR@
-GDK_CFLAGS = @GDK_CFLAGS@
-GDK_LIBS = @GDK_LIBS@
+GDK_CFLAGS = -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -I/usr/include/gtk-3.0 -I/usr/include/gio-unix-2.0/ -I/usr/include/cairo -I/usr/include/pango-1.0 -I/usr/include/harfbuzz -I/usr/include/pango-1.0 -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/cairo -I/usr/include/pixman-1 -I/usr/include/freetype2 -I/usr/include/libdrm -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+GDK_LIBS = -L/usr/lib/amd64 -lgdk-3 -lgdk_pixbuf-2.0  -lgobject-2.0 -lglib-2.0
 GDK_REQUIRED = @GDK_REQUIRED@
 GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
 GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
-GLIB_LIBS = @GLIB_LIBS@
+GLIB_LIBS = -L/usr/lib/amd64 -lgobject-2.0 -lglib-2.0
 GLIB_REQUIRED = @GLIB_REQUIRED@
 GMOFILES = @GMOFILES@
 GMSGFMT = @GMSGFMT@
 GNOME_CFLAGS = @GNOME_CFLAGS@
 GNOME_LIBS = @GNOME_LIBS@
-GPM_EXTRA_LIBS = @GPM_EXTRA_LIBS@
+GPM_EXTRA_LIBS = -lresolv -lXext -lkstat -lgconf-2 
 GREP = @GREP@
 GSTREAMER_CFLAGS = @GSTREAMER_CFLAGS@
-GSTREAMER_LIBS = @GSTREAMER_LIBS@
+GSTREAMER_LIBS = -lgstreamer-1.0
 GSTREAMER_REQUIRED = @GSTREAMER_REQUIRED@
 GTK_REQUIRED = @GTK_REQUIRED@
-HAL_CFLAGS = @HAL_CFLAGS@
-HAL_LIBS = @HAL_LIBS@
+HAL_CFLAGS = -DDBUS_API_SUBJECT_TO_CHANGE -I/usr/include/hal -I/usr/include/dbus-1.0 -I/usr/lib/amd64/dbus-1.0/include
+HAL_LIBS = -L/usr/lib/amd64 -lhal -ldbus-1
 HAL_REQUIRED = @HAL_REQUIRED@
 HELP_DIR = @HELP_DIR@
 INSTALL = @INSTALL@
@@ -290,10 +284,9 @@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
 LIBGLADE_REQUIRED = @LIBGLADE_REQUIRED@
-LIBGNOMEUI_REQUIRED = @LIBGNOMEUI_REQUIRED@
 LIBGNOME_REQUIRED = @LIBGNOME_REQUIRED@
-LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
-LIBNOTIFY_LIBS = @LIBNOTIFY_LIBS@
+LIBNOTIFY_CFLAGS = -D_REENTRANT -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/libpng14 -I/usr/include/glib-2.0 -I/usr/lib/amd64/glib-2.0/include -I/usr/include/pcre
+LIBNOTIFY_LIBS = -L/usr/lib/amd64 -lnotify
 LIBNOTIFY_REQUIRED = @LIBNOTIFY_REQUIRED@
 LIBOBJS = @LIBOBJS@
 LIBPANEL_REQUIRED = @LIBPANEL_REQUIRED@
@@ -350,12 +343,12 @@
 XMKMF = @XMKMF@
 XMLTO = @XMLTO@
 XRANDR_CFLAGS = @XRANDR_CFLAGS@
-XRANDR_LIBS = @XRANDR_LIBS@
+XRANDR_LIBS = -lXrandr -lXrender -lX11
 XRANDR_REQUIRED = @XRANDR_REQUIRED@
 X_CFLAGS = @X_CFLAGS@
 X_EXTRA_LIBS = @X_EXTRA_LIBS@
 X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
+X_PRE_LIBS = -lSM -lICE
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
 abs_top_builddir = @abs_top_builddir@
@@ -415,36 +408,95 @@
 	gpm-marshal.list				\
 	$(NULL)
 
+CAIRO_LIBS = -L/usr/lib/amd64 -lcairo -lpangocairo-1.0 -lpango-1.0 -latk-1.0 -lcairo-gobject -lgdk_pixbuf-2.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0
 INCLUDES = \
-	$(GLIB_CFLAGS)					\
-	$(HAL_CFLAGS)					\
-	$(DBUS_CFLAGS)					\
-	$(GNOME_CFLAGS)					\
-	$(XRANDR_CFLAGS)				\
-	$(LIBNOTIFY_CFLAGS)				\
-	$(UNIQUE_CFLAGS)				\
-	$(GSTREAMER_CFLAGS)				\
-	$(POLKIT_CFLAGS)				\
-	$(POLKIT_GNOME_CFLAGS)				\
-	-DBINDIR=\"$(bindir)\"			 	\
-	-DGNOMELOCALEDIR=\""$(datadir)/locale"\"	\
-	-DDATADIR=\"$(datadir)\"			\
-	-DPREFIX=\""$(prefix)"\" 			\
-	-DSYSCONFDIR=\""$(sysconfdir)"\" 		\
-	-DLIBDIR=\""$(libdir)"\" 			\
-	-DVERSION="\"$(VERSION)\"" 			\
-	-DGPM_DATA=\"$(pkgdatadir)\"			\
-	-DEGG_LOG_FILE=\""$(PK_LOG_DIR)/gnome-power-manager"\"	\
-	-I$(top_srcdir)					\
-	-I$(top_srcdir)/libunique			\
-	-I$(top_srcdir)/libhal-glib			\
-	-I$(top_srcdir)/libdbus-glib			\
-	$(NULL)
+        $(GLIB_CFLAGS)                                  \
+        $(HAL_CFLAGS)                                   \
+        $(DBUS_CFLAGS)                                  \
+        $(GNOME_CFLAGS)                                 \
+        $(XRANDR_CFLAGS)                                \
+        $(LIBNOTIFY_CFLAGS)                             \
+        $(UNIQUE_CFLAGS)                                \
+        $(POLKIT_CFLAGS)                                \
+        $(POLKIT_GNOME_CFLAGS)                          \
+        -DBINDIR=\"$(bindir)\"                          \
+        -DGNOMELOCALEDIR=\""$(datadir)/locale"\"        \
+        -DDATADIR=\"$(datadir)\"                        \
+        -DPREFIX=\""$(prefix)"\"                        \
+        -DSYSCONFDIR=\""$(sysconfdir)"\"                \
+        -DLIBDIR=\""$(libdir)"\"                        \
+        -DVERSION="\"$(VERSION)\""                      \
+        -DGPM_DATA=\"$(pkgdatadir)\"                    \
+        -DEGG_LOG_FILE=\""$(PK_LOG_DIR)/gnome-power-manager"\"  \
+        -I$(top_srcdir)                                 \
+        -I$(top_srcdir)/libunique                       \
+        -I$(top_srcdir)/libhal-glib                     \
+        -I$(top_srcdir)/libdbus-glib                    \
+        -I/usr/include/dbus-1.0                                 \
+        -I/usr/lib/amd64/dbus-1.0/include                       \
+        -I/usr/include/glib-2.0                                 \
+        -I/usr/lib/amd64/glib-2.0/include                       \
+        -I/usr/include/pcre                                     \
+        -I/usr/include/gtk-3.0                                  \
+        -I/usr/include/gio-unix-2.0                             \
+        -I/usr/include/cairo                                    \
+        -I/usr/include/pango-1.0                                \
+        -I/usr/include/gdk-pixbuf-2.0                           \
+        -I/usr/include/libpng14                                 \
+        -I/usr/include/pixman-1                                 \
+        -I/usr/include/atk-1.0                                  \
+        -I/usr/include/gconf/2                                  \
+        -I/usr/include/gstreamer-1.0                            \
+        $(NULL)
+
+gnome_power_preferences_LDADD = $(GLIB_LIBS) $(GNOME_LIBS) $(HAL_LIBS) \
+        $(DBUS_LIBS) $(POLKIT_LIBS) $(GPM_EXTRA_LIBS) \
+        $(LOCAL_LIBHAL_LIBS) $(LOCAL_LIBDBUS_LIBS) $(XRANDR_LIBS) \
+        $(LOCAL_LIBUNIQUE_LIBS) $(CAIRO_LIBS) $(NULL) $(am__append_2)
+
+gnome_power_manager_LDADD = \
+        $(GLIB_LIBS)                                    \
+        $(GSTREAMER_LIBS)                               \
+        $(GNOME_LIBS)                                   \
+        $(HAL_LIBS)                                     \
+        $(POLKIT_LIBS)                                  \
+        $(DBUS_LIBS)                                    \
+        $(XRANDR_LIBS)                                  \
+        $(GPM_EXTRA_LIBS)                               \
+        $(LOCAL_LIBHAL_LIBS)                            \
+        $(LOCAL_LIBDBUS_LIBS)                           \
+        $(GDK_LIBS)                                     \
+        $(X_LIBS)                                       \
+        $(CAIRO_LIBS)                                   \
+	$(LIBNOTIFY_LIBS)					\
+	$(GSTREAMER_LIBS)				\
+        $(am__append_3)                                 \
+        $(NULL)
+
+gnome_power_statistics_LDADD = $(GLIB_LIBS) $(GNOME_LIBS) $(DBUS_LIBS) \
+        $(LOCAL_LIBDBUS_LIBS) $(LOCAL_LIBUNIQUE_LIBS) $(NULL) \
+        $(CAIRO_LIBS) $(XRANDR_LIBS) $(GPM_EXTRA_LIBS) \
+        $(am__append_1)
+
+gnome_power_self_test_LDADD = \
+        $(GLIB_LIBS)                                    \
+        $(GNOME_LIBS)                                   \
+        $(GSTREAMER_LIBS)                               \
+        $(POLKIT_GNOME_LIBS)                            \
+        $(DBUS_LIBS)                                    \
+        $(LIBNOTIFY_LIBS)                               \
+        $(LOCAL_LIBDBUS_LIBS)                           \
+        $(LOCAL_LIBHAL_LIBS)                            \
+        $(GPM_EXTRA_LIBS)                               \
+        $(XRANDR_LIBS)                                  \
+        $(CAIRO_LIBS)                                   \
+        $(NULL)
 
 LOCAL_LIBHAL_LIBS = \
 	$(top_builddir)/libhal-glib/libhal-gdevice.la	\
 	$(top_builddir)/libhal-glib/libhal-gdevicestore.la	\
 	$(top_builddir)/libhal-glib/libhal-gmanager.la	\
+	$(top_builddir)/libhal-glib/libhal-gcpufreq.la	\
 	$(top_builddir)/libhal-glib/libhal-gpower.la
 
 LOCAL_LIBDBUS_LIBS = \
@@ -461,6 +513,8 @@
 	egg-color.h					\
 	egg-debug.h					\
 	egg-debug.c					\
+        egg-precision.h                                 \
+        egg-precision.c                                 \
 	gpm-statistics.c				\
 	gpm-statistics-core.h				\
 	gpm-statistics-core.c				\
@@ -476,11 +530,10 @@
 	gpm-conf.c					\
 	gpm-common.h					\
 	gpm-common.c					\
+        gpm-point-obj.c					\
+        gpm-point-obj.h					\
 	$(NULL)
 
-gnome_power_statistics_LDADD = $(GLIB_LIBS) $(GNOME_LIBS) $(DBUS_LIBS) \
-	$(LOCAL_LIBDBUS_LIBS) $(LOCAL_LIBUNIQUE_LIBS) $(NULL) \
-	$(am__append_1)
 gnome_power_preferences_SOURCES = \
 	egg-debug.h					\
 	egg-debug.c					\
@@ -498,16 +551,18 @@
 	gpm-prefs-core.c				\
 	gpm-marshal.h					\
 	gpm-marshal.c					\
+	gpm-control.h					\
+	gpm-control.c					\
+	gpm-networkmanager.h				\
+	gpm-networkmanager.c				\
+	gpm-button.c					\
+	gpm-button.h					\
 	gpm-common.h					\
 	gpm-common.c					\
 	gpm-screensaver.h				\
 	gpm-screensaver.c				\
 	$(NULL)
 
-gnome_power_preferences_LDADD = $(GLIB_LIBS) $(GNOME_LIBS) $(HAL_LIBS) \
-	$(DBUS_LIBS) $(POLKIT_GNOME_LIBS) $(GPM_EXTRA_LIBS) \
-	$(LOCAL_LIBHAL_LIBS) $(LOCAL_LIBDBUS_LIBS) \
-	$(LOCAL_LIBUNIQUE_LIBS) $(NULL) $(am__append_2)
 gnome_power_manager_SOURCES = \
 	egg-color.c					\
 	egg-color.h					\
@@ -539,6 +594,8 @@
 	gpm-srv-brightness-kbd.c			\
 	gpm-srv-screensaver.h				\
 	gpm-srv-screensaver.c				\
+	gpm-cpufreq.c					\
+	gpm-cpufreq.h					\
 	gpm-conf.h					\
 	gpm-conf.c					\
 	gpm-idle.h					\
@@ -591,14 +648,18 @@
 	gpm-inhibit.c					\
 	gpm-graph-widget.h				\
 	gpm-graph-widget.c				\
-	gpm-feedback-widget.h				\
-	gpm-feedback-widget.c				\
+	egg-array-float.h                               \
+        egg-array-float.c                               \
+        egg-precision.h                                 \
+        egg-precision.c                                 \
+        gpm-session.h                                   \
+        gpm-session.c                                   \
+        gpm-feedback-widget.c                           \
+        gpm-feedback-widget.h                           \
+        gpm-point-obj.c					\
+        gpm-point-obj.h					\
 	$(NULL)
 
-gnome_power_manager_LDADD = $(GLIB_LIBS) $(GSTREAMER_LIBS) \
-	$(GNOME_LIBS) $(HAL_LIBS) $(POLKIT_LIBS) $(DBUS_LIBS) \
-	$(XRANDR_LIBS) $(GPM_EXTRA_LIBS) $(LOCAL_LIBHAL_LIBS) \
-	$(LOCAL_LIBDBUS_LIBS) $(NULL) $(am__append_3)
 gnome_power_self_test_SOURCES = \
 	egg-color.c					\
 	egg-color.h					\
@@ -660,18 +721,6 @@
 	gpm-graph-widget.c				\
 	$(NULL)
 
-gnome_power_self_test_LDADD = \
-	$(GLIB_LIBS)					\
-	$(GNOME_LIBS)					\
-	$(GSTREAMER_LIBS)				\
-	$(POLKIT_GNOME_LIBS)				\
-	$(DBUS_LIBS)					\
-	$(LIBNOTIFY_LIBS)				\
-	$(LOCAL_LIBDBUS_LIBS)				\
-	$(LOCAL_LIBHAL_LIBS)				\
-	$(GPM_EXTRA_LIBS)				\
-	$(NULL)
-
 gnome_power_self_test_CPPFLAGS = \
 	-DGPM_BUILD_TESTS
 
@@ -774,81 +823,86 @@
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-color.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-console-kit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-debug.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-egg-color.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-egg-debug.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-ac-adapter.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-array-float.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-array.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-button.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-cell-array.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-cell-unit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-cell.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-common.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-conf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-control.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-dpms.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-engine.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-graph-widget.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-idle.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-info.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-inhibit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-load.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-marshal.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-networkmanager.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-notify.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-phone.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-prefs-server.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-profile.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-screensaver.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-self-test.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-sound.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-warnings.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-ac-adapter.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-array-float.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-array.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-backlight.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness-hal.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness-kbd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness-xrandr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-button.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cell-array.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cell-unit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cell.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-common.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-conf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-control.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-dpms.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-engine.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-feedback-widget.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-graph-widget.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-idle.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-info.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-inhibit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-light-sensor.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-load.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-main.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-manager.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-marshal.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-networkmanager.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-notify.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-phone.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-prefs-core.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-prefs-server.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-prefs.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-profile.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-refcount.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-screensaver.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-sound.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-srv-brightness-kbd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-srv-screensaver.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-statistics-core.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-statistics.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-tray-icon.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-warnings.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-array-float.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-color.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-console-kit.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-debug.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egg-precision.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-egg-color.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-egg-debug.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-ac-adapter.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-array-float.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-array.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-button.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-cell-array.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-cell-unit.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-cell.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-common.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-conf.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-control.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-dpms.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-engine.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-graph-widget.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-idle.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-info.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-inhibit.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-load.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-marshal.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-networkmanager.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-notify.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-phone.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-prefs-server.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-profile.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-screensaver.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-self-test.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-sound.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnome_power_self_test-gpm-warnings.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-ac-adapter.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-array-float.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-array.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-backlight.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness-hal.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness-kbd.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness-xrandr.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-brightness.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-button.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cell-array.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cell-unit.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cell.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-common.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-conf.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-control.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-cpufreq.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-dpms.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-engine.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-feedback-widget.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-graph-widget.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-idle.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-info.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-inhibit.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-light-sensor.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-load.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-main.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-manager.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-marshal.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-networkmanager.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-notify.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-phone.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-point-obj.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-prefs-core.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-prefs-server.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-prefs.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-profile.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-refcount.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-screensaver.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-session.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-sound.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-srv-brightness-kbd.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-srv-screensaver.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-statistics-core.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-statistics.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-tray-icon.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gpm-warnings.Po@am__quote@ # am--include-marker
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff -urN ../g1/gnome-power-manager-2.24.4/src/egg-array-float.c gnome-power-manager-2.24.4/src/egg-array-float.c
--- ../g1/gnome-power-manager-2.24.4/src/egg-array-float.c	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/egg-array-float.c	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,770 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007-2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <glib.h>
+
+#include "egg-debug.h"
+#include "egg-array-float.h"
+
+/**
+ * egg_array_float_guassian_value:
+ *
+ * @x: input value
+ * @sigma: sigma value
+ * Return value: the gaussian, in floating point precision
+ **/
+static gfloat
+egg_array_float_guassian_value (gfloat x, gfloat sigma)
+{
+	return (1.0 / (sqrtf(2.0*3.1415927) * sigma)) * (expf((-(powf(x,2.0)))/(2.0 * powf(sigma, 2.0))));
+}
+
+/**
+ * egg_array_float_new:
+ *
+ * @length: length of array
+ * Return value: Allocate array
+ *
+ * Creates a new size array which is zeroed. Free with g_array_free();
+ **/
+EggArrayFloat *
+egg_array_float_new (guint length)
+{
+	guint i;
+	EggArrayFloat *array;
+	array = g_array_sized_new (TRUE, FALSE, sizeof(gfloat), length);
+	array->len = length;
+
+	/* clear to 0.0 */
+	for (i=0; i<length; i++)
+		g_array_index (array, gfloat, i) = 0.0;
+	return array;
+}
+
+/**
+ * egg_array_float_get:
+ *
+ * @array: input array
+ **/
+gfloat
+egg_array_float_get (EggArrayFloat *array, guint i)
+{
+	if (i >= array->len)
+		g_error ("above index! (%i)", i);
+	return g_array_index (array, gfloat, i);
+}
+
+/**
+ * egg_array_float_set:
+ *
+ * @array: input array
+ **/
+void
+egg_array_float_set (EggArrayFloat *array, guint i, gfloat value)
+{
+	g_array_index (array, gfloat, i) = value;
+}
+
+/**
+ * egg_array_float_free:
+ *
+ * @array: input array
+ *
+ * Frees the array, deallocating data
+ **/
+void
+egg_array_float_free (EggArrayFloat *array)
+{
+	if (array != NULL)
+		g_array_free (array, TRUE);
+}
+
+/**
+ * egg_array_float_get_average:
+ * @array: This class instance
+ *
+ * Gets the average value.
+ **/
+gfloat
+egg_array_float_get_average (EggArrayFloat *array)
+{
+	guint i;
+	guint length;
+	gfloat average = 0;
+
+	length = array->len;
+	for (i=0; i<length; i++)
+		average += g_array_index (array, gfloat, i);
+	return average / (gfloat) length;
+}
+
+/**
+ * egg_array_float_compute_gaussian:
+ *
+ * @length: length of output array
+ * @sigma: sigma value
+ * Return value: Gaussian array
+ *
+ * Create a set of Gaussian array of a specified size
+ **/
+EggArrayFloat *
+egg_array_float_compute_gaussian (guint length, gfloat sigma)
+{
+	EggArrayFloat *array;
+	guint half_length;
+	guint i;
+	gfloat division;
+	gfloat value;
+
+	g_return_val_if_fail (length % 2 == 1, NULL);
+
+	array = egg_array_float_new (length);
+
+	/* array positions 0..length, has to be an odd number */
+	half_length = (length / 2) + 1;
+	for (i=0; i<half_length; i++) {
+		division = half_length - (i + 1);
+	egg_debug ("half_length=%i, div=%f, sigma=%f", half_length, division, sigma);
+		g_array_index (array, gfloat, i) = egg_array_float_guassian_value (division, sigma);
+	}
+
+	/* no point working these out, we can just reflect the gaussian */
+	for (i=half_length; i<length; i++) {
+		division = g_array_index (array, gfloat, length-(i+1));
+		g_array_index (array, gfloat, i) = division;
+	}
+
+	/* make sure we get an accurate gaussian */
+	value = egg_array_float_sum (array);
+	if (fabs (value - 1.0f) > 0.01f) {
+		egg_warning ("got wrong sum (%f), perhaps sigma too high for size?", value);
+		egg_array_float_free (array);
+		array = NULL;
+	}
+
+	return array;
+}
+
+/**
+ * egg_array_float_sum:
+ *
+ * @array: input array
+ *
+ * Sum the elements of the array
+ **/
+gfloat
+egg_array_float_sum (EggArrayFloat *array)
+{
+	guint length;
+	guint i;
+	gfloat total = 0;
+
+	length = array->len;
+	for (i=0; i<length; i++)
+		total += g_array_index (array, gfloat, i);
+	return total;
+}
+
+/**
+ * egg_array_float_print:
+ *
+ * @array: input array
+ *
+ * Print the array
+ **/
+gboolean
+egg_array_float_print (EggArrayFloat *array)
+{
+	guint length;
+	guint i;
+
+	length = array->len;
+	/* debug out */
+	for (i=0; i<length; i++)
+		egg_debug ("[%i]\tval=%f", i, g_array_index (array, gfloat, i));
+	return TRUE;
+}
+
+/**
+ * egg_array_float_convolve:
+ *
+ * @data: input array
+ * @kernel: kernel array
+ * Return value: Colvolved array, same length as data
+ *
+ * Convolves an array with a kernel, and returns an array the same size.
+ * THIS FUNCTION IS REALLY SLOW...
+ **/
+EggArrayFloat *
+egg_array_float_convolve (EggArrayFloat *data, EggArrayFloat *kernel)
+{
+	gint length_data;
+	gint length_kernel;
+	EggArrayFloat *result;
+	gfloat value;
+	gint i;
+	gint j;
+	gint idx;
+
+	length_data = data->len;
+	length_kernel = kernel->len;
+
+	result = egg_array_float_new (length_data);
+
+	/* convolve */
+	for (i=0;i<length_data;i++) {
+		value = 0;
+		for (j=0;j<length_kernel;j++) {
+			idx = i+j-(length_kernel/2);
+			if (idx < 0)
+				idx = 0;
+			else if (idx >= length_data)
+				idx = length_data - 1;
+			value += g_array_index (data, gfloat, idx) * g_array_index (kernel, gfloat, j);
+		}
+		g_array_index (result, gfloat, i) = value;
+	}
+	return result;
+}
+
+/**
+ * egg_array_float_compute_integral:
+ * @array: This class instance
+ *
+ * Computes complete discrete integral of dataset.
+ * Will only work with a step size of one.
+ **/
+gfloat
+egg_array_float_compute_integral (EggArrayFloat *array, guint x1, guint x2)
+{
+	gfloat value;
+	guint i;
+
+	g_return_val_if_fail (x2 >= x1, 0.0);
+
+	/* if the same point, then we have no area */
+	if (x1 == x2)
+		return 0.0;
+
+	value = 0.0;
+	for (i=x1; i <= x2; i++)
+		value += g_array_index (array, gfloat, i);
+	return value;
+}
+
+/**
+ * powfi:
+ **/
+static gfloat
+powfi (gfloat base, guint n)
+{
+	guint i;
+	gfloat retval = 1;
+	for (i=1; i <= n; i++)
+		retval *= base;
+	return retval;
+}
+
+/**
+ * egg_array_float_remove_outliers:
+ *
+ * @data: input array
+ * @size: size to analyse
+ * @sigma: sigma for standard deviation
+ * Return value: Data with outliers removed
+ *
+ * Compares local sections of the data, removing outliers if they fall
+ * outside of sigma, and using the average of the other points in its place.
+ **/
+EggArrayFloat *
+egg_array_float_remove_outliers (EggArrayFloat *data, guint length, gfloat sigma)
+{
+	guint i;
+	guint j;
+	guint half_length;
+	gfloat value;
+	gfloat average;
+	gfloat average_not_inc;
+	gfloat average_square;
+	gfloat biggest_difference;
+	gfloat outlier_value;
+	EggArrayFloat *result;
+
+	g_return_val_if_fail (length % 2 == 1, NULL);
+	result = egg_array_float_new (data->len);
+
+	/* check for no data */
+	if (data->len == 0)
+		goto out;
+
+	half_length = (length - 1) / 2;
+
+	/* copy start and end of array */
+	for (i=0; i < half_length; i++)
+		g_array_index (result, gfloat, i) = g_array_index (data, gfloat, i);
+	for (i=data->len-half_length; i < data->len; i++)
+		g_array_index (result, gfloat, i) = g_array_index (data, gfloat, i);
+
+	/* find the standard deviation of a block off data */
+	for (i=half_length; i < data->len-half_length; i++) {
+		average = 0;
+		average_square = 0;
+
+		/* find the average and the squared average */
+		for (j=i-half_length; j<i+half_length+1; j++) {
+			value = g_array_index (data, gfloat, j);
+			average += value;
+			average_square += powfi (value, 2);
+		}
+
+		/* divide by length to get average */
+		average /= length;
+		average_square /= length;
+
+		/* find the standard deviation */
+		value = sqrtf (average_square - powfi (average, 2));
+
+		/* stddev is okay */
+		if (value < sigma) {
+			g_array_index (result, gfloat, i) = g_array_index (data, gfloat, i);
+		} else {
+			/* ignore the biggest difference from the average */
+			biggest_difference = 0;
+			outlier_value = 0;
+			for (j=i-half_length; j<i+half_length+1; j++) {
+				value = fabs (g_array_index (data, gfloat, j) - average);
+				if (value > biggest_difference) {
+					biggest_difference = value;
+					outlier_value = g_array_index (data, gfloat, j);
+				}
+			}
+			average_not_inc = (average * length) - outlier_value;
+			average_not_inc /= length - 1;
+			g_array_index (result, gfloat, i) = average_not_inc;
+		}
+	}
+out:
+	return result;
+}
+
+/***************************************************************************
+ ***                          MAKE CHECK TESTS                           ***
+ ***************************************************************************/
+#ifdef EGG_TEST
+#include "egg-test.h"
+
+void
+egg_array_float_test (gpointer data)
+{
+	EggArrayFloat *array;
+	EggArrayFloat *kernel;
+	EggArrayFloat *result;
+	gfloat value;
+	gfloat sigma;
+	guint size;
+	EggTest *test = (EggTest *) data;
+
+	if (egg_test_start (test, "EggArrayFloat") == FALSE)
+		return;
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get a non null array");
+	array = egg_array_float_new (10);
+	if (array != NULL)
+		egg_test_success (test, "got EggArrayFloat");
+	else
+		egg_test_failed (test, "could not get EggArrayFloat");
+	egg_array_float_print (array);
+	egg_array_float_free (array);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct length array");
+	array = egg_array_float_new (10);
+	if (array->len == 10)
+		egg_test_success (test, "got correct size");
+	else
+		egg_test_failed (test, "got wrong size");
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum");
+	value = egg_array_float_sum (array);
+	if (value == 0.0)
+		egg_test_success (test, "got correct sum");
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "remove outliers");
+	egg_array_float_set (array, 0, 30.0);
+	egg_array_float_set (array, 1, 29.0);
+	egg_array_float_set (array, 2, 31.0);
+	egg_array_float_set (array, 3, 33.0);
+	egg_array_float_set (array, 4, 100.0);
+	egg_array_float_set (array, 5, 27.0);
+	egg_array_float_set (array, 6, 30.0);
+	egg_array_float_set (array, 7, 29.0);
+	egg_array_float_set (array, 8, 31.0);
+	egg_array_float_set (array, 9, 30.0);
+	kernel = egg_array_float_remove_outliers (array, 3, 10.0);
+	if (kernel != NULL && kernel->len == 10) 
+		egg_test_success (test, "got correct length outlier array");
+	else
+		egg_test_failed (test, "got gaussian array length (%i)", array->len);
+	egg_array_float_print (array);
+	egg_array_float_print (kernel);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we removed the outliers");
+	value = egg_array_float_sum (kernel);
+	if (fabs(value - 30*10) < 1)
+		egg_test_success (test, "got sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+	egg_array_float_free (kernel);
+
+	/************************************************************/
+	egg_test_title (test, "remove outliers step");
+	egg_array_float_set (array, 0, 0.0);
+	egg_array_float_set (array, 1, 0.0);
+	egg_array_float_set (array, 2, 0.0);
+	egg_array_float_set (array, 3, 0.0);
+	egg_array_float_set (array, 4, 0.0);
+	egg_array_float_set (array, 5, 0.0);
+	egg_array_float_set (array, 6, 0.0);
+	egg_array_float_set (array, 7, 10.0);
+	egg_array_float_set (array, 8, 20.0);
+	egg_array_float_set (array, 9, 50.0);
+	kernel = egg_array_float_remove_outliers (array, 3, 20.0);
+	if (kernel != NULL && kernel->len == 10) 
+		egg_test_success (test, "got correct length outlier array");
+	else
+		egg_test_failed (test, "got gaussian array length (%i)", array->len);
+	egg_array_float_print (array);
+	egg_array_float_print (kernel);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we removed the outliers");
+	value = egg_array_float_sum (kernel);
+	if (fabs(value - 80) < 1)
+		egg_test_success (test, "got sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+	egg_array_float_free (kernel);
+
+	/************************************************************/
+	egg_test_title (test, "get gaussian 0.0, sigma 1.1");
+	value = egg_array_float_guassian_value (0.0, 1.1);
+	if (fabs (value - 0.36267) < 0.0001)
+		egg_test_success (test, "got correct gaussian");
+	else
+		egg_test_failed (test, "got wrong gaussian (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "get gaussian 0.5, sigma 1.1");
+	value = egg_array_float_guassian_value (0.5, 1.1);
+	if (fabs (value - 0.32708) < 0.0001)
+		egg_test_success (test, "got correct gaussian");
+	else
+		egg_test_failed (test, "got wrong gaussian (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "get gaussian 1.0, sigma 1.1");
+	value = egg_array_float_guassian_value (1.0, 1.1);
+	if (fabs (value - 0.23991) < 0.0001)
+		egg_test_success (test, "got correct gaussian");
+	else
+		egg_test_failed (test, "got wrong gaussian (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "get gaussian 0.5, sigma 4.5");
+	value = egg_array_float_guassian_value (0.5, 4.5);
+	if (fabs (value - 0.088108) < 0.0001)
+		egg_test_success (test, "got correct gaussian");
+	else
+		egg_test_failed (test, "got wrong gaussian (%f)", value);
+
+	/************************************************************/
+	size = 5;
+	sigma = 1.1;
+	egg_test_title (test, "get inprecise gaussian array (%i), sigma %f", size, sigma);
+	kernel = egg_array_float_compute_gaussian (size, sigma);
+	if (kernel == NULL) 
+		egg_test_success (test, NULL);
+	else {
+		egg_test_failed (test, "got gaussian array length (%i)", array->len);
+		egg_array_float_print (kernel);
+	}
+
+	/************************************************************/
+	size = 9;
+	sigma = 1.1;
+	egg_test_title (test, "get gaussian-9 array (%i), sigma %f", size, sigma);
+	kernel = egg_array_float_compute_gaussian (size, sigma);
+	if (kernel != NULL && kernel->len == size) 
+		egg_test_success (test, "got correct length gaussian array");
+	else
+		egg_test_failed (test, "got gaussian array length (%i)", array->len);
+	egg_array_float_print (kernel);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get an accurate gaussian");
+	value = egg_array_float_sum (kernel);
+	if (fabs(value - 1.0) < 0.01)
+		egg_test_success (test, "got sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get get and set");
+	egg_array_float_set (array, 4, 100.0);
+	value = egg_array_float_get (array, 4);
+	if (value == 100.0)
+		egg_test_success (test, "got value okay", value);
+	else
+		egg_test_failed (test, "got wrong value (%f)", value);
+	egg_array_float_print (array);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum (2)");
+	egg_array_float_set (array, 0, 20.0);
+	egg_array_float_set (array, 1, 44.0);
+	egg_array_float_set (array, 2, 45.0);
+	egg_array_float_set (array, 3, 89.0);
+	egg_array_float_set (array, 4, 100.0);
+	egg_array_float_set (array, 5, 12.0);
+	egg_array_float_set (array, 6, 76.0);
+	egg_array_float_set (array, 7, 78.0);
+	egg_array_float_set (array, 8, 1.20);
+	egg_array_float_set (array, 9, 3.0);
+	value = egg_array_float_sum (array);
+	if (fabs (value - 468.2) < 0.0001f)
+		egg_test_success (test, "got correct sum");
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "test convolving with kernel #1");
+	egg_array_float_set (array, 0, 0.0);
+	egg_array_float_set (array, 1, 0.0);
+	egg_array_float_set (array, 2, 0.0);
+	egg_array_float_set (array, 3, 0.0);
+	egg_array_float_set (array, 4, 100.0);
+	egg_array_float_set (array, 5, 0.0);
+	egg_array_float_set (array, 6, 0.0);
+	egg_array_float_set (array, 7, 0.0);
+	egg_array_float_set (array, 8, 0.0);
+	egg_array_float_set (array, 9, 0.0);
+	result = egg_array_float_convolve (array, kernel);
+	if (result->len == 10)
+		egg_test_success (test, "got correct size convolve product");
+	else
+		egg_test_failed (test, "got correct size convolve product (%f)", result->len);
+	egg_array_float_print (result);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum of convolve #1");
+	value = egg_array_float_sum (result);
+	if (fabs(value - 100.0) < 5.0)
+		egg_test_success (test, "got correct (enough) sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+	egg_array_float_free (result);
+
+	/************************************************************/
+	egg_test_title (test, "test convolving with kernel #2");
+	egg_array_float_set (array, 0, 100.0);
+	egg_array_float_set (array, 1, 0.0);
+	egg_array_float_set (array, 2, 0.0);
+	egg_array_float_set (array, 3, 0.0);
+	egg_array_float_set (array, 4, 0.0);
+	egg_array_float_set (array, 5, 0.0);
+	egg_array_float_set (array, 6, 0.0);
+	egg_array_float_set (array, 7, 0.0);
+	egg_array_float_set (array, 8, 0.0);
+	egg_array_float_set (array, 9, 0.0);
+	result = egg_array_float_convolve (array, kernel);
+	if (result->len == 10)
+		egg_test_success (test, "got correct size convolve product");
+	else
+		egg_test_failed (test, "got correct size convolve product (%f)", result->len);
+	egg_array_float_print (array);
+	egg_array_float_print (result);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum of convolve #2");
+	value = egg_array_float_sum (result);
+	if (fabs(value - 100.0) < 10.0)
+		egg_test_success (test, "got correct (enough) sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+
+	egg_array_float_free (result);
+
+	/************************************************************/
+	egg_test_title (test, "test convolving with kernel #3");
+	egg_array_float_set (array, 0, 0.0);
+	egg_array_float_set (array, 1, 0.0);
+	egg_array_float_set (array, 2, 0.0);
+	egg_array_float_set (array, 3, 0.0);
+	egg_array_float_set (array, 4, 0.0);
+	egg_array_float_set (array, 5, 0.0);
+	egg_array_float_set (array, 6, 0.0);
+	egg_array_float_set (array, 7, 0.0);
+	egg_array_float_set (array, 8, 0.0);
+	egg_array_float_set (array, 9, 100.0);
+	result = egg_array_float_convolve (array, kernel);
+	if (result->len == 10)
+		egg_test_success (test, "got correct size convolve product");
+	else
+		egg_test_failed (test, "got correct size convolve product (%f)", result->len);
+	egg_array_float_print (array);
+	egg_array_float_print (result);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum of convolve #3");
+	value = egg_array_float_sum (result);
+	if (fabs(value - 100.0) < 10.0)
+		egg_test_success (test, "got correct (enough) sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+	egg_array_float_free (result);
+
+	/************************************************************/
+	egg_test_title (test, "test convolving with kernel #4");
+	egg_array_float_set (array, 0, 10.0);
+	egg_array_float_set (array, 1, 10.0);
+	egg_array_float_set (array, 2, 10.0);
+	egg_array_float_set (array, 3, 10.0);
+	egg_array_float_set (array, 4, 10.0);
+	egg_array_float_set (array, 5, 10.0);
+	egg_array_float_set (array, 6, 10.0);
+	egg_array_float_set (array, 7, 10.0);
+	egg_array_float_set (array, 8, 10.0);
+	egg_array_float_set (array, 9, 10.0);
+	result = egg_array_float_convolve (array, kernel);
+	if (result->len == 10)
+		egg_test_success (test, "got correct size convolve product");
+	else
+		egg_test_failed (test, "got incorrect size convolve product (%f)", result->len);
+	egg_array_float_print (array);
+	egg_array_float_print (result);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum of convolve #4");
+	value = egg_array_float_sum (result);
+	if (fabs(value - 100.0) < 1.0)
+		egg_test_success (test, "got correct (enough) sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+
+	/************************************************************/
+	egg_test_title (test, "test convolving with kernel #5");
+	egg_array_float_set (array, 0, 10.0);
+	egg_array_float_set (array, 1, 10.0);
+	egg_array_float_set (array, 2, 10.0);
+	egg_array_float_set (array, 3, 10.0);
+	egg_array_float_set (array, 4, 0.0);
+	egg_array_float_set (array, 5, 10.0);
+	egg_array_float_set (array, 6, 10.0);
+	egg_array_float_set (array, 7, 10.0);
+	egg_array_float_set (array, 8, 10.0);
+	egg_array_float_set (array, 9, 10.0);
+	result = egg_array_float_convolve (array, kernel);
+	if (result->len == 10)
+		egg_test_success (test, "got correct size convolve product");
+	else
+		egg_test_failed (test, "got incorrect size convolve product (%f)", result->len);
+	egg_array_float_print (array);
+	egg_array_float_print (result);
+
+	/************************************************************/
+	egg_test_title (test, "make sure we get the correct array sum of convolve #5");
+	value = egg_array_float_sum (result);
+	if (fabs(value - 90.0) < 1.0)
+		egg_test_success (test, "got correct (enough) sum (%f)", value);
+	else
+		egg_test_failed (test, "got wrong sum (%f)", value);
+
+	/*************** INTEGRATION TEST ************************/
+	egg_test_title (test, "integration down");
+	egg_array_float_set (array, 0, 0.0);
+	egg_array_float_set (array, 1, 1.0);
+	egg_array_float_set (array, 2, 2.0);
+	egg_array_float_set (array, 3, 3.0);
+	egg_array_float_set (array, 4, 4.0);
+	egg_array_float_set (array, 5, 5.0);
+	egg_array_float_set (array, 6, 6.0);
+	egg_array_float_set (array, 7, 7.0);
+	egg_array_float_set (array, 8, 8.0);
+	egg_array_float_set (array, 9, 9.0);
+	size = egg_array_float_compute_integral (array, 0, 4);
+	if (size == 0+1+2+3+4)
+		egg_test_success (test, "intergrated okay");
+	else
+		egg_test_failed (test, "did not intergrated okay (%i)", size);
+	egg_test_title (test, "integration up");
+	size = egg_array_float_compute_integral (array, 5, 9);
+	if (size == 5+6+7+8+9)
+		egg_test_success (test, "intergrated okay");
+	else
+		egg_test_failed (test, "did not intergrated okay (%i)", size);
+	egg_test_title (test, "integration all");
+	size = egg_array_float_compute_integral (array, 0, 9);
+	if (size == 0+1+2+3+4+5+6+7+8+9)
+		egg_test_success (test, "intergrated okay");
+	else
+		egg_test_failed (test, "did not intergrated okay (%i)", size);
+
+	/*************** AVERAGE TEST ************************/
+	egg_test_title (test, "average");
+	egg_array_float_set (array, 0, 0.0);
+	egg_array_float_set (array, 1, 1.0);
+	egg_array_float_set (array, 2, 2.0);
+	egg_array_float_set (array, 3, 3.0);
+	egg_array_float_set (array, 4, 4.0);
+	egg_array_float_set (array, 5, 5.0);
+	egg_array_float_set (array, 6, 6.0);
+	egg_array_float_set (array, 7, 7.0);
+	egg_array_float_set (array, 8, 8.0);
+	egg_array_float_set (array, 9, 9.0);
+	value = egg_array_float_get_average (array);
+	if (value == 4.5)
+		egg_test_success (test, "averaged okay");
+	else
+		egg_test_failed (test, "did not average okay (%i)", value);
+
+	egg_array_float_free (result);
+	egg_array_float_free (array);
+	egg_array_float_free (kernel);
+
+	egg_test_end (test);
+}
+
+#endif
+
diff -urN ../g1/gnome-power-manager-2.24.4/src/egg-array-float.h gnome-power-manager-2.24.4/src/egg-array-float.h
--- ../g1/gnome-power-manager-2.24.4/src/egg-array-float.h	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/egg-array-float.h	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,56 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007-2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __EGG_ARRAY_FLOAT_H
+#define __EGG_ARRAY_FLOAT_H
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+/* at the moment just use a GArray as it's quick */
+typedef GArray EggArrayFloat;
+
+EggArrayFloat	*egg_array_float_new			(guint		 length);
+void		 egg_array_float_free			(EggArrayFloat	*array);
+gfloat		 egg_array_float_sum			(EggArrayFloat	*array);
+EggArrayFloat	*egg_array_float_compute_gaussian	(guint		 length,
+							 gfloat		 sigma);
+gfloat		 egg_array_float_compute_integral	(EggArrayFloat	*array,
+							 guint		 x1,
+							 guint		 x2);
+gfloat		 egg_array_float_get_average		(EggArrayFloat	*array);
+gboolean	 egg_array_float_print			(EggArrayFloat	*array);
+EggArrayFloat	*egg_array_float_convolve		(EggArrayFloat	*data,
+							 EggArrayFloat	*kernel);
+gfloat		 egg_array_float_get			(EggArrayFloat	*array,
+							 guint		 i);
+void		 egg_array_float_set			(EggArrayFloat	*array,
+							 guint		 i,
+							 gfloat		 value);
+EggArrayFloat	*egg_array_float_remove_outliers	(EggArrayFloat *data, guint length, gfloat sigma);
+#ifdef EGG_TEST
+void		 egg_array_float_test			(gpointer	 data);
+#endif
+
+G_END_DECLS
+
+#endif /* __EGG_ARRAY_FLOAT_H */
diff -urN ../g1/gnome-power-manager-2.24.4/src/egg-debug.h gnome-power-manager-2.24.4/src/egg-debug.h
--- ../g1/gnome-power-manager-2.24.4/src/egg-debug.h	2008-10-06 07:22:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/egg-debug.h	2020-04-05 16:08:10.000000000 +0000
@@ -27,7 +27,7 @@
 
 G_BEGIN_DECLS
 
-#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199409L
 /**
  * egg_debug:
  *
@@ -66,15 +66,15 @@
 void		egg_debug_real			(const gchar	*func,
 						 const gchar	*file,
 						 int		 line,
-						 const gchar	*format, ...) __attribute__((format (printf,4,5)));
+						 const gchar	*format, ...);
 void		egg_warning_real		(const gchar	*func,
 						 const gchar	*file,
 						 int		 line,
-						 const gchar	*format, ...) __attribute__((format (printf,4,5)));
+						 const gchar	*format, ...);
 void		egg_error_real			(const gchar	*func,
 						 const gchar	*file,
 						 int		 line,
-						 const gchar	*format, ...) __attribute__((format (printf,4,5)));
+						 const gchar	*format, ...);
 
 G_END_DECLS
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/egg-precision.c gnome-power-manager-2.24.4/src/egg-precision.c
--- ../g1/gnome-power-manager-2.24.4/src/egg-precision.c	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/egg-precision.c	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,193 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007-2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <glib.h>
+
+#include "egg-debug.h"
+#include "egg-precision.h"
+
+/**
+ * egg_precision_round_up:
+ * @value: The input value
+ * @smallest: The smallest increment allowed
+ *
+ * 101, 10	110
+ * 95,  10	100
+ * 0,   10	0
+ * 112, 10	120
+ * 100, 10	100
+ **/
+gint
+egg_precision_round_up (gfloat value, gint smallest)
+{
+	gfloat division;
+	if (fabs (value) < 0.01)
+		return 0;
+	if (smallest == 0) {
+		egg_warning ("divisor zero");
+		return 0;
+	}
+	division = (gfloat) value / (gfloat) smallest;
+	division = ceilf (division);
+	division *= smallest;
+	return (gint) division;
+}
+
+/**
+ * egg_precision_round_down:
+ * @value: The input value
+ * @smallest: The smallest increment allowed
+ *
+ * 101, 10	100
+ * 95,  10	90
+ * 0,   10	0
+ * 112, 10	110
+ * 100, 10	100
+ **/
+gint
+egg_precision_round_down (gfloat value, gint smallest)
+{
+	gfloat division;
+	if (fabs (value) < 0.01)
+		return 0;
+	if (smallest == 0) {
+		egg_warning ("divisor zero");
+		return 0;
+	}
+	division = (gfloat) value / (gfloat) smallest;
+	division = floorf (division);
+	division *= smallest;
+	return (gint) division;
+}
+
+/***************************************************************************
+ ***                          MAKE CHECK TESTS                           ***
+ ***************************************************************************/
+#ifdef EGG_TEST
+#include "egg-test.h"
+
+void
+egg_precision_test (gpointer data)
+{
+	guint value;
+	EggTest *test = (EggTest *) data;
+
+	if (!egg_test_start (test, "EggPrecision"))
+		return;
+
+	/************************************************************/
+	egg_test_title (test, "limit precision down 0,10");
+	value = egg_precision_round_down (0, 10);
+	if (value == 0) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision down 4,10");
+	value = egg_precision_round_down (4, 10);
+	if (value == 0) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision down 11,10");
+	value = egg_precision_round_down (11, 10);
+	if (value == 10) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision down 201,2");
+	value = egg_precision_round_down (201, 2);
+	if (value == 200) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision down 100,10");
+	value = egg_precision_round_down (100, 10);
+	if (value == 100) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision up 0,10");
+	value = egg_precision_round_up (0, 10);
+	if (value == 0) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision up 4,10");
+	value = egg_precision_round_up (4, 10);
+	if (value == 10) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision up 11,10");
+	value = egg_precision_round_up (11, 10);
+	if (value == 20) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision up 201,2");
+	value = egg_precision_round_up (201, 2);
+	if (value == 202) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	/************************************************************/
+	egg_test_title (test, "limit precision up 100,10");
+	value = egg_precision_round_up (100, 10);
+	if (value == 100) {
+		egg_test_success (test, "got %i", value);
+	} else {
+		egg_test_failed (test, "precision incorrect (%i)", value);
+	}
+
+	egg_test_end (test);
+}
+
+#endif
+
diff -urN ../g1/gnome-power-manager-2.24.4/src/egg-precision.h gnome-power-manager-2.24.4/src/egg-precision.h
--- ../g1/gnome-power-manager-2.24.4/src/egg-precision.h	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/egg-precision.h	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,39 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007-2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __EGG_PRECISION_H
+#define __EGG_PRECISION_H
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+gint		 egg_precision_round_up			(gfloat		 value,
+							 gint		 smallest);
+gint		 egg_precision_round_down		(gfloat		 value,
+							 gint		 smallest);
+#ifdef EGG_TEST
+void		 egg_precision_test			(gpointer	 data);
+#endif
+
+G_END_DECLS
+
+#endif /* __EGG_PRECISION_H */
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-array-float.c gnome-power-manager-2.24.4/src/gpm-array-float.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-array-float.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-array-float.c	2020-04-05 16:08:10.000000000 +0000
@@ -75,7 +75,7 @@
  *
  * @array: input array
  **/
-inline gfloat
+gfloat
 gpm_array_float_get (GArray *array, guint i)
 {
 	if (i >= array->len) {
@@ -89,7 +89,7 @@
  *
  * @array: input array
  **/
-inline void
+void
 gpm_array_float_set (GArray *array, guint i, gfloat value)
 {
 	g_array_index (array, gfloat, i) = value;
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-array-float.h gnome-power-manager-2.24.4/src/gpm-array-float.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-array-float.h	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-array-float.h	2020-04-05 16:08:10.000000000 +0000
@@ -49,9 +49,9 @@
 gboolean	 gpm_array_float_print			(GArray		*array);
 GArray		*gpm_array_float_convolve		(GArray		*data,
 							 GArray		*kernel);
-inline gfloat	 gpm_array_float_get			(GArray		*array,
+gfloat		 gpm_array_float_get			(GArray		*array,
 							 guint		 i);
-inline void	 gpm_array_float_set			(GArray		*array,
+void		 gpm_array_float_set			(GArray		*array,
 							 guint		 i,
 							 gfloat		 value);
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-brightness-xrandr.c gnome-power-manager-2.24.4/src/gpm-brightness-xrandr.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-brightness-xrandr.c	2009-02-12 03:52:35.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-brightness-xrandr.c	2020-04-05 16:08:10.000000000 +0000
@@ -147,7 +147,7 @@
 	g_return_val_if_fail (GPM_IS_BRIGHTNESS_XRANDR (brightness), FALSE);
 
 	/* get the display */
-	brightness->priv->dpy = GDK_DISPLAY();
+	brightness->priv->dpy = GDK_DISPLAY_XDISPLAY (gdk_display_get_default());
 	if (!brightness->priv->dpy) {
 		egg_error ("Cannot open display");
 		return FALSE;
@@ -698,7 +698,7 @@
 	display = gdk_display_get_default ();
 
 	/* as we a filtering by a window, we have to add an event type */
-	if (!XRRQueryExtension (GDK_DISPLAY(), &event_base, &ignore)) {
+	if (!XRRQueryExtension (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), &event_base, &ignore)) {
 		egg_error ("can't get event_base for XRR");
 	}
 	gdk_x11_register_standard_event_type (display, event_base, RRNotify + 1);
@@ -706,7 +706,7 @@
 
 	/* don't abort on error */
 	gdk_error_trap_push ();
-	XRRSelectInput (GDK_DISPLAY(), GDK_WINDOW_XID (window),
+	XRRSelectInput (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), GDK_WINDOW_XID (window),
 			RRScreenChangeNotifyMask |
 			RROutputPropertyNotifyMask); /* <--- the only one we need, but see rh:345551 */
 	gdk_flush ();
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-button.c gnome-power-manager-2.24.4/src/gpm-button.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-button.c	2008-12-02 07:24:01.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-button.c	2020-04-05 16:08:10.000000000 +0000
@@ -151,10 +151,10 @@
 	gint ret;
 
 	/* get the current X Display */
-	display = GDK_DISPLAY ();
+	display = gdk_x11_get_default_xdisplay();
 
 	/* don't abort on error */
-	gdk_error_trap_push ();
+	//gdk_error_trap_push ();
 
 	/* grab the key if possible */
 	ret = XGrabKey (display, keycode, modmask,
@@ -205,7 +205,7 @@
 	guint keycode;
 
 	/* convert from keysym to keycode */
-	keycode = XKeysymToKeycode (GDK_DISPLAY (), keysym);
+	keycode = XKeysymToKeycode (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), keysym);
 	if (keycode == 0) {
 		egg_warning ("could not map keysym %x to keycode", keysym);
 		return FALSE;
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-cell-unit.c gnome-power-manager-2.24.4/src/gpm-cell-unit.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-cell-unit.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-cell-unit.c	2020-04-05 16:08:10.000000000 +0000
@@ -166,6 +166,12 @@
 	/* get correct icon prefix */
 	prefix = gpm_cell_unit_get_kind_string (unit);
 
+	/*
+	 * MATE icons contain battery names
+	 */
+	if (strcmp (prefix, "primary") == 0)
+		prefix = "battery";
+
 	/* get the icon from some simple rules */
 	if (unit->kind == GPM_CELL_UNIT_KIND_PRIMARY ||
 	    unit->kind == GPM_CELL_UNIT_KIND_UPS) {
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-common.c gnome-power-manager-2.24.4/src/gpm-common.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-common.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-common.c	2020-04-05 16:08:10.000000000 +0000
@@ -316,7 +316,7 @@
 	}
 
 	gscreen = gdk_screen_get_default();
-	gdk_spawn_command_line_on_screen (gscreen, command, &error);
+	g_spawn_command_line_async (command, &error);
 	if (error != NULL) {
 		GtkWidget *d;
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-conf.h gnome-power-manager-2.24.4/src/gpm-conf.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-conf.h	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-conf.h	2020-04-05 16:08:10.000000000 +0000
@@ -72,6 +72,13 @@
 #define GPM_CONF_BUTTON_HIBERNATE		GPM_CONF_DIR "/buttons/hibernate"
 #define GPM_CONF_BUTTON_POWER			GPM_CONF_DIR "/buttons/power"
 
+/* cpufreq */
+#define GPM_CONF_CPUFREQ_POLICY_AC		GPM_CONF_DIR "/cpufreq/policy_ac"
+#define GPM_CONF_CPUFREQ_POLICY_BATT		GPM_CONF_DIR "/cpufreq/policy_battery"
+#define GPM_CONF_CPUFREQ_PERFORMANCE_AC		GPM_CONF_DIR "/cpufreq/performance_ac"
+#define GPM_CONF_CPUFREQ_PERFORMANCE_BATT	GPM_CONF_DIR "/cpufreq/performance_battery"
+#define GPM_CONF_CPUFREQ_USE_NICE		GPM_CONF_DIR "/cpufreq/consider_nice"
+
 /* general */
 #define GPM_CONF_DEBUG				GPM_CONF_DIR "/general/debug"
 #define GPM_CONF_SCHEMA_VERSION			GPM_CONF_DIR "/general/installed_schema"
@@ -140,6 +147,7 @@
 #define GPM_CONF_UI_SHOW_ACTIONS_IN_MENU	GPM_CONF_DIR "/ui/show_actions_in_menu"
 #define GPM_CONF_UI_ENABLE_BEEPING		GPM_CONF_DIR "/ui/enable_sound"
 #define GPM_CONF_UI_SHOW_CONTEXT_MENU		GPM_CONF_DIR "/ui/show_context_menu"
+#define GPM_CONF_UI_ENABLE_SCREEN_LOCK		GPM_CONF_DIR "/ui/enable_screen_lock"
 
 /* we use the gnome-session key now */
 #define GPM_CONF_SESSION_REQUEST_SAVE		"/apps/gnome-session/options/auto_save_session"
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-control.c gnome-power-manager-2.24.4/src/gpm-control.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-control.c	2008-10-06 07:22:07.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-control.c	2020-04-05 16:08:10.000000000 +0000
@@ -27,7 +27,6 @@
 #include <stdio.h>
 #include <time.h>
 #include <errno.h>
-#include <libgnomeui/gnome-client.h>
 
 #include <string.h>
 #include <sys/time.h>
@@ -40,10 +39,13 @@
 #include <glib/gi18n.h>
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
+#ifdef WITH_KEYRING
 #include <gnome-keyring.h>
+#endif
 
 #include <libhal-gpower.h>
 
+#undef HAVE_POLKIT
 #ifdef HAVE_POLKIT
 #include <polkit/polkit.h>
 #include <polkit-dbus/polkit-dbus.h>
@@ -299,7 +301,6 @@
 {
 	gboolean allowed;
 	gboolean ret;
-	gboolean save_session;
 
 	gpm_control_allowed_shutdown (control, &allowed, error);
 	if (allowed == FALSE) {
@@ -311,15 +312,6 @@
 		return FALSE;
 	}
 
-	gpm_conf_get_bool (control->priv->conf, GPM_CONF_SESSION_REQUEST_SAVE, &save_session);
-	/* We can set g-p-m to not save the session to avoid confusing new
-	   users. By default we save the session to preserve data. */
-	if (save_session) {
-		gnome_client_request_save (gnome_master_client (),
-					   GNOME_SAVE_GLOBAL,
-					   FALSE, GNOME_INTERACT_NONE, FALSE,  TRUE);
-	}
-
 	ret = hal_gpower_shutdown (control->priv->hal_power, error);
 	if (!ret) {
 		gpm_control_convert_hal_error (control, error);
@@ -339,7 +331,6 @@
 		    GError    **error)
 {
 	gboolean allowed;
-	gboolean save_session;
 
 	gpm_control_allowed_reboot (control, &allowed, error);
 	if (allowed == FALSE) {
@@ -351,15 +342,6 @@
 		return FALSE;
 	}
 
-	gpm_conf_get_bool (control->priv->conf, GPM_CONF_SESSION_REQUEST_SAVE, &save_session);
-	/* We can set g-p-m to not save the session to avoid confusing new
-	   users. By default we save the session to preserve data. */
-	if (save_session) {
-		gnome_client_request_save (gnome_master_client (),
-					   GNOME_SAVE_GLOBAL,
-					   FALSE, GNOME_INTERACT_NONE, FALSE,  TRUE);
-	}
-
 	return hal_gpower_reboot (control->priv->hal_power, error);
 }
 
@@ -402,8 +384,10 @@
 	gboolean ret;
 	gboolean do_lock;
 	gboolean nm_sleep;
+#ifdef WITH_KEYRING
 	gboolean lock_gnome_keyring;
 	GnomeKeyringResult keyres;
+#endif
 	GpmScreensaver *screensaver;
 
 	screensaver = gpm_screensaver_new ();
@@ -419,6 +403,7 @@
 		return FALSE;
 	}
 
+#ifdef WITH_KEYRING
 	/* we should perhaps lock keyrings when sleeping #375681 */
 	gpm_conf_get_bool (control->priv->conf, GPM_CONF_LOCK_GNOME_KEYRING_SUSPEND, &lock_gnome_keyring);
 	if (lock_gnome_keyring) {
@@ -427,6 +412,7 @@
 			egg_warning ("could not lock keyring");
 		}
 	}
+#endif
 
 	do_lock = gpm_control_get_lock_policy (control, GPM_CONF_LOCK_ON_SUSPEND);
 	if (do_lock) {
@@ -477,8 +463,10 @@
 	gboolean ret;
 	gboolean do_lock;
 	gboolean nm_sleep;
+#ifdef WITH_KEYRING
 	gboolean lock_gnome_keyring;
 	GnomeKeyringResult keyres;
+#endif
 	GpmScreensaver *screensaver;
 
 	screensaver = gpm_screensaver_new ();
@@ -495,6 +483,7 @@
 		return FALSE;
 	}
 
+#ifdef WITH_KEYRING
 	/* we should perhaps lock keyrings when sleeping #375681 */
 	gpm_conf_get_bool (control->priv->conf, GPM_CONF_LOCK_GNOME_KEYRING_HIBERNATE, &lock_gnome_keyring);
 	if (lock_gnome_keyring) {
@@ -503,6 +492,7 @@
 			egg_warning ("could not lock keyring");
 		}
 	}
+#endif
 
 	do_lock = gpm_control_get_lock_policy (control, GPM_CONF_LOCK_ON_HIBERNATE);
 	if (do_lock) {
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-control.h gnome-power-manager-2.24.4/src/gpm-control.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-control.h	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-control.h	2020-04-05 16:08:10.000000000 +0000
@@ -74,6 +74,8 @@
 GQuark		 gpm_control_error_quark		(void);
 GType		 gpm_control_get_type			(void);
 GpmControl	*gpm_control_new			(void);
+gboolean	 gpm_control_is_user_privileged 	(GpmControl 	*control,
+							 const gchar 	*privilege);
 gboolean	 gpm_control_allowed_suspend		(GpmControl	*control,
 							 gboolean	*can,
 							 GError		**error);
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-cpufreq.c gnome-power-manager-2.24.4/src/gpm-cpufreq.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-cpufreq.c	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-cpufreq.c	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,252 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2007 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <string.h>
+#include <glib.h>
+#include <dbus/dbus-glib.h>
+#include <glib/gi18n.h>
+
+#include <libhal-gcpufreq.h>
+
+#include "gpm-ac-adapter.h"
+#include "gpm-conf.h"
+#include "egg-debug.h"
+#include "gpm-cpufreq.h"
+
+static void     gpm_cpufreq_class_init (GpmCpufreqClass *klass);
+static void     gpm_cpufreq_init       (GpmCpufreq      *hal);
+static void     gpm_cpufreq_finalize   (GObject	*object);
+
+#define GPM_CPUFREQ_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPM_TYPE_CPUFREQ, GpmCpufreqPrivate))
+
+struct GpmCpufreqPrivate
+{
+	HalGCpufreq		*hal_cpufreq;
+	GpmConf			*conf;
+	GpmAcAdapter		*ac_adapter;
+};
+
+G_DEFINE_TYPE (GpmCpufreq, gpm_cpufreq, G_TYPE_OBJECT)
+
+#if defined(sun) && defined(__SVR4)
+/**
+ * gpm_cpufreq_sync_policy_from_system_to_gconf:
+ * @cpufreq: This class instance
+ *
+ * Changes the cpufreq policy if AC gconf isn't identical to current system setting.
+ * Note: Because Solaris considers server user apart from laptop user, AC gconf key
+ *       isn't per user preference any more. In other words, AC gconf key always 
+ *       identical to current kernel/system configuration. Therefore, we need to 
+ *       read setting from kernel/system and store in AC gconf key. 
+ **/
+static gboolean
+gpm_cpufreq_sync_policy_from_system_to_gconf (GpmCpufreq *cpufreq)
+{
+	gboolean on_ac;
+	guint cpufreq_performance;
+	gchar *cpufreq_policy;
+	HalGCpufreqType cpufreq_type;
+
+	on_ac = gpm_ac_adapter_is_present (cpufreq->priv->ac_adapter);
+	if (on_ac == TRUE) {
+		/* Store current system governor and performance setting into AC gconf key.
+		 * Solaris CPUfreq don't support nice, do nothing for that. 
+                 */
+		hal_gcpufreq_get_governor (cpufreq->priv->hal_cpufreq, &cpufreq_type);
+		cpufreq_policy = hal_gcpufreq_enum_to_string (cpufreq_type);
+		gpm_conf_set_string (cpufreq->priv->conf, GPM_CONF_CPUFREQ_POLICY_AC, cpufreq_policy);
+		if (hal_gcpufreq_get_performance (cpufreq->priv->hal_cpufreq, &cpufreq_performance)) {
+			gpm_conf_set_uint (cpufreq->priv->conf, GPM_CONF_CPUFREQ_PERFORMANCE_AC, cpufreq_performance);
+		}
+	}
+
+	return TRUE;
+}
+#endif
+
+/**
+ * gpm_cpufreq_sync_policy:
+ * @cpufreq: This class instance
+ * @on_ac: If we are on AC power
+ *
+ * Changes the cpufreq policy if required
+ **/
+static gboolean
+gpm_cpufreq_sync_policy (GpmCpufreq *cpufreq)
+{
+	gboolean cpufreq_consider_nice;
+	gboolean on_ac;
+	guint cpufreq_performance;
+	gchar *cpufreq_policy;
+	HalGCpufreqType cpufreq_type;
+
+	on_ac = gpm_ac_adapter_is_present (cpufreq->priv->ac_adapter);
+
+	if (on_ac == TRUE) {
+		gpm_conf_get_bool (cpufreq->priv->conf, GPM_CONF_CPUFREQ_USE_NICE, &cpufreq_consider_nice);
+		gpm_conf_get_string (cpufreq->priv->conf, GPM_CONF_CPUFREQ_POLICY_AC, &cpufreq_policy);
+		gpm_conf_get_uint (cpufreq->priv->conf, GPM_CONF_CPUFREQ_PERFORMANCE_AC, &cpufreq_performance);
+	} else {
+		gpm_conf_get_bool (cpufreq->priv->conf, GPM_CONF_CPUFREQ_USE_NICE, &cpufreq_consider_nice);
+		gpm_conf_get_string (cpufreq->priv->conf, GPM_CONF_CPUFREQ_POLICY_BATT, &cpufreq_policy);
+		gpm_conf_get_uint (cpufreq->priv->conf, GPM_CONF_CPUFREQ_PERFORMANCE_BATT, &cpufreq_performance);
+	}
+
+	/* use enumerated value */
+	cpufreq_type = hal_gcpufreq_string_to_enum (cpufreq_policy);
+	g_free (cpufreq_policy);
+
+	/* change to the right governer and settings */
+	hal_gcpufreq_set_governor (cpufreq->priv->hal_cpufreq, cpufreq_type);
+#if 0
+	hal_gcpufreq_set_consider_nice (cpufreq->priv->hal_cpufreq, cpufreq_consider_nice);
+#endif
+	// Fix for bugster #6727770. hal_gcpufreq_set_performance (cpufreq->priv->hal_cpufreq, cpufreq_performance);
+	return TRUE;
+}
+
+/**
+ * conf_key_changed_cb:
+ *
+ * We might have to do things when the gconf keys change; do them here.
+ **/
+static void
+conf_key_changed_cb (GpmConf     *conf,
+		     const gchar *key,
+		     GpmCpufreq  *cpufreq)
+{
+	/* if any change, just resync the whole lot */
+	if (strcmp (key, GPM_CONF_CPUFREQ_POLICY_AC) == 0 ||
+	    strcmp (key, GPM_CONF_CPUFREQ_PERFORMANCE_AC) == 0 ||
+	    strcmp (key, GPM_CONF_CPUFREQ_POLICY_BATT) == 0 ||
+	    strcmp (key, GPM_CONF_CPUFREQ_PERFORMANCE_BATT) == 0 ||
+	    strcmp (key, GPM_CONF_CPUFREQ_USE_NICE) == 0) {
+
+		gpm_cpufreq_sync_policy (cpufreq);
+	}
+}
+
+/**
+ * ac_adapter_changed_cb:
+ * @ac_adapter: The ac_adapter class instance
+ * @on_ac: if we are on AC power
+ * @cpufreq: This class instance
+ *
+ * Does the actions when the ac power source is inserted/removed.
+ **/
+static void
+ac_adapter_changed_cb (GpmAcAdapter *ac_adapter,
+		       gboolean      on_ac,
+		       GpmCpufreq  *cpufreq)
+{
+	gpm_cpufreq_sync_policy (cpufreq);
+}
+
+/**
+ * gpm_cpufreq_class_init:
+ * @klass: This class instance
+ **/
+static void
+gpm_cpufreq_class_init (GpmCpufreqClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	object_class->finalize = gpm_cpufreq_finalize;
+	g_type_class_add_private (klass, sizeof (GpmCpufreqPrivate));
+}
+
+/**
+ * gpm_cpufreq_init:
+ *
+ * @cpufreq: This class instance
+ **/
+static void
+gpm_cpufreq_init (GpmCpufreq *cpufreq)
+{
+	cpufreq->priv = GPM_CPUFREQ_GET_PRIVATE (cpufreq);
+
+	/* we use cpufreq as the master class */
+	cpufreq->priv->hal_cpufreq = hal_gcpufreq_new ();
+
+	/* get changes from gconf */
+	cpufreq->priv->conf = gpm_conf_new ();
+	g_signal_connect (cpufreq->priv->conf, "value-changed",
+			  G_CALLBACK (conf_key_changed_cb), cpufreq);
+
+	/* we use ac_adapter for the ac-adapter-changed signal */
+	cpufreq->priv->ac_adapter = gpm_ac_adapter_new ();
+	g_signal_connect (cpufreq->priv->ac_adapter, "ac-adapter-changed",
+			  G_CALLBACK (ac_adapter_changed_cb), cpufreq);
+
+	/* sync policy */
+#if defined(sun) && defined(__SVR4)
+	gpm_cpufreq_sync_policy_from_system_to_gconf (cpufreq);
+#else
+	gpm_cpufreq_sync_policy (cpufreq);
+#endif
+}
+
+/**
+ * gpm_cpufreq_finalize:
+ * @object: This class instance
+ **/
+static void
+gpm_cpufreq_finalize (GObject *object)
+{
+	GpmCpufreq *cpufreq;
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GPM_IS_CPUFREQ (object));
+
+	cpufreq = GPM_CPUFREQ (object);
+	cpufreq->priv = GPM_CPUFREQ_GET_PRIVATE (cpufreq);
+
+	if (cpufreq->priv->hal_cpufreq != NULL) {
+		g_object_unref (cpufreq->priv->hal_cpufreq);
+	}
+	if (cpufreq->priv->conf != NULL) {
+		g_object_unref (cpufreq->priv->conf);
+	}
+	if (cpufreq->priv->ac_adapter != NULL) {
+		g_object_unref (cpufreq->priv->ac_adapter);
+	}
+	G_OBJECT_CLASS (gpm_cpufreq_parent_class)->finalize (object);
+}
+
+/**
+ * gpm_cpufreq_new:
+ * Return value: new GpmCpufreq instance.
+ **/
+GpmCpufreq *
+gpm_cpufreq_new (void)
+{
+	GpmCpufreq *cpufreq = NULL;
+
+	/* only load if we have the hardware */
+	if (hal_gcpufreq_has_hw() == TRUE) {
+		cpufreq = g_object_new (GPM_TYPE_CPUFREQ, NULL);
+	}
+
+	return cpufreq;
+}
+
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-cpufreq.h gnome-power-manager-2.24.4/src/gpm-cpufreq.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-cpufreq.h	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-cpufreq.h	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2007 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GPMCPUFREQ_H
+#define __GPMCPUFREQ_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GPM_TYPE_CPUFREQ		(gpm_cpufreq_get_type ())
+#define GPM_CPUFREQ(o)			(G_TYPE_CHECK_INSTANCE_CAST ((o), GPM_TYPE_CPUFREQ, GpmCpufreq))
+#define GPM_CPUFREQ_CLASS(k)		(G_TYPE_CHECK_CLASS_CAST((k), GPM_TYPE_CPUFREQ, GpmCpufreqClass))
+#define GPM_IS_CPUFREQ(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), GPM_TYPE_CPUFREQ))
+#define GPM_IS_CPUFREQ_CLASS(k)		(G_TYPE_CHECK_CLASS_TYPE ((k), GPM_TYPE_CPUFREQ))
+#define GPM_CPUFREQ_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GPM_TYPE_CPUFREQ, GpmCpufreqClass))
+
+typedef struct GpmCpufreqPrivate GpmCpufreqPrivate;
+
+typedef struct
+{
+	GObject			 parent;
+	GpmCpufreqPrivate	*priv;
+} GpmCpufreq;
+
+typedef struct
+{
+	GObjectClass	parent_class;
+} GpmCpufreqClass;
+
+GType		 gpm_cpufreq_get_type				(void);
+GpmCpufreq	*gpm_cpufreq_new				(void);
+
+G_END_DECLS
+
+#endif	/* __GPMCPUFREQ_H */
+
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-dpms.c gnome-power-manager-2.24.4/src/gpm-dpms.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-dpms.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-dpms.c	2020-04-05 16:08:10.000000000 +0000
@@ -39,7 +39,6 @@
 #ifdef HAVE_DPMS_EXTENSION
 #include <X11/Xproto.h>
 #include <X11/extensions/dpms.h>
-#include <X11/extensions/dpmsstr.h>
 #endif
 
 #include "gpm-conf.h"
@@ -211,7 +210,7 @@
 		/* Server or monitor can't DPMS -- assume the monitor is on. */
 		result = GPM_DPMS_MODE_ON;
 	} else {
-		DPMSInfo (GDK_DISPLAY (), &state, &enabled);
+		DPMSInfo (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), &state, &enabled);
 		if (! enabled) {
 			/* Server says DPMS is disabled -- so the monitor is on. */
 			result = GPM_DPMS_MODE_ON;
@@ -262,7 +261,7 @@
 		return FALSE;
 	}
 
-	if (! DPMSInfo (GDK_DISPLAY (), &current_state, &current_enabled)) {
+	if (! DPMSInfo (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), &current_state, &current_enabled)) {
 		egg_debug ("couldn't get DPMS info");
 		g_set_error (error,
 			     GPM_DPMS_ERROR,
@@ -301,7 +300,7 @@
 	x11_get_mode (dpms, &current_mode, NULL);
 
 	if (current_mode != mode) {
-		if (! DPMSForceLevel (GDK_DISPLAY (), state)) {
+		if (! DPMSForceLevel (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), state)) {
 			g_set_error (error,
 				     GPM_DPMS_ERROR,
 				     GPM_DPMS_ERROR_GENERAL,
@@ -309,7 +308,7 @@
 			return FALSE;
 		}
 
-		XSync (GDK_DISPLAY (), FALSE);
+		XSync (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()), FALSE);
 	}
 
 	return TRUE;
@@ -372,7 +371,7 @@
 	   use zero values for the timeouts when the
 	   we aren't active in order to prevent it
 	   from activating.  */
-	return x11_sync_server_dpms_settings (GDK_DISPLAY (),
+	return x11_sync_server_dpms_settings (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()),
 					      dpms->priv->enabled,
 					      standby,
 					      suspend,
@@ -787,7 +786,7 @@
 	dpms->priv = GPM_DPMS_GET_PRIVATE (dpms);
 
 	/* DPMSCapable() can never change for a given display */
-	dpms->priv->dpms_capable = DPMSCapable (GDK_DISPLAY ());
+	dpms->priv->dpms_capable = DPMSCapable (GDK_DISPLAY_XDISPLAY (gdk_display_get_default()));
 
 	add_poll_timer (dpms, GPM_DPMS_POLL_TIME);
 }
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-feedback-widget.c gnome-power-manager-2.24.4/src/gpm-feedback-widget.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-feedback-widget.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-feedback-widget.c	2020-04-05 16:08:10.000000000 +0000
@@ -23,30 +23,26 @@
 
 #include <glib.h>
 
-#include <glade/glade.h>
 #include <gtk/gtk.h>
 #include <gdk/gdkx.h>
 
 #include "gpm-feedback-widget.h"
 #include "gpm-stock-icons.h"
-#include "gpm-refcount.h"
 #include "egg-debug.h"
 
-static void     gpm_feedback_class_init (GpmFeedbackClass *klass);
-static void     gpm_feedback_init       (GpmFeedback      *feedback);
 static void     gpm_feedback_finalize   (GObject	  *object);
 static void	gpm_feedback_show	(GtkWidget 	  *widget);
 
 #define GPM_FEEDBACK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPM_TYPE_FEEDBACK, GpmFeedbackPrivate))
 
-#define GPM_FEEDBACK_TIMOUT		2000	/* ms */
+#define GPM_FEEDBACK_TIMOUT		2	/* s */
 
 struct GpmFeedbackPrivate
 {
-	GladeXML		*xml;
+	GtkBuilder		*builder;
 	GtkWidget		*main_window;
 	GtkWidget		*progress;
-	GpmRefcount		*refcount;
+	guint			 timer_id;
 	gchar			*icon_name;
 };
 
@@ -121,16 +117,18 @@
 
 /**
  * gpm_feedback_close_window:
- * @data: gpointer to this class instance
  **/
 static void
-gpm_feedback_close_window (GpmRefcount *refcount,
-			   GpmFeedback *feedback)
+gpm_feedback_close_window (GpmFeedback *feedback)
 {
+	g_return_if_fail (GPM_IS_FEEDBACK (feedback));
 	egg_debug ("Closing feedback widget");
 	gtk_widget_hide (feedback->priv->main_window);
 }
 
+/**
+ * gpm_feedback_display_value:
+ **/
 gboolean
 gpm_feedback_display_value (GpmFeedback *feedback, gfloat value)
 {
@@ -141,33 +139,34 @@
 	gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (feedback->priv->progress), value);
 	gpm_feedback_show (feedback->priv->main_window);
 
-	/* set up the window auto-close */
-	gpm_refcount_add (feedback->priv->refcount);
+	if (feedback->priv->timer_id != 0)
+		g_source_remove (feedback->priv->timer_id);
+	feedback->priv->timer_id = g_timeout_add_seconds (GPM_FEEDBACK_TIMOUT, (GSourceFunc) gpm_feedback_close_window, feedback);
 
 	return TRUE;
 }
 
+/**
+ * gpm_feedback_set_icon_name:
+ **/
 gboolean
 gpm_feedback_set_icon_name (GpmFeedback *feedback, const gchar *icon_name)
 {
-	GtkWidget *image;
+	GtkImage *image;
 
 	g_return_val_if_fail (feedback != NULL, FALSE);
 	g_return_val_if_fail (GPM_IS_FEEDBACK (feedback), FALSE);
 	g_return_val_if_fail (icon_name != NULL, FALSE);
 
 	/* if name already set then free */
-	if (feedback->priv->icon_name != NULL) {
+	if (feedback->priv->icon_name != NULL)
 		g_free (feedback->priv->icon_name);
-	}
 
 	egg_debug ("Using icon name '%s'", icon_name);
 	feedback->priv->icon_name = g_strdup (icon_name);
 
-	image = glade_xml_get_widget (feedback->priv->xml, "image");
-	gtk_image_set_from_icon_name  (GTK_IMAGE (image),
-				       feedback->priv->icon_name,
-				       GTK_ICON_SIZE_DIALOG);
+	image = GTK_IMAGE (gtk_builder_get_object (feedback->priv->builder, "image"));
+	gtk_image_set_from_icon_name  (image, feedback->priv->icon_name, GTK_ICON_SIZE_DIALOG);
 
 	return TRUE;
 }
@@ -179,22 +178,24 @@
 static void
 gpm_feedback_init (GpmFeedback *feedback)
 {
+	guint retval;
+	GError *error = NULL;
+
 	feedback->priv = GPM_FEEDBACK_GET_PRIVATE (feedback);
-	feedback->priv->refcount = 0;
+	feedback->priv->timer_id = 0;
 	feedback->priv->icon_name = NULL;
 
-	feedback->priv->refcount = gpm_refcount_new ();
-	g_signal_connect (feedback->priv->refcount, "refcount-zero",
-			  G_CALLBACK (gpm_feedback_close_window), feedback);
-	gpm_refcount_set_timeout (feedback->priv->refcount, GPM_FEEDBACK_TIMOUT);
+	/* get UI */
+	feedback->priv->builder = gtk_builder_new ();
+	retval = gtk_builder_add_from_file (feedback->priv->builder, GPM_DATA "/gpm-feedback-widget.ui", &error);
+	if (error != NULL) {
+		egg_warning ("failed to load ui: %s", error->message);
+		g_error_free (error);
+	}
 
 	/* initialise the window */
-	feedback->priv->xml = glade_xml_new (GPM_DATA "/gpm-feedback-widget.glade", NULL, NULL);
-	if (feedback->priv->xml == NULL)
-		egg_error ("Can't find gpm-feedback-widget.glade");
-	feedback->priv->main_window = glade_xml_get_widget (feedback->priv->xml, "main_window");
-
-	feedback->priv->progress = glade_xml_get_widget (feedback->priv->xml, "progressbar");
+	feedback->priv->main_window = GTK_WIDGET (gtk_builder_get_object (feedback->priv->builder, "main_window"));
+	feedback->priv->progress = GTK_WIDGET (gtk_builder_get_object (feedback->priv->builder, "progressbar"));
 	gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (feedback->priv->progress), 0.0f);
 	gtk_widget_set_sensitive (feedback->priv->progress, FALSE);
 
@@ -217,8 +218,8 @@
 	feedback->priv = GPM_FEEDBACK_GET_PRIVATE (feedback);
 
 	g_free (feedback->priv->icon_name);
-	if (feedback->priv->refcount != NULL)
-		g_object_unref (feedback->priv->refcount);
+	if (feedback->priv->timer_id != 0)
+		g_source_remove (feedback->priv->timer_id);
 
 	G_OBJECT_CLASS (gpm_feedback_parent_class)->finalize (object);
 }
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-graph-widget.c gnome-power-manager-2.24.4/src/gpm-graph-widget.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-graph-widget.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-graph-widget.c	2020-04-05 16:08:10.000000000 +0000
@@ -16,22 +16,23 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include "config.h"
 #include <gtk/gtk.h>
 #include <pango/pangocairo.h>
 #include <glib/gi18n.h>
-#include <math.h>
 #include <stdlib.h>
-#include <string.h>
+#include <math.h>
 
-#include "egg-color.h"
 #include "gpm-common.h"
+#include "gpm-point-obj.h"
 #include "gpm-graph-widget.h"
-#include "gpm-array.h"
+
 #include "egg-debug.h"
+#include "egg-color.h"
+#include "egg-precision.h"
 
 G_DEFINE_TYPE (GpmGraphWidget, gpm_graph_widget, GTK_TYPE_DRAWING_AREA);
 #define GPM_GRAPH_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPM_TYPE_GRAPH_WIDGET, GpmGraphWidgetPrivate))
@@ -41,11 +42,10 @@
 {
 	gboolean		 use_grid;
 	gboolean		 use_legend;
-	gboolean		 use_events;
 	gboolean		 autorange_x;
+	gboolean		 autorange_y;
 
 	GSList			*key_data; /* lines */
-	GSList			*key_event; /* dots */
 
 	gint			 stop_x;
 	gint			 stop_y;
@@ -59,99 +59,49 @@
 	gfloat			 unit_x; /* 10th width of graph */
 	gfloat			 unit_y; /* 10th width of graph */
 
-	GpmGraphWidgetAxisType	 axis_type_x;
-	GpmGraphWidgetAxisType	 axis_type_y;
+	GpmGraphWidgetType	 type_x;
+	GpmGraphWidgetType	 type_y;
 	gchar			*title;
 
 	cairo_t			*cr;
 	PangoLayout 		*layout;
 
 	GPtrArray		*data_list;
-	GpmArray		*events;
+	GPtrArray		*plot_list;
 };
 
-static gboolean gpm_graph_widget_expose (GtkWidget *graph, GdkEventExpose *event);
+static gboolean gpm_graph_widget_draw (GtkWidget *graph, cairo_t *cr);
 static void	gpm_graph_widget_finalize (GObject *object);
 
-/**
- * gpm_graph_widget_key_compare_func
- * Return value: 0 if cookie matches
- **/
-static gint
-gpm_graph_widget_key_compare_func (gconstpointer a, gconstpointer b)
-{
-	GpmGraphWidgetKeyItem *data;
-	guint32 id;
-	data = (GpmGraphWidgetKeyItem*) a;
-	id = *((guint*) b);
-	if (id == data->id)
-		return 0;
-	return 1;
-}
-
-/**
- * gpm_graph_widget_key_find_id:
- **/
-static GpmGraphWidgetKeyItem *
-gpm_graph_widget_key_find_id (GpmGraphWidget *graph, guint id)
-{
-	GpmGraphWidgetKeyItem *data;
-	GSList *ret;
-	ret = g_slist_find_custom (graph->priv->key_event, &id,
-				   gpm_graph_widget_key_compare_func);
-	if (ret == NULL) {
-		return NULL;
-	}
-	data = (GpmGraphWidgetKeyItem *) ret->data;
-	return data;
-}
-
-/**
- * gpm_graph_widget_key_event_add:
- **/
-gboolean
-gpm_graph_widget_key_event_add (GpmGraphWidget *graph,
-			  guint		        id,
-			  guint32               colour,
-			  GpmGraphWidgetShape   shape,
-			  const gchar	       *desc)
+enum
 {
-	GpmGraphWidgetKeyItem *keyitem;
-	g_return_val_if_fail (graph != NULL, FALSE);
-	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
-
-	keyitem = gpm_graph_widget_key_find_id (graph, id);
-	if (keyitem != NULL) {
-		egg_warning ("keyitem %i already in use", id);
-		return FALSE;
-	}
-
-	egg_debug ("add to hashtable '%s'", desc);
-	keyitem = g_new0 (GpmGraphWidgetKeyItem, 1);
-	keyitem->id = id;
-	keyitem->desc = g_strdup (desc);
-	keyitem->colour = colour;
-	keyitem->shape = shape;
-
-	graph->priv->key_event = g_slist_append (graph->priv->key_event, (gpointer) keyitem);
-	return TRUE;
-}
+	PROP_0,
+	PROP_USE_LEGEND,
+	PROP_USE_GRID,
+	PROP_TYPE_X,
+	PROP_TYPE_Y,
+	PROP_AUTORANGE_X,
+	PROP_AUTORANGE_Y,
+	PROP_START_X,
+	PROP_START_Y,
+	PROP_STOP_X,
+	PROP_STOP_Y,
+};
 
 /**
  * gpm_graph_widget_key_data_clear:
  **/
-gboolean
+static gboolean
 gpm_graph_widget_key_data_clear (GpmGraphWidget *graph)
 {
 	GpmGraphWidgetKeyData *keyitem;
-	guint a;
+	guint i;
 
-	g_return_val_if_fail (graph != NULL, FALSE);
 	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
 
 	/* remove items in list and free */
-	for (a=0; a<g_slist_length (graph->priv->key_data); a++) {
-		keyitem = (GpmGraphWidgetKeyData *) g_slist_nth_data (graph->priv->key_data, a);
+	for (i=0; i<g_slist_length (graph->priv->key_data); i++) {
+		keyitem = (GpmGraphWidgetKeyData *) g_slist_nth_data (graph->priv->key_data, i);
 		g_free (keyitem->desc);
 		g_free (keyitem);
 	}
@@ -162,131 +112,114 @@
 }
 
 /**
- * gpm_graph_widget_key_event_clear:
- **/
-gboolean
-gpm_graph_widget_key_event_clear (GpmGraphWidget *graph)
-{
-	GpmGraphWidgetKeyItem *keyitem;
-	guint a;
-
-	g_return_val_if_fail (graph != NULL, FALSE);
-	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
-
-	/* remove items in list and free */
-	for (a=0; a<g_slist_length (graph->priv->key_event); a++) {
-		keyitem = (GpmGraphWidgetKeyItem *) g_slist_nth_data (graph->priv->key_event, a);
-		g_free (keyitem->desc);
-		g_free (keyitem);
-	}
-	g_slist_free (graph->priv->key_event);
-	graph->priv->key_event = NULL;
-
-	return TRUE;
-}
-
-/**
  * gpm_graph_widget_key_data_add:
  **/
 gboolean
-gpm_graph_widget_key_data_add (GpmGraphWidget *graph, guint colour, const gchar *desc)
+gpm_graph_widget_key_data_add (GpmGraphWidget *graph, guint32 color, const gchar *desc)
 {
 	GpmGraphWidgetKeyData *keyitem;
 
-	g_return_val_if_fail (graph != NULL, FALSE);
 	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
 
 	egg_debug ("add to list %s", desc);
 	keyitem = g_new0 (GpmGraphWidgetKeyData, 1);
 
-	keyitem->colour = colour;
+	keyitem->color = color;
 	keyitem->desc = g_strdup (desc);
 
 	graph->priv->key_data = g_slist_append (graph->priv->key_data, (gpointer) keyitem);
 	return TRUE;
 }
 
-
 /**
- * gpm_graph_widget_string_to_axis_type:
- * @graph: This class instance
- * @type: The axis type, e.g. "percentage"
- *
- * Return value: The enumerated axis type
+ * up_graph_get_property:
  **/
-GpmGraphWidgetAxisType
-gpm_graph_widget_string_to_axis_type (const gchar *type)
+static void
+up_graph_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)
 {
-	GpmGraphWidgetAxisType ret;
-
-	ret = GPM_GRAPH_WIDGET_TYPE_INVALID;
-	if (strcmp (type, "percentage") == 0) {
-		ret = GPM_GRAPH_WIDGET_TYPE_PERCENTAGE;
-	} else if (strcmp (type, "time") == 0) {
-		ret = GPM_GRAPH_WIDGET_TYPE_TIME;
-	} else if (strcmp (type, "power") == 0) {
-		ret = GPM_GRAPH_WIDGET_TYPE_POWER;
-	} else if (strcmp (type, "voltage") == 0) {
-		ret = GPM_GRAPH_WIDGET_TYPE_VOLTAGE;
+	GpmGraphWidget *graph = GPM_GRAPH_WIDGET (object);
+	switch (prop_id) {
+	case PROP_USE_LEGEND:
+		g_value_set_boolean (value, graph->priv->use_legend);
+		break;
+	case PROP_USE_GRID:
+		g_value_set_boolean (value, graph->priv->use_grid);
+		break;
+	case PROP_TYPE_X:
+		g_value_set_uint (value, graph->priv->type_x);
+		break;
+	case PROP_TYPE_Y:
+		g_value_set_uint (value, graph->priv->type_y);
+		break;
+	case PROP_AUTORANGE_X:
+		g_value_set_boolean (value, graph->priv->autorange_x);
+		break;
+	case PROP_AUTORANGE_Y:
+		g_value_set_boolean (value, graph->priv->autorange_y);
+		break;
+	case PROP_START_X:
+		g_value_set_int (value, graph->priv->start_x);
+		break;
+	case PROP_START_Y:
+		g_value_set_int (value, graph->priv->start_y);
+		break;
+	case PROP_STOP_X:
+		g_value_set_int (value, graph->priv->stop_x);
+		break;
+	case PROP_STOP_Y:
+		g_value_set_int (value, graph->priv->stop_y);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
 	}
-
-	return ret;
-}
-
-/**
- * gpm_graph_widget_set_axis_type_x:
- * @graph: This class instance
- * @axis: The axis type, e.g. GPM_GRAPH_WIDGET_TYPE_TIME
- **/
-void
-gpm_graph_widget_set_axis_type_x (GpmGraphWidget *graph, GpmGraphWidgetAxisType axis)
-{
-	g_return_if_fail (graph != NULL);
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
-	graph->priv->axis_type_x = axis;
-}
-
-/**
- * gpm_graph_widget_set_axis_type_y:
- * @graph: This class instance
- * @axis: The axis type, e.g. GPM_GRAPH_WIDGET_TYPE_TIME
- **/
-void
-gpm_graph_widget_set_axis_type_y (GpmGraphWidget *graph, GpmGraphWidgetAxisType axis)
-{
-	g_return_if_fail (graph != NULL);
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
-	graph->priv->axis_type_y = axis;
 }
 
 /**
- * gpm_graph_widget_enable_legend:
- * @graph: This class instance
- * @enable: If we should show the legend
+ * up_graph_set_property:
  **/
-void
-gpm_graph_widget_enable_legend (GpmGraphWidget *graph, gboolean enable)
+static void
+up_graph_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)
 {
-	g_return_if_fail (graph != NULL);
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
-	graph->priv->use_legend = enable;
+	GpmGraphWidget *graph = GPM_GRAPH_WIDGET (object);
 
-	gtk_widget_hide (GTK_WIDGET (graph));
-	gtk_widget_show (GTK_WIDGET (graph));
-}
-
-/**
- * gpm_graph_widget_enable_events:
- * @graph: This class instance
- * @enable: If we should show the legend
- **/
-void
-gpm_graph_widget_enable_events (GpmGraphWidget *graph, gboolean enable)
-{
-	g_return_if_fail (graph != NULL);
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
-	graph->priv->use_events = enable;
+	switch (prop_id) {
+	case PROP_USE_LEGEND:
+		graph->priv->use_legend = g_value_get_boolean (value);
+		break;
+	case PROP_USE_GRID:
+		graph->priv->use_grid = g_value_get_boolean (value);
+		break;
+	case PROP_TYPE_X:
+		graph->priv->type_x = g_value_get_uint (value);
+		break;
+	case PROP_TYPE_Y:
+		graph->priv->type_y = g_value_get_uint (value);
+		break;
+	case PROP_AUTORANGE_X:
+		graph->priv->autorange_x = g_value_get_boolean (value);
+		break;
+	case PROP_AUTORANGE_Y:
+		graph->priv->autorange_y = g_value_get_boolean (value);
+		break;
+	case PROP_START_X:
+		graph->priv->start_x = g_value_get_int (value);
+		break;
+	case PROP_START_Y:
+		graph->priv->start_y = g_value_get_int (value);
+		break;
+	case PROP_STOP_X:
+		graph->priv->stop_x = g_value_get_int (value);
+		break;
+	case PROP_STOP_Y:
+		graph->priv->stop_y = g_value_get_int (value);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
 
+	/* refresh widget */
 	gtk_widget_hide (GTK_WIDGET (graph));
 	gtk_widget_show (GTK_WIDGET (graph));
 }
@@ -301,10 +234,68 @@
 	GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (class);
 	GObjectClass *object_class = G_OBJECT_CLASS (class);
 
-	widget_class->expose_event = gpm_graph_widget_expose;
+	widget_class->draw = gpm_graph_widget_draw;
+	object_class->get_property = up_graph_get_property;
+	object_class->set_property = up_graph_set_property;
 	object_class->finalize = gpm_graph_widget_finalize;
 
 	g_type_class_add_private (class, sizeof (GpmGraphWidgetPrivate));
+
+	/* properties */
+	g_object_class_install_property (object_class,
+					 PROP_USE_LEGEND,
+					 g_param_spec_boolean ("use-legend", NULL, NULL,
+							       FALSE,
+							       G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_USE_GRID,
+					 g_param_spec_boolean ("use-grid", NULL, NULL,
+							       TRUE,
+							       G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_TYPE_X,
+					 g_param_spec_uint ("type-x", NULL, NULL,
+							    GPM_GRAPH_WIDGET_TYPE_INVALID,
+							    GPM_GRAPH_WIDGET_TYPE_UNKNOWN,
+							    GPM_GRAPH_WIDGET_TYPE_TIME,
+							    G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_TYPE_Y,
+					 g_param_spec_uint ("type-y", NULL, NULL,
+							    GPM_GRAPH_WIDGET_TYPE_INVALID,
+							    GPM_GRAPH_WIDGET_TYPE_UNKNOWN,
+							    GPM_GRAPH_WIDGET_TYPE_PERCENTAGE,
+							    G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_AUTORANGE_X,
+					 g_param_spec_boolean ("autorange-x", NULL, NULL,
+							       TRUE,
+							       G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_AUTORANGE_Y,
+					 g_param_spec_boolean ("autorange-y", NULL, NULL,
+							       TRUE,
+							       G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_START_X,
+					 g_param_spec_int ("start-x", NULL, NULL,
+							   G_MININT, G_MAXINT, 0,
+							   G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_START_Y,
+					 g_param_spec_int ("start-y", NULL, NULL,
+							   G_MININT, G_MAXINT, 0,
+							   G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_STOP_X,
+					 g_param_spec_int ("stop-x", NULL, NULL,
+							   G_MININT, G_MAXINT, 60,
+							   G_PARAM_READWRITE));
+	g_object_class_install_property (object_class,
+					 PROP_STOP_Y,
+					 g_param_spec_int ("stop-y", NULL, NULL,
+							   G_MININT, G_MAXINT, 100,
+							   G_PARAM_READWRITE));
 }
 
 /**
@@ -325,18 +316,16 @@
 	graph->priv->stop_y = 100;
 	graph->priv->use_grid = TRUE;
 	graph->priv->use_legend = FALSE;
-	graph->priv->data_list = g_ptr_array_new ();
+	graph->priv->data_list = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
+	graph->priv->plot_list = g_ptr_array_new ();
 	graph->priv->key_data = NULL;
-	graph->priv->key_event = NULL;
-	graph->priv->axis_type_x = GPM_GRAPH_WIDGET_TYPE_TIME;
-	graph->priv->axis_type_y = GPM_GRAPH_WIDGET_TYPE_PERCENTAGE;
+	graph->priv->type_x = GPM_GRAPH_WIDGET_TYPE_TIME;
+	graph->priv->type_y = GPM_GRAPH_WIDGET_TYPE_PERCENTAGE;
 
 	/* do pango stuff */
 	fontmap = pango_cairo_font_map_get_default ();
-	context = pango_cairo_font_map_create_context (PANGO_CAIRO_FONT_MAP (fontmap));
-
-	/* Comment out as this requires pango 1.16 when FC6 only supports 1.14
-	pango_context_set_base_gravity (context, PANGO_GRAVITY_AUTO); */
+	context = pango_font_map_create_context (PANGO_FONT_MAP (fontmap));
+	pango_context_set_base_gravity (context, PANGO_GRAVITY_AUTO);
 
 	graph->priv->layout = pango_layout_new (context);
 	desc = pango_font_description_from_string (GPM_GRAPH_WIDGET_FONT);
@@ -345,6 +334,20 @@
 }
 
 /**
+ * gpm_graph_widget_data_clear:
+ **/
+gboolean
+gpm_graph_widget_data_clear (GpmGraphWidget *graph)
+{
+	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
+
+	g_ptr_array_set_size (graph->priv->data_list, 0);
+	g_ptr_array_set_size (graph->priv->plot_list, 0);
+
+	return TRUE;
+}
+
+/**
  * gpm_graph_widget_finalize:
  * @object: This graph class instance
  **/
@@ -354,11 +357,13 @@
 	PangoContext *context;
 	GpmGraphWidget *graph = (GpmGraphWidget*) object;
 
-	/* clear key */
+	/* clear key and data */
 	gpm_graph_widget_key_data_clear (graph);
-	gpm_graph_widget_key_event_clear (graph);
+	gpm_graph_widget_data_clear (graph);
 
-	g_ptr_array_free (graph->priv->data_list, FALSE);
+	/* free data */
+	g_ptr_array_unref (graph->priv->data_list);
+	g_ptr_array_unref (graph->priv->plot_list);
 
 	context = pango_layout_get_context (graph->priv->layout);
 	g_object_unref (graph->priv->layout);
@@ -367,96 +372,37 @@
 }
 
 /**
- * gpm_graph_widget_data_add:
+ * gpm_graph_widget_data_assign:
  * @graph: This class instance
+ * @data: an array of GpmPointObj's
  *
- * Sets the data for the graph. You MUST NOT free the list before the widget.
+ * Sets the data for the graph
  **/
 gboolean
-gpm_graph_widget_data_add (GpmGraphWidget *graph, GpmArray *array)
+gpm_graph_widget_data_assign (GpmGraphWidget *graph, GpmGraphWidgetPlot plot, GPtrArray *data)
 {
-	GpmArrayPoint *point;
-	guint length;
+	GPtrArray *copy;
+	GpmPointObj *obj;
 	guint i;
-	guint oldx;
 
-	g_return_val_if_fail (array != NULL, FALSE);
-	g_return_val_if_fail (graph != NULL, FALSE);
+	g_return_val_if_fail (data != NULL, FALSE);
 	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
-	g_return_val_if_fail (GPM_IS_ARRAY (array), FALSE);
-
-	/* check size is not zero */
-	length = gpm_array_get_size (array);
-	if (length == 0) {
-		egg_warning ("Trying to assign a zero length array");
-		return FALSE;
-	}
-
-	/* check X is only monotomically increasing */
-	oldx = 0;
-	for (i=0; i < length; i++) {
-		point = gpm_array_get (array, i);
-		if (point->x < oldx) {
-			/* going backwards! */
-			return FALSE;
-		}
-		oldx = point->x;
-	}
-
-	/* always add, never remove in this function */
-	g_ptr_array_add (graph->priv->data_list, (gpointer) array);
-	return TRUE;
-}
-
-/**
- * gpm_graph_widget_data_clear:
- * @graph: This class instance
- *
- * Sets the data for the graph. You MUST NOT free the list before the widget.
- **/
-void
-gpm_graph_widget_data_clear (GpmGraphWidget *graph)
-{
-	guint i;
-	guint length;
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
 
-	/* remove all in list */
-	length = graph->priv->data_list->len;
-	for (i=0; i < length; i++) {
-		egg_debug ("Removing dataset %i", i);
-		g_ptr_array_remove_index_fast (graph->priv->data_list, 0);
+	/* make a deep copy */
+	copy = g_ptr_array_new_with_free_func ((GDestroyNotify) gpm_point_obj_free);
+	for (i=0; i<data->len; i++) {
+		obj = gpm_point_obj_copy (g_ptr_array_index (data, i));
+		g_ptr_array_add (copy, obj);
 	}
-}
 
-/**
- * gpm_graph_widget_events_add:
- * @graph: This class instance
- * @list: The GList events to be plotted on the graph
- *
- * Sets the data for the graph. You MUST NOT free the array before the widget.
- **/
-void
-gpm_graph_widget_events_add (GpmGraphWidget *graph, GpmArray *array)
-{
-	g_return_if_fail (graph != NULL);
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
+	/* get the new data */
+	g_ptr_array_add (graph->priv->data_list, copy);
+	g_ptr_array_add (graph->priv->plot_list, GUINT_TO_POINTER(plot));
 
-	graph->priv->events = array;
-}
+	/* refresh */
+	gtk_widget_queue_draw (GTK_WIDGET (graph));
 
-/**
- * gpm_graph_widget_events_clear:
- * @graph: This class instance
- *
- * Clears the data for the graph.
- **/
-void
-gpm_graph_widget_events_clear (GpmGraphWidget *graph)
-{
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
-	/* this is managed externally, so just set to NULL */
-	graph->priv->events = NULL;
+	return TRUE;
 }
 
 /**
@@ -466,27 +412,38 @@
  *
  * Unit is:
  * GPM_GRAPH_WIDGET_TYPE_TIME:		seconds
- * GPM_GRAPH_WIDGET_TYPE_POWER: 	mWh (not mAh)
+ * GPM_GRAPH_WIDGET_TYPE_POWER: 	Wh (not Ah)
  * GPM_GRAPH_WIDGET_TYPE_PERCENTAGE:	%
  *
  * Return value: a string value depending on the axis type and the value.
  **/
 static gchar *
-gpm_get_axis_label (GpmGraphWidgetAxisType axis, gint value)
+gpm_get_axis_label (GpmGraphWidgetType axis, gfloat value)
 {
-	char *text = NULL;
+	gchar *text = NULL;
 	if (axis == GPM_GRAPH_WIDGET_TYPE_TIME) {
-		int minutes = value / 60;
-		int seconds = value - (minutes * 60);
-		int hours = minutes / 60;
-		minutes =  minutes - (hours * 60);
-		if (hours > 0) {
+		gint time_s = abs((gint) value);
+		gint minutes = time_s / 60;
+		gint seconds = time_s - (minutes * 60);
+		gint hours = minutes / 60;
+		gint days = hours / 24;
+		minutes = minutes - (hours * 60);
+		hours = hours - (days * 24);
+		if (days > 0) {
+			if (hours == 0) {
+				/*Translators: This is %i days*/
+				text = g_strdup_printf (_("%id"), days);
+			} else {
+				/*Translators: This is %i days %02i hours*/
+				text = g_strdup_printf (_("%id%02ih"), days, hours);
+			}
+		} else if (hours > 0) {
 			if (minutes == 0) {
 				/*Translators: This is %i hours*/
 				text = g_strdup_printf (_("%ih"), hours);
 			} else {
 				/*Translators: This is %i hours %02i minutes*/
-				text = g_strdup_printf (_("%ih%02i"), hours, minutes);
+				text = g_strdup_printf (_("%ih%02im"), hours, minutes);
 			}
 		} else if (minutes > 0) {
 			if (seconds == 0) {
@@ -502,15 +459,17 @@
 		}
 	} else if (axis == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
 		/*Translators: This is %i Percentage*/
-		text = g_strdup_printf (_("%i%%"), value);
+		text = g_strdup_printf (_("%i%%"), (gint) value);
 	} else if (axis == GPM_GRAPH_WIDGET_TYPE_POWER) {
 		/*Translators: This is %.1f Watts*/
-		text = g_strdup_printf (_("%.1fW"), (gfloat) value / 1000.0);
+		text = g_strdup_printf (_("%.1fW"), value);
+	} else if (axis == GPM_GRAPH_WIDGET_TYPE_FACTOR) {
+		text = g_strdup_printf ("%.1f", value);
 	} else if (axis == GPM_GRAPH_WIDGET_TYPE_VOLTAGE) {
 		/*Translators: This is %.1f Volts*/
-		text = g_strdup_printf (_("%.1fV"), (gfloat) value / 1000.0);
+		text = g_strdup_printf (_("%.1fV"), value);
 	} else {
-		text = g_strdup_printf ("%i", value);
+		text = g_strdup_printf ("%i", (gint) value);
 	}
 	return text;
 }
@@ -525,7 +484,8 @@
 static void
 gpm_graph_widget_draw_grid (GpmGraphWidget *graph, cairo_t *cr)
 {
-	gfloat a, b;
+	guint i;
+	gfloat b;
 	gdouble dotted[] = {1., 2.};
 	gfloat divwidth  = (gfloat)graph->priv->box_width / 10.0f;
 	gfloat divheight = (gfloat)graph->priv->box_height / 10.0f;
@@ -537,16 +497,16 @@
 
 	/* do vertical lines */
 	cairo_set_source_rgb (cr, 0.1, 0.1, 0.1);
-	for (a=1; a<10; a++) {
-		b = graph->priv->box_x + (a * divwidth);
+	for (i=1; i<10; i++) {
+		b = graph->priv->box_x + ((gfloat) i * divwidth);
 		cairo_move_to (cr, (gint)b + 0.5f, graph->priv->box_y);
 		cairo_line_to (cr, (gint)b + 0.5f, graph->priv->box_y + graph->priv->box_height);
 		cairo_stroke (cr);
 	}
 
 	/* do horizontal lines */
-	for (a=1; a<10; a++) {
-		b = graph->priv->box_y + (a * divheight);
+	for (i=1; i<10; i++) {
+		b = graph->priv->box_y + ((gfloat) i * divheight);
 		cairo_move_to (cr, graph->priv->box_x, (gint)b + 0.5f);
 		cairo_line_to (cr, graph->priv->box_x + graph->priv->box_width, (int)b + 0.5f);
 		cairo_stroke (cr);
@@ -565,9 +525,10 @@
 static void
 gpm_graph_widget_draw_labels (GpmGraphWidget *graph, cairo_t *cr)
 {
-	gfloat a, b;
+	guint i;
+	gfloat b;
 	gchar *text;
-	gint value;
+	gfloat value;
 	gfloat divwidth  = (gfloat)graph->priv->box_width / 10.0f;
 	gfloat divheight = (gfloat)graph->priv->box_height / 10.0f;
 	gint length_x = graph->priv->stop_x - graph->priv->start_x;
@@ -580,21 +541,20 @@
 
 	/* do x text */
 	cairo_set_source_rgb (cr, 0, 0, 0);
-	for (a=0; a<11; a++) {
-		b = graph->priv->box_x + (a * divwidth);
-		value = ((length_x / 10) * a) + graph->priv->start_x;
-		text = gpm_get_axis_label (graph->priv->axis_type_x, value);
+	for (i=0; i<11; i++) {
+		b = graph->priv->box_x + ((gfloat) i * divwidth);
+		value = ((length_x / 10.0f) * (gfloat) i) + (gfloat) graph->priv->start_x;
+		text = gpm_get_axis_label (graph->priv->type_x, value);
 
 		pango_layout_set_text (graph->priv->layout, text, -1);
 		pango_layout_get_pixel_extents (graph->priv->layout, &ink_rect, &logical_rect);
 		/* have data points 0 and 10 bounded, but 1..9 centered */
-		if (a == 0) {
+		if (i == 0)
 			offsetx = 2.0;
-		} else if (a == 10) {
+		else if (i == 10)
 			offsetx = ink_rect.width;
-		} else {
+		else
 			offsetx = (ink_rect.width / 2.0f);
-		}
 
 		cairo_move_to (cr, b - offsetx,
 			       graph->priv->box_y + graph->priv->box_height + 2.0);
@@ -604,22 +564,21 @@
 	}
 
 	/* do y text */
-	for (a=0; a<11; a++) {
-		b = graph->priv->box_y + (a * divheight);
-		value = (length_y / 10) * (10 - a) + graph->priv->start_y;
-		text = gpm_get_axis_label (graph->priv->axis_type_y, value);
+	for (i=0; i<11; i++) {
+		b = graph->priv->box_y + ((gfloat) i * divheight);
+		value = ((gfloat) length_y / 10.0f) * (10 - (gfloat) i) + graph->priv->start_y;
+		text = gpm_get_axis_label (graph->priv->type_y, value);
 
 		pango_layout_set_text (graph->priv->layout, text, -1);
 		pango_layout_get_pixel_extents (graph->priv->layout, &ink_rect, &logical_rect);
 
 		/* have data points 0 and 10 bounded, but 1..9 centered */
-		if (a == 10) {
+		if (i == 10)
 			offsety = 0;
-		} else if (a == 0) {
+		else if (i == 0)
 			offsety = ink_rect.height;
-		} else {
+		else
 			offsety = (ink_rect.height / 2.0f);
-		}
 		offsetx = ink_rect.width + 7;
 		offsety -= 10;
 		cairo_move_to (cr, graph->priv->box_x - offsetx - 2, b + offsety);
@@ -640,31 +599,28 @@
 static guint
 gpm_graph_widget_get_y_label_max_width (GpmGraphWidget *graph, cairo_t *cr)
 {
-	gfloat a, b;
+	guint i;
 	gchar *text;
 	gint value;
-	gfloat divheight = (gfloat)graph->priv->box_height / 10.0f;
 	gint length_y = graph->priv->stop_y - graph->priv->start_y;
 	PangoRectangle ink_rect, logical_rect;
 	guint biggest = 0;
 
 	/* do y text */
-	for (a=0; a<11; a++) {
-		b = graph->priv->box_y + (a * divheight);
-		value = (length_y / 10) * (10 - a) + graph->priv->start_y;
-		text = gpm_get_axis_label (graph->priv->axis_type_y, value);
+	for (i=0; i<11; i++) {
+		value = (length_y / 10) * (10 - (gfloat) i) + graph->priv->start_y;
+		text = gpm_get_axis_label (graph->priv->type_y, value);
 		pango_layout_set_text (graph->priv->layout, text, -1);
 		pango_layout_get_pixel_extents (graph->priv->layout, &ink_rect, &logical_rect);
-		if (ink_rect.width > biggest) {
+		if (ink_rect.width > (gint) biggest)
 			biggest = ink_rect.width;
-		}
 		g_free (text);
 	}
 	return biggest;
 }
 
 /**
- * gpm_graph_widget_auto_range:
+ * gpm_graph_widget_autorange_x:
  * @graph: This class instance
  *
  * Autoranges the graph axis depending on the axis type, and the maximum
@@ -672,228 +628,222 @@
  * resolution but also a number that scales "well" to a 10x10 grid.
  **/
 static void
-gpm_graph_widget_auto_range (GpmGraphWidget *graph)
+gpm_graph_widget_autorange_x (GpmGraphWidget *graph)
 {
-	gint biggest_x = 0;
-	gint biggest_y = 0;
-	gint smallest_x = 999999;
-	gint smallest_y = 999999;
+	gfloat biggest_x = G_MINFLOAT;
+	gfloat smallest_x = G_MAXFLOAT;
 	guint rounding_x = 1;
-	guint rounding_y = 1;
-	GpmArray *array;
-	GpmArrayPoint *point;
-	guint i;
-	guint j;
-	guint length;
+	GPtrArray *data;
+	GpmPointObj *point;
+	guint i, j;
+	guint len = 0;
+	GPtrArray *array;
+
+	array = graph->priv->data_list;
+
+	/* find out if we have no data */
+	for (j=0; j<array->len; j++) {
+		data = g_ptr_array_index (array, j);
+		len = data->len;
+		if (len > 0)
+			break;
+	}
 
-	if (graph->priv->data_list->len == 0) {
+	/* no data in any array */
+	if (len == 0) {
 		egg_debug ("no data");
 		graph->priv->start_x = 0;
-		graph->priv->start_y = 0;
 		graph->priv->stop_x = 10;
-		graph->priv->stop_y = 10;
 		return;
 	}
 
-	/* get the range for all graphs */
-	for (i=0; i<graph->priv->data_list->len; i++) {
-		array = g_ptr_array_index (graph->priv->data_list, i);
-		length = gpm_array_get_size (array);
-		for (j=0; j < length; j++) {
-			point = gpm_array_get (array, j);
-			if (point->x > biggest_x) {
+	/* get the range for the graph */
+	for (j=0; j<array->len; j++) {
+		data = g_ptr_array_index (array, j);
+		for (i=0; i < data->len; i++) {
+			point = (GpmPointObj *) g_ptr_array_index (data, i);
+			if (point->x > biggest_x)
 				biggest_x = point->x;
-			}
-			if (point->y > biggest_y) {
-				biggest_y = point->y;
-			}
-			if (point->x < smallest_x) {
+			if (point->x < smallest_x)
 				smallest_x = point->x;
-			}
-			if (point->y < smallest_y) {
-				smallest_y = point->y;
-			}
 		}
 	}
-	egg_debug ("Data range is %i<x<%i, %i<y<%i", smallest_x, biggest_x, smallest_y, biggest_y);
+	egg_debug ("Data range is %f<x<%f", smallest_x, biggest_x);
+	/* don't allow no difference */
+	if (biggest_x - smallest_x < 0.0001) {
+		biggest_x++;
+		smallest_x--;
+	}
 
-	if (graph->priv->axis_type_x == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
+	if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
 		rounding_x = 10;
-	} else if (graph->priv->axis_type_x == GPM_GRAPH_WIDGET_TYPE_POWER) {
-		rounding_x = 1000;
-	} else if (graph->priv->axis_type_x == GPM_GRAPH_WIDGET_TYPE_VOLTAGE) {
+	} else if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_FACTOR) {
+		rounding_x = 1;
+	} else if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_POWER) {
+		rounding_x = 10;
+	} else if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_VOLTAGE) {
 		rounding_x = 1000;
-	} else if (graph->priv->axis_type_x == GPM_GRAPH_WIDGET_TYPE_TIME) {
-		if (biggest_x < 150) {
+	} else if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_TIME) {
+		if (biggest_x-smallest_x < 150)
 			rounding_x = 150;
-		} else if (biggest_x < 5*60) {
+		else if (biggest_x-smallest_x < 5*60)
 			rounding_x = 5 * 60;
-		} else {
+		else
 			rounding_x = 10 * 60;
+	}
+
+	graph->priv->start_x = egg_precision_round_down (smallest_x, rounding_x);
+	graph->priv->stop_x = egg_precision_round_up (biggest_x, rounding_x);
+
+	egg_debug ("Processed(1) range is %i<x<%i",
+		   graph->priv->start_x, graph->priv->stop_x);
+
+	/* if percentage, and close to the end points, then extend */
+	if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
+		if (graph->priv->stop_x >= 90)
+			graph->priv->stop_x = 100;
+		if (graph->priv->start_x > 0 && graph->priv->start_x <= 10)
+			graph->priv->start_x = 0;
+	} else if (graph->priv->type_x == GPM_GRAPH_WIDGET_TYPE_TIME) {
+		if (graph->priv->start_x > 0 && graph->priv->start_x <= 60*10)
+			graph->priv->start_x = 0;
+	}
+
+	egg_debug ("Processed range is %i<x<%i",
+		   graph->priv->start_x, graph->priv->stop_x);
+}
+
+/**
+ * gpm_graph_widget_autorange_y:
+ * @graph: This class instance
+ *
+ * Autoranges the graph axis depending on the axis type, and the maximum
+ * value of the data. We have to be careful to choose a number that gives good
+ * resolution but also a number that scales "well" to a 10x10 grid.
+ **/
+static void
+gpm_graph_widget_autorange_y (GpmGraphWidget *graph)
+{
+	gfloat biggest_y = G_MINFLOAT;
+	gfloat smallest_y = G_MAXFLOAT;
+	guint rounding_y = 1;
+	GPtrArray *data;
+	GpmPointObj *point;
+	guint i, j;
+	guint len = 0;
+	GPtrArray *array;
+
+	array = graph->priv->data_list;
+
+	/* find out if we have no data */
+	for (j=0; j<array->len; j++) {
+		data = g_ptr_array_index (array, j);
+		len = data->len;
+		if (len > 0)
+			break;
+	}
+
+	/* no data in any array */
+	if (len == 0) {
+		egg_debug ("no data");
+		graph->priv->start_y = 0;
+		graph->priv->stop_y = 10;
+		return;
+	}
+
+	/* get the range for the graph */
+	for (j=0; j<array->len; j++) {
+		data = g_ptr_array_index (array, j);
+		for (i=0; i < data->len; i++) {
+			point = (GpmPointObj *) g_ptr_array_index (data, i);
+			if (point->y > biggest_y)
+				biggest_y = point->y;
+			if (point->y < smallest_y)
+				smallest_y = point->y;
 		}
 	}
-	if (graph->priv->axis_type_y == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
+	egg_debug ("Data range is %f<y<%f", smallest_y, biggest_y);
+	/* don't allow no difference */
+	if (biggest_y - smallest_y < 0.0001) {
+		biggest_y++;
+		smallest_y--;
+	}
+
+	if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
 		rounding_y = 10;
-	} else if (graph->priv->axis_type_y == GPM_GRAPH_WIDGET_TYPE_POWER) {
-		rounding_y = 1000;
-	} else if (graph->priv->axis_type_y == GPM_GRAPH_WIDGET_TYPE_VOLTAGE) {
+	} else if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_FACTOR) {
+		rounding_y = 1;
+	} else if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_POWER) {
+		rounding_y = 10;
+	} else if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_VOLTAGE) {
 		rounding_y = 1000;
-	} else if (graph->priv->axis_type_y == GPM_GRAPH_WIDGET_TYPE_TIME) {
-		if (biggest_y < 150) {
+	} else if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_TIME) {
+		if (biggest_y-smallest_y < 150)
 			rounding_y = 150;
-		} else if (biggest_y < 5*60) {
+		else if (biggest_y < 5*60)
 			rounding_y = 5 * 60;
-		} else {
+		else
 			rounding_y = 10 * 60;
-		}
 	}
 
-	graph->priv->start_x = gpm_precision_round_down (smallest_x, rounding_x);
-	graph->priv->start_y = gpm_precision_round_down (smallest_y, rounding_y);
-	graph->priv->stop_x = gpm_precision_round_up (biggest_x, rounding_x);
-	graph->priv->stop_y = gpm_precision_round_up (biggest_y, rounding_y);
+	graph->priv->start_y = egg_precision_round_down (smallest_y, rounding_y);
+	graph->priv->stop_y = egg_precision_round_up (biggest_y, rounding_y);
 
-	/* if percentage, and close to the end points, then extend */
-	if (graph->priv->axis_type_x == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
-		if (graph->priv->stop_x >= 90) {
-			graph->priv->stop_x = 100;
-		}
-		if (graph->priv->start_x <= 10) {
-			graph->priv->start_x = 0;
-		}
-	} else if (graph->priv->axis_type_x == GPM_GRAPH_WIDGET_TYPE_TIME) {
-		if (graph->priv->start_x <= 60*10) {
-			graph->priv->start_x = 0;
-		}
+	/* a factor graph always is centered around zero */
+	if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_FACTOR) {
+		if (abs (graph->priv->stop_y) > abs (graph->priv->start_y))
+			graph->priv->start_y = -graph->priv->stop_y;
+		else
+			graph->priv->stop_y = -graph->priv->start_y;
 	}
-	if (graph->priv->axis_type_y == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
-		if (graph->priv->stop_y >= 90) {
+
+	egg_debug ("Processed(1) range is %i<y<%i",
+		   graph->priv->start_y, graph->priv->stop_y);
+
+	if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_PERCENTAGE) {
+		if (graph->priv->stop_y >= 90)
 			graph->priv->stop_y = 100;
-		}
-		if (graph->priv->start_y <= 10) {
+		if (graph->priv->start_y > 0 && graph->priv->start_y <= 10)
 			graph->priv->start_y = 0;
-		}
-	} else if (graph->priv->axis_type_y == GPM_GRAPH_WIDGET_TYPE_TIME) {
-		if (graph->priv->start_y <= 60*10) {
+	} else if (graph->priv->type_y == GPM_GRAPH_WIDGET_TYPE_TIME) {
+		if (graph->priv->start_y <= 60*10)
 			graph->priv->start_y = 0;
-		}
 	}
 
-	egg_debug ("Processed range is %i<x<%i, %i<y<%i",
-		   graph->priv->start_x, graph->priv->stop_x,
+	egg_debug ("Processed range is %i<y<%i",
 		   graph->priv->start_y, graph->priv->stop_y);
 }
 
 /**
- * gpm_graph_widget_set_colour:
+ * gpm_graph_widget_set_color:
  * @cr: Cairo drawing context
- * @colour: The colour enum
+ * @color: The color enum
  **/
 static void
-gpm_graph_widget_set_colour (cairo_t *cr, guint32 colour)
+gpm_graph_widget_set_color (cairo_t *cr, guint32 color)
 {
 	guint8 r, g, b;
-	egg_color_to_rgb (colour, &r, &g, &b);
+	egg_color_to_rgb (color, &r, &g, &b);
 	cairo_set_source_rgb (cr, ((gdouble) r)/256.0f, ((gdouble) g)/256.0f, ((gdouble) b)/256.0f);
 }
 
 /**
- * gpm_graph_widget_draw_dot:
- * @cr: Cairo drawing context
- * @x: The X-coordinate for the center
- * @y: The Y-coordinate for the center
- * @colour: The colour enum
- * @shape: The shape enum
- *
- * Draw the dot on the graph of a specified colour
- **/
-static void
-gpm_graph_widget_draw_dot (cairo_t             *cr,
-			   gfloat               x,
-			   gfloat               y,
-			   guint32              colour,
-			   GpmGraphWidgetShape  shape)
-{
-	gfloat width;
-	if (shape == GPM_GRAPH_WIDGET_SHAPE_CIRCLE) {
-		/* circle */
-		cairo_arc (cr, (gint)x + 0.5f, (gint)y + 0.5f, 4, 0, 2*M_PI);
-		gpm_graph_widget_set_colour (cr, colour);
-		cairo_fill (cr);
-		cairo_arc (cr, (gint)x + 0.5f, (gint)y + 0.5f, 4, 0, 2*M_PI);
-		cairo_set_source_rgb (cr, 0, 0, 0);
-		cairo_set_line_width (cr, 1);
-		cairo_stroke (cr);
-	} else if (shape == GPM_GRAPH_WIDGET_SHAPE_SQUARE) {
-		/* box */
-		width = 8.0;
-		cairo_rectangle (cr, (gint)x + 0.5f - (width/2), (gint)y + 0.5f - (width/2), width, width);
-		gpm_graph_widget_set_colour (cr, colour);
-		cairo_fill (cr);
-		cairo_rectangle (cr, (gint)x + 0.5f - (width/2), (gint)y + 0.5f - (width/2), width, width);
-		cairo_set_source_rgb (cr, 0, 0, 0);
-		cairo_set_line_width (cr, 1);
-		cairo_stroke (cr);
-	} else if (shape == GPM_GRAPH_WIDGET_SHAPE_DIAMOND) {
-		/* diamond */
-		width = 4.0;
-		cairo_new_path (cr);
-		cairo_move_to (cr, x+0.5, y-width+0.5);
-		cairo_line_to (cr, x+width+0.5, y+0.5);
-		cairo_line_to (cr, x+0.5, y+width+0.5);
-		cairo_line_to (cr, x-width+0.5, y+0.5);
-		cairo_close_path (cr);
-		gpm_graph_widget_set_colour (cr, colour);
-		cairo_fill (cr);
-		cairo_new_path (cr);
-		cairo_move_to (cr, x+0.5, y-width+0.5);
-		cairo_line_to (cr, x+width+0.5, y+0.5);
-		cairo_line_to (cr, x+0.5, y+width+0.5);
-		cairo_line_to (cr, x-width+0.5, y+0.5);
-		cairo_close_path (cr);
-		cairo_set_source_rgb (cr, 0, 0, 0);
-		cairo_set_line_width (cr, 1);
-		cairo_stroke (cr);
-	} else if (shape == GPM_GRAPH_WIDGET_SHAPE_TRIANGLE) {
-		/* triangle */
-		width = 4.0;
-		cairo_new_path (cr);
-		cairo_move_to (cr, x+0.5, y-width+0.5);
-		cairo_line_to (cr, x+width+0.5, y+width+0.5-1.0);
-		cairo_line_to (cr, x-width+0.5, y+width+0.5-1.0);
-		cairo_close_path (cr);
-		gpm_graph_widget_set_colour (cr, colour);
-		cairo_fill (cr);
-		cairo_new_path (cr);
-		cairo_move_to (cr, x+0.5, y-width+0.5);
-		cairo_line_to (cr, x+width+0.5, y+width+0.5-1.0);
-		cairo_line_to (cr, x-width+0.5, y+width+0.5-1.0);
-		cairo_close_path (cr);
-		cairo_set_source_rgb (cr, 0, 0, 0);
-		cairo_set_line_width (cr, 1);
-		cairo_stroke (cr);
-	} else {
-		egg_warning ("shape %i not recognised!", shape);
-	}
-}
-
-/**
  * gpm_graph_widget_draw_legend_line:
  * @cr: Cairo drawing context
  * @x: The X-coordinate for the center
  * @y: The Y-coordinate for the center
- * @colour: The colour enum
+ * @color: The color enum
  *
- * Draw the legend line on the graph of a specified colour
+ * Draw the legend line on the graph of a specified color
  **/
 static void
-gpm_graph_widget_draw_legend_line (cairo_t *cr, gfloat x, gfloat y, guint32 colour)
+gpm_graph_widget_draw_legend_line (cairo_t *cr, gfloat x, gfloat y, guint32 color)
 {
 	gfloat width = 10;
 	gfloat height = 2;
 	/* background */
 	cairo_rectangle (cr, (int) (x - (width/2)) + 0.5, (int) (y - (height/2)) + 0.5, width, height);
-	gpm_graph_widget_set_colour (cr, colour);
+	gpm_graph_widget_set_color (cr, color);
 	cairo_fill (cr);
 	/* solid outline box */
 	cairo_rectangle (cr, (int) (x - (width/2)) + 0.5, (int) (y - (height/2)) + 0.5, width, height);
@@ -918,6 +868,24 @@
 }
 
 /**
+ * gpm_graph_widget_draw_dot:
+ **/
+static void
+gpm_graph_widget_draw_dot (cairo_t *cr, gfloat x, gfloat y, guint32 color)
+{
+	gfloat width;
+	/* box */
+	width = 2.0;
+	cairo_rectangle (cr, (gint)x + 0.5f - (width/2), (gint)y + 0.5f - (width/2), width, width);
+	gpm_graph_widget_set_color (cr, color);
+	cairo_fill (cr);
+	cairo_rectangle (cr, (gint)x + 0.5f - (width/2), (gint)y + 0.5f - (width/2), width, width);
+	cairo_set_source_rgb (cr, 0, 0, 0);
+	cairo_set_line_width (cr, 1);
+	cairo_stroke (cr);
+}
+
+/**
  * gpm_graph_widget_draw_line:
  * @graph: This class instance
  * @cr: Cairo drawing context
@@ -930,11 +898,11 @@
 {
 	gfloat oldx, oldy;
 	gfloat newx, newy;
-	guint j;
-	guint length;
-	GpmArray *array;
-	GpmArrayPoint *point;
-	guint i;
+	GPtrArray *data;
+	GPtrArray *array;
+	GpmGraphWidgetPlot plot;
+	GpmPointObj *point;
+	guint i, j;
 
 	if (graph->priv->data_list->len == 0) {
 		egg_debug ("no data");
@@ -942,110 +910,52 @@
 	}
 	cairo_save (cr);
 
-	/* do all the lines on the graphs */
-	for (i=0; i<graph->priv->data_list->len; i++) {
-		egg_debug ("drawing line %i", i);
-		array = g_ptr_array_index (graph->priv->data_list, i);
+	array = graph->priv->data_list;
 
-		/* we have no data */
-		if (array == NULL) {
-			break;
-		}
+	/* do each line */
+	for (j=0; j<array->len; j++) {
+		data = g_ptr_array_index (array, j);
+		if (data->len == 0)
+			continue;
+		plot = GPOINTER_TO_UINT (g_ptr_array_index (graph->priv->plot_list, j));
 
 		/* get the very first point so we can work out the old */
-		point = gpm_array_get (array, 0);
+		point = (GpmPointObj *) g_ptr_array_index (data, 0);
 		oldx = 0;
 		oldy = 0;
 		gpm_graph_widget_get_pos_on_graph (graph, point->x, point->y, &oldx, &oldy);
+		if (plot == GPM_GRAPH_WIDGET_PLOT_POINTS || plot == GPM_GRAPH_WIDGET_PLOT_BOTH)
+			gpm_graph_widget_draw_dot (cr, oldx, oldy, point->color);
 
-		length = gpm_array_get_size (array);
-		for (j=1; j < length; j++) {
-			point = gpm_array_get (array, j);
+		for (i=1; i < data->len; i++) {
+			point = (GpmPointObj *) g_ptr_array_index (data, i);
 
-			/* draw line */
 			gpm_graph_widget_get_pos_on_graph (graph, point->x, point->y, &newx, &newy);
-			cairo_move_to (cr, oldx, oldy);
-			cairo_line_to (cr, newx, newy);
-			cairo_set_line_width (cr, 1.5);
-			gpm_graph_widget_set_colour (cr, point->data);
-			cairo_stroke (cr);
-			/* save old */
-			oldx = newx;
-			oldy = newy;
-		}
-	}
-
-	cairo_restore (cr);
-}
 
-/**
- * gpm_graph_widget_draw_event_dots:
- * @graph: This class instance
- * @cr: Cairo drawing context
- *
- * Draw the data line onto the graph with a big green line. We should already
- * limit the data to < ~100 values, so this shouldn't take too long.
- **/
-static void
-gpm_graph_widget_draw_event_dots (GpmGraphWidget *graph, cairo_t *cr)
-{
-	gfloat newx, newy;
-	GpmGraphWidgetKeyItem *keyitem;
-	guint i;
-	guint length;
-	GpmArray *array = NULL;
-	GpmArrayPoint *point;
-	gint dot;
-	gint prevpos = -1;
-	guint previous_y = 0;
-
-	if (graph->priv->events == NULL) {
-		/* we have no events */
-		return;
-	}
-
-	cairo_save (cr);
-
-	length = gpm_array_get_size (graph->priv->events);
-
-	/* always use the first data array */
-	if (graph->priv->data_list->len > 0) {
-		array = g_ptr_array_index (graph->priv->data_list, 0);
-	}
-
-	for (i=0; i < length; i++) {
-		point = gpm_array_get (graph->priv->events, i);
-		if (point == NULL) {
-			/* this shouldn't ever happen */
-			egg_warning ("point NULL!");
-			break;
-		}
-		/* try to position the point on the line, or at zero if there is no line */
-		if (array == NULL) {
-			dot = 0;
-		} else {
-			dot = gpm_array_interpolate (array, point->x);
-		}
-		gpm_graph_widget_get_pos_on_graph (graph, point->x, dot, &newx, &newy);
+			/* ignore white lines */
+			if (point->color == 0xffffff) {
+				oldx = newx;
+				oldy = newy;
+				continue;
+			}
 
-		/* don't overlay the points, stack vertically */
-		if (abs (newx - prevpos) < 10) {
-			newy = previous_y - 8;
-		}
+			/* draw line */
+			if (plot == GPM_GRAPH_WIDGET_PLOT_LINE || plot == GPM_GRAPH_WIDGET_PLOT_BOTH) {
+				cairo_move_to (cr, oldx, oldy);
+				cairo_line_to (cr, newx, newy);
+				cairo_set_line_width (cr, 1.5);
+				gpm_graph_widget_set_color (cr, point->color);
+				cairo_stroke (cr);
+			}
 
-		/* save the last y point */
-		previous_y = newy;
+			/* draw data dot */
+			if (plot == GPM_GRAPH_WIDGET_PLOT_POINTS || plot == GPM_GRAPH_WIDGET_PLOT_BOTH)
+				gpm_graph_widget_draw_dot (cr, newx, newy, point->color);
 
-		/* only do the event dot, if it's going to be valid on the graph */
-		if (point->x > graph->priv->start_x && newy > graph->priv->box_y) {
-			keyitem = gpm_graph_widget_key_find_id (graph, point->y);
-			if (keyitem == NULL) {
-				egg_warning ("did not find id %i", point->y);
-			} else {
-				gpm_graph_widget_draw_dot (cr, newx, newy, keyitem->colour, keyitem->shape);
-			}
+			/* save old */
+			oldx = newx;
+			oldy = newy;
 		}
-		prevpos = newx;
 	}
 
 	cairo_restore (cr);
@@ -1060,11 +970,7 @@
  * @height: The item height
  **/
 static void
-gpm_graph_widget_draw_bounding_box (cairo_t *cr,
-				    gint     x,
-				    gint     y,
-				    gint     width,
-				    gint     height)
+gpm_graph_widget_draw_bounding_box (cairo_t *cr, gint x, gint y, gint width, gint height)
 {
 	/* background */
 	cairo_rectangle (cr, x, y, width, height);
@@ -1086,52 +992,31 @@
  * @height: The item height
  **/
 static void
-gpm_graph_widget_draw_legend (GpmGraphWidget *graph,
-			      gint     x,
-			      gint     y,
-			      gint     width,
-			      gint     height)
+gpm_graph_widget_draw_legend (GpmGraphWidget *graph, gint x, gint y, gint width, gint height)
 {
 	cairo_t *cr = graph->priv->cr;
 	gint y_count;
-	gint a;
+	guint i;
 	GpmGraphWidgetKeyData *keydataitem;
-	GpmGraphWidgetKeyItem *keyeventitem;
 
 	gpm_graph_widget_draw_bounding_box (cr, x, y, width, height);
 	y_count = y + 10;
 
-	/* add the line colours to the legend */
-	for (a=0; a<g_slist_length (graph->priv->key_data); a++) {
-		keydataitem = (GpmGraphWidgetKeyData *) g_slist_nth_data (graph->priv->key_data, a);
+	/* add the line colors to the legend */
+	for (i=0; i<g_slist_length (graph->priv->key_data); i++) {
+		keydataitem = (GpmGraphWidgetKeyData *) g_slist_nth_data (graph->priv->key_data, i);
 		if (keydataitem == NULL) {
 			/* this shouldn't ever happen */
 			egg_warning ("keydataitem NULL!");
 			break;
 		}
-		gpm_graph_widget_draw_legend_line (cr, x + 8, y_count, keydataitem->colour);
+		gpm_graph_widget_draw_legend_line (cr, x + 8, y_count, keydataitem->color);
 		cairo_move_to (cr, x + 8 + 10, y_count - 6);
 		cairo_set_source_rgb (cr, 0, 0, 0);
 		pango_layout_set_text (graph->priv->layout, keydataitem->desc, -1);
 		pango_cairo_show_layout (cr, graph->priv->layout);
 		y_count = y_count + GPM_GRAPH_WIDGET_LEGEND_SPACING;
 	}
-
-	/* add the events to the legend */
-	for (a=0; a<g_slist_length (graph->priv->key_event); a++) {
-		keyeventitem = (GpmGraphWidgetKeyItem *) g_slist_nth_data (graph->priv->key_event, a);
-		if (keyeventitem == NULL) {
-			/* this shouldn't ever happen */
-			egg_warning ("keyeventitem NULL!");
-			break;
-		}
-		gpm_graph_widget_draw_dot (cr, x + 8, y_count,
-					   keyeventitem->colour, keyeventitem->shape);
-		cairo_move_to (cr, x + 8 + 10, y_count - 6);
-		pango_layout_set_text (graph->priv->layout, keyeventitem->desc, -1);
-		pango_cairo_show_layout (cr, graph->priv->layout);
-		y_count = y_count + GPM_GRAPH_WIDGET_LEGEND_SPACING;
-	}
 }
 
 /**
@@ -1148,44 +1033,29 @@
 gpm_graph_widget_legend_calculate_size (GpmGraphWidget *graph, cairo_t *cr,
 					guint *width, guint *height)
 {
-	guint a;
+	guint i;
 	PangoRectangle ink_rect, logical_rect;
 	GpmGraphWidgetKeyData *keydataitem;
-	GpmGraphWidgetKeyItem *keyeventitem;
 
-	g_return_val_if_fail (graph != NULL, FALSE);
 	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
 
 	/* set defaults */
 	*width = 0;
 	*height = 0;
 
-	/* add the line colours to the legend */
-	for (a=0; a<g_slist_length (graph->priv->key_data); a++) {
-		keydataitem = (GpmGraphWidgetKeyData *) g_slist_nth_data (graph->priv->key_data, a);
+	/* add the line colors to the legend */
+	for (i=0; i<g_slist_length (graph->priv->key_data); i++) {
+		keydataitem = (GpmGraphWidgetKeyData *) g_slist_nth_data (graph->priv->key_data, i);
 		*height = *height + GPM_GRAPH_WIDGET_LEGEND_SPACING;
 		pango_layout_set_text (graph->priv->layout, keydataitem->desc, -1);
 		pango_layout_get_pixel_extents (graph->priv->layout, &ink_rect, &logical_rect);
-		if (*width < ink_rect.width) {
-			*width = ink_rect.width;
-		}
-	}
-
-	/* add the events to the legend */
-	for (a=0; a<g_slist_length (graph->priv->key_event); a++) {
-		keyeventitem = (GpmGraphWidgetKeyItem *) g_slist_nth_data (graph->priv->key_event, a);
-		*height = *height + GPM_GRAPH_WIDGET_LEGEND_SPACING;
-		pango_layout_set_text (graph->priv->layout, keyeventitem->desc, -1);
-		pango_layout_get_pixel_extents (graph->priv->layout, &ink_rect, &logical_rect);
-		if (*width < ink_rect.width) {
+		if ((gint) *width < ink_rect.width)
 			*width = ink_rect.width;
-		}
 	}
 
 	/* have we got no entries? */
-	if (*width == 0 && *height == 0) {
+	if (*width == 0 && *height == 0)
 		return TRUE;
-	}
 
 	/* add for borders */
 	*width += 25;
@@ -1195,56 +1065,58 @@
 }
 
 /**
- * gpm_graph_widget_draw_graph:
+ * gpm_graph_widget_draw:
  * @graph: This class instance
- * @cr: Cairo drawing context
+ * @event: The expose event
  *
- * Draw the complete graph, with the box, the grid, the labels and the line.
+ * Just repaint the entire graph widget on expose.
  **/
-static void
-gpm_graph_widget_draw_graph (GtkWidget *graph_widget, cairo_t *cr)
+static gboolean
+gpm_graph_widget_draw (GtkWidget *widget, cairo_t *cr)
 {
+	GtkAllocation allocation;
 	gint legend_x = 0;
 	gint legend_y = 0;
 	guint legend_height = 0;
 	guint legend_width = 0;
-	gint data_x;
-	gint data_y;
+	gfloat data_x;
+	gfloat data_y;
 
-	GpmGraphWidget *graph = (GpmGraphWidget*) graph_widget;
-	g_return_if_fail (graph != NULL);
-	g_return_if_fail (GPM_IS_GRAPH_WIDGET (graph));
+	GpmGraphWidget *graph = (GpmGraphWidget*) widget;
+	g_return_val_if_fail (graph != NULL, FALSE);
+	g_return_val_if_fail (GPM_IS_GRAPH_WIDGET (graph), FALSE);
 
 	gpm_graph_widget_legend_calculate_size (graph, cr, &legend_width, &legend_height);
-
 	cairo_save (cr);
 
 	/* we need this so we know the y text */
-	gpm_graph_widget_auto_range (graph);
+	if (graph->priv->autorange_x)
+		gpm_graph_widget_autorange_x (graph);
+	if (graph->priv->autorange_y)
+		gpm_graph_widget_autorange_y (graph);
 
 	graph->priv->box_x = gpm_graph_widget_get_y_label_max_width (graph, cr) + 10;
 	graph->priv->box_y = 5;
 
-	graph->priv->box_height = graph_widget->allocation.height - (20 + graph->priv->box_y);
+	gtk_widget_get_allocation (widget, &allocation);
+	graph->priv->box_height = allocation.height - (20 + graph->priv->box_y);
 
 	/* make size adjustment for legend */
 	if (graph->priv->use_legend && legend_height > 0) {
-		graph->priv->box_width = graph_widget->allocation.width -
+		graph->priv->box_width = allocation.width -
 					 (3 + legend_width + 5 + graph->priv->box_x);
 		legend_x = graph->priv->box_x + graph->priv->box_width + 6;
 		legend_y = graph->priv->box_y;
 	} else {
-		graph->priv->box_width = graph_widget->allocation.width -
+		graph->priv->box_width = allocation.width -
 					 (3 + graph->priv->box_x);
 	}
 
 	/* graph background */
 	gpm_graph_widget_draw_bounding_box (cr, graph->priv->box_x, graph->priv->box_y,
 				     graph->priv->box_width, graph->priv->box_height);
-
-	if (graph->priv->use_grid) {
+	if (graph->priv->use_grid)
 		gpm_graph_widget_draw_grid (graph, cr);
-	}
 
 	/* -3 is so we can keep the lines inside the box at both extremes */
 	data_x = graph->priv->stop_x - graph->priv->start_x;
@@ -1255,40 +1127,10 @@
 	gpm_graph_widget_draw_labels (graph, cr);
 	gpm_graph_widget_draw_line (graph, cr);
 
-	if (graph->priv->use_events) {
-		gpm_graph_widget_draw_event_dots (graph, cr);
-	}
-
-	if (graph->priv->use_legend && legend_height > 0) {
+	if (graph->priv->use_legend && legend_height > 0)
 		gpm_graph_widget_draw_legend (graph, legend_x, legend_y, legend_width, legend_height);
-	}
 
 	cairo_restore (cr);
-}
-
-/**
- * gpm_graph_widget_expose:
- * @graph: This class instance
- * @event: The expose event
- *
- * Just repaint the entire graph widget on expose.
- **/
-static gboolean
-gpm_graph_widget_expose (GtkWidget *graph, GdkEventExpose *event)
-{
-	cairo_t *cr;
-
-	/* get a cairo_t */
-	cr = gdk_cairo_create (graph->window);
-	cairo_rectangle (cr,
-			 event->area.x, event->area.y,
-			 event->area.width, event->area.height);
-	cairo_clip (cr);
-	((GpmGraphWidget *)graph)->priv->cr = cr;
-
-	gpm_graph_widget_draw_graph (graph, cr);
-
-	cairo_destroy (cr);
 	return FALSE;
 }
 
@@ -1302,297 +1144,3 @@
 	return g_object_new (GPM_TYPE_GRAPH_WIDGET, NULL);
 }
 
-/***************************************************************************
- ***                          MAKE CHECK TESTS                           ***
- ***************************************************************************/
-#ifdef GPM_BUILD_TESTS
-#include "gpm-self-test.h"
-
-GtkWidget *window;
-GtkWidget *graph;
-GtkWidget *label;
-
-static gint
-close_handler (GtkWidget *widget, gpointer gdata)
-{
-	gtk_main_quit ();
-	return FALSE;
-}
-
-static void
-clicked_passed_cb (GtkWidget *widget, gpointer gdata)
-{
-	GpmSelfTest *test = (GpmSelfTest *) gdata;
-	gpm_st_success (test, NULL);
-	gtk_main_quit ();
-}
-
-static void
-clicked_failed_cb (GtkWidget *widget, gpointer gdata)
-{
-	GpmSelfTest *test = (GpmSelfTest *) gdata;
-	gpm_st_failed (test, NULL);
-	gtk_main_quit ();
-}
-
-static void
-create_graph_window (GpmSelfTest *test)
-{
-	GtkWidget *button_passed;
-	GtkWidget *button_failed;
-	GtkWidget *vbox;
-
-	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-	graph = gpm_graph_widget_new ();
-	vbox = gtk_vbox_new (FALSE, 0);
-	label = gtk_label_new("Title");
-
-	button_passed = gtk_button_new_with_label("Passed");
-	gtk_signal_connect(GTK_OBJECT(button_passed), "clicked", GTK_SIGNAL_FUNC(clicked_passed_cb), test);
-	button_failed = gtk_button_new_with_label("Failed");
-	gtk_signal_connect(GTK_OBJECT(button_failed), "clicked", GTK_SIGNAL_FUNC(clicked_failed_cb), test);
-
-	gtk_widget_set_size_request (graph, 600, 300);
-	gtk_signal_connect (GTK_OBJECT(window), "delete_event", GTK_SIGNAL_FUNC(close_handler), test);
-
-	gtk_container_add (GTK_CONTAINER (window), vbox);
-	gtk_box_pack_start (GTK_BOX (vbox), graph, FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX (vbox), button_passed, FALSE, FALSE, 0);
-	gtk_box_pack_start (GTK_BOX (vbox), button_failed, FALSE, FALSE, 0);
-	gtk_container_border_width (GTK_CONTAINER (window), 0);
-
-	gtk_widget_show (vbox);
-	gtk_widget_show (label);
-	gtk_widget_show (button_passed);
-	gtk_widget_show (button_failed);
-}
-
-static void
-wait_for_input (GpmSelfTest *test)
-{
-	gtk_widget_hide_all (window);
-	gtk_widget_show_all (window);
-	gtk_main ();
-}
-
-void
-gpm_st_title_graph (GpmSelfTest *test, const gchar *format, ...)
-{
-	va_list args;
-	gchar va_args_buffer [1025];
-	va_start (args, format);
-	g_vsnprintf (va_args_buffer, 1024, format, args);
-	va_end (args);
-	gpm_st_title (test, va_args_buffer);
-	gtk_label_set_label (GTK_LABEL (label), va_args_buffer);
-//	g_print ("> check #%u\t%s: \t%s...", test->total+1, test->type, va_args_buffer);
-//	test->total++;
-}
-
-void
-gpm_st_graph_widget (GpmSelfTest *test)
-{
-	GpmArray *data;
-	GpmArray *data_more;
-	GpmArray *events;
-	gboolean ret;
-
-	if (gpm_st_start (test, "GpmGraphWidget") == FALSE) {
-		return;
-	}
-
-	create_graph_window (test);
-	gpm_graph_widget_enable_legend (GPM_GRAPH_WIDGET (graph), TRUE);
-	gpm_graph_widget_enable_events (GPM_GRAPH_WIDGET (graph), TRUE);
-
-	/********** TYPES *************/
-	gpm_st_title_graph (test, "graph loaded, visible, no key, and set to y=percent x=time");
-	wait_for_input (test);
-
-	gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (graph), GPM_GRAPH_WIDGET_TYPE_PERCENTAGE);
-	gpm_graph_widget_set_axis_type_y (GPM_GRAPH_WIDGET (graph), GPM_GRAPH_WIDGET_TYPE_TIME);
-
-	gpm_st_title_graph (test, "now set to y=time x=percent");
-	wait_for_input (test);
-
-	/********** KEY DATA *************/
-	gpm_graph_widget_key_data_add (GPM_GRAPH_WIDGET (graph), EGG_COLOR_RED, "red data");
-	gpm_graph_widget_key_data_add (GPM_GRAPH_WIDGET (graph), EGG_COLOR_GREEN, "green data");
-	gpm_graph_widget_key_data_add (GPM_GRAPH_WIDGET (graph), EGG_COLOR_BLUE, "blue data");
-
-	gpm_st_title_graph (test, "red green blue key data added");
-	wait_for_input (test);
-
-	gpm_graph_widget_key_data_clear (GPM_GRAPH_WIDGET (graph));
-
-	gpm_st_title_graph (test, "data items cleared, no key remains");
-	wait_for_input (test);
-
-	/********** KEY EVENT *************/
-	gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (graph), 0,
-					EGG_COLOR_RED,
-					GPM_GRAPH_WIDGET_SHAPE_CIRCLE,
-					"red circle");
-	gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (graph), 1,
-					EGG_COLOR_GREEN,
-					GPM_GRAPH_WIDGET_SHAPE_SQUARE,
-					"green square");
-	gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (graph), 2,
-					EGG_COLOR_BLUE,
-					GPM_GRAPH_WIDGET_SHAPE_TRIANGLE,
-					"blue triangle");
-	gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (graph), 3,
-					EGG_COLOR_WHITE,
-					GPM_GRAPH_WIDGET_SHAPE_DIAMOND,
-					"white diamond");
-
-	gpm_st_title_graph (test, "red green blue white key events added");
-	wait_for_input (test);
-
-
-	/********** KEY EVENT duplicate test *************/
-	gpm_st_title (test, "duplicate key event test");
-	ret = gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (graph), 3,
-					      EGG_COLOR_WHITE,
-					      GPM_GRAPH_WIDGET_SHAPE_DIAMOND,
-					      "white diamond");
-	if (!ret) {
-		gpm_st_success (test, "refused duplicate id");
-	} else {
-		gpm_st_failed (test, "added duplicate ID!");
-	}
-
-	gpm_graph_widget_key_event_clear (GPM_GRAPH_WIDGET (graph));
-
-	gpm_st_title_graph (test, "event items cleared, no key remains");
-	wait_for_input (test);
-
-	/********** DATA *************/
-	gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (graph), GPM_GRAPH_WIDGET_TYPE_PERCENTAGE);
-	gpm_graph_widget_set_axis_type_y (GPM_GRAPH_WIDGET (graph), GPM_GRAPH_WIDGET_TYPE_PERCENTAGE);
-
-	gpm_graph_widget_key_data_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_graph_widget_key_event_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_graph_widget_key_data_add (GPM_GRAPH_WIDGET (graph), EGG_COLOR_RED, "red data");
-	gpm_graph_widget_key_data_add (GPM_GRAPH_WIDGET (graph), EGG_COLOR_BLUE, "blue data");
-	gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (graph), 0, EGG_COLOR_GREEN, GPM_GRAPH_WIDGET_SHAPE_SQUARE, "green square");
-	
-	/********** ADD INVALID DATA *************/
-	data = gpm_array_new ();
-	gpm_array_append (data, 50, 0, EGG_COLOR_RED);
-	gpm_array_append (data, 40, 100, EGG_COLOR_RED);
-	gpm_graph_widget_data_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_st_title (test, "add invalid data");
-	ret = gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (graph), data);
-	if (!ret) {
-		gpm_st_success (test, "ignored");
-	} else {
-		gpm_st_failed (test, "failed to ignore invalid data");
-	}
-	g_object_unref (data);
-
-	/********** ADD NO DATA *************/
-	data = gpm_array_new ();
-	gpm_st_title (test, "add zero data");
-	gpm_graph_widget_data_clear (GPM_GRAPH_WIDGET (graph));
-	ret = gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (graph), data);
-	if (!ret) {
-		gpm_st_success (test, "ignored");
-	} else {
-		gpm_st_failed (test, "failed to ignore zero data");
-	}
-	g_object_unref (data);
-
-	/********** ADD VALID DATA *************/
-	data = gpm_array_new ();
-	gpm_array_append (data, 0, 0, EGG_COLOR_RED);
-	gpm_array_append (data, 100, 100, EGG_COLOR_RED);
-	gpm_st_title (test, "add valid data");
-	ret = gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (graph), data);
-	if (ret) {
-		gpm_st_success (test, NULL);
-	} else {
-		gpm_st_failed (test, "failed to add valid data");
-	}
-
-	/********** SHOW VALID DATA *************/
-	gpm_st_title_graph (test, "red line shown gradient up");
-	wait_for_input (test);
-
-	/*********** second line **************/
-	data_more = gpm_array_new ();
-	gpm_array_append (data_more, 0, 100, EGG_COLOR_BLUE);
-	gpm_array_append (data_more, 100, 0, EGG_COLOR_BLUE);
-	gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (graph), data_more);
-
-	gpm_st_title_graph (test, "red line shown gradient up, blue gradient down");
-	wait_for_input (test);
-
-	/*********** dots **************/
-	events = gpm_array_new ();
-	gpm_array_append (events, 25, 0, 0);
-	gpm_array_append (events, 50, 0, 0);
-	gpm_array_append (events, 75, 0, 0);
-	gpm_graph_widget_events_add (GPM_GRAPH_WIDGET (graph), events);
-
-	gpm_st_title_graph (test, "events follow red line (primary)");
-	wait_for_input (test);
-
-	/*********** stacked dots **************/
-	gpm_array_append (events, 76, 0, 0);
-	gpm_array_append (events, 77, 0, 0);
-	gpm_graph_widget_events_add (GPM_GRAPH_WIDGET (graph), events);
-
-	gpm_st_title_graph (test, "three events stacked at ~75");
-	wait_for_input (test);
-
-	/*********** events removed **************/
-	gpm_graph_widget_events_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_st_title_graph (test, "events removed");
-	wait_for_input (test);
-
-	/*********** data lines removed **************/
-	gpm_graph_widget_data_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_st_title_graph (test, "all lines and event removed");
-	wait_for_input (test);
-
-	g_object_unref (events);
-	g_object_unref (data);
-	g_object_unref (data_more);
-
-	/********** AUTORANGING PERCENT (close) *************/
-	gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (graph), GPM_GRAPH_WIDGET_TYPE_PERCENTAGE);
-	gpm_graph_widget_key_event_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_graph_widget_key_data_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_graph_widget_key_data_add (GPM_GRAPH_WIDGET (graph), EGG_COLOR_RED, "red data");
-	data = gpm_array_new ();
-	gpm_array_append (data, 0, 75, EGG_COLOR_RED);
-	gpm_array_append (data, 20, 78, EGG_COLOR_RED);
-	gpm_array_append (data, 40, 74, EGG_COLOR_RED);
-	gpm_array_append (data, 60, 72, EGG_COLOR_RED);
-	gpm_array_append (data, 80, 78, EGG_COLOR_RED);
-	gpm_array_append (data, 100, 79, EGG_COLOR_RED);
-	gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (graph), data);
-	gpm_st_title_graph (test, "autorange y axis between 70 and 80");
-	wait_for_input (test);
-	g_object_unref (data);
-
-	/********** AUTORANGING PERCENT (extremes) *************/
-	data = gpm_array_new ();
-	gpm_array_append (data, 0, 6, EGG_COLOR_RED);
-	gpm_array_append (data, 100, 85, EGG_COLOR_RED);
-	gpm_graph_widget_data_clear (GPM_GRAPH_WIDGET (graph));
-	gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (graph), data);
-	gpm_st_title_graph (test, "autorange y axis between 0 and 100");
-	wait_for_input (test);
-	g_object_unref (data);
-
-	/* hide window */
-	gtk_widget_hide_all (window);
-
-	gpm_st_end (test);
-}
-
-#endif
-
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-graph-widget.h gnome-power-manager-2.24.4/src/gpm-graph-widget.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-graph-widget.h	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-graph-widget.h	2020-04-05 16:08:10.000000000 +0000
@@ -16,14 +16,14 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #ifndef __GPM_GRAPH_WIDGET_H__
 #define __GPM_GRAPH_WIDGET_H__
 
 #include <gtk/gtk.h>
-#include "gpm-array.h"
+#include "gpm-point-obj.h"
 
 G_BEGIN_DECLS
 
@@ -41,39 +41,38 @@
 typedef struct GpmGraphWidgetPrivate	GpmGraphWidgetPrivate;
 
 typedef enum {
-	GPM_GRAPH_WIDGET_SHAPE_CIRCLE,
-	GPM_GRAPH_WIDGET_SHAPE_SQUARE,
-	GPM_GRAPH_WIDGET_SHAPE_DIAMOND,
-	GPM_GRAPH_WIDGET_SHAPE_TRIANGLE,
-	GPM_GRAPH_WIDGET_SHAPE_LAST
-} GpmGraphWidgetShape;
-
-typedef enum {
 	GPM_GRAPH_WIDGET_TYPE_INVALID,
 	GPM_GRAPH_WIDGET_TYPE_PERCENTAGE,
+	GPM_GRAPH_WIDGET_TYPE_FACTOR,
 	GPM_GRAPH_WIDGET_TYPE_TIME,
 	GPM_GRAPH_WIDGET_TYPE_POWER,
 	GPM_GRAPH_WIDGET_TYPE_VOLTAGE,
-	GPM_GRAPH_WIDGET_TYPE_LAST
-} GpmGraphWidgetAxisType;
+	GPM_GRAPH_WIDGET_TYPE_UNKNOWN
+} GpmGraphWidgetType;
 
-/* the different kinds of dots in the key */
-typedef struct {
-	guint			 id;
-	guint32			 colour;
-	GpmGraphWidgetShape	 shape;
-	gchar			*desc;
-} GpmGraphWidgetKeyItem;
+typedef enum {
+	GPM_GRAPH_WIDGET_PLOT_LINE,
+	GPM_GRAPH_WIDGET_PLOT_POINTS,
+	GPM_GRAPH_WIDGET_PLOT_BOTH
+} GpmGraphWidgetPlot;
+
+typedef enum {
+	GPM_GRAPH_WIDGET_SHAPE_CIRCLE,
+	GPM_GRAPH_WIDGET_SHAPE_SQUARE,
+	GPM_GRAPH_WIDGET_SHAPE_DIAMOND,
+	GPM_GRAPH_WIDGET_SHAPE_TRIANGLE,
+	GPM_GRAPH_WIDGET_SHAPE_LAST
+} GpmGraphWidgetShape;
 
 /* the different kinds of lines in the key */
 typedef struct {
-	guint32			 colour;
+	guint32			 color;
 	gchar			*desc;
 } GpmGraphWidgetKeyData;
 
 struct GpmGraphWidget
 {
-	GtkDrawingArea	 parent;
+	GtkDrawingArea		 parent;
 	GpmGraphWidgetPrivate	*priv;
 };
 
@@ -85,32 +84,13 @@
 GType		 gpm_graph_widget_get_type		(void);
 GtkWidget	*gpm_graph_widget_new			(void);
 
-void		 gpm_graph_widget_enable_legend		(GpmGraphWidget	*graph,
-							 gboolean	 enable);
-void		 gpm_graph_widget_enable_events		(GpmGraphWidget	*graph,
-							 gboolean	 enable);
-gboolean	 gpm_graph_widget_data_add		(GpmGraphWidget	*graph,
-							 GpmArray	*array);
-void		 gpm_graph_widget_data_clear		(GpmGraphWidget	*graph);
-void		 gpm_graph_widget_events_add		(GpmGraphWidget	*graph,
-							 GpmArray	*array);
-void		 gpm_graph_widget_events_clear		(GpmGraphWidget	*graph);
-void		 gpm_graph_widget_set_axis_type_x	(GpmGraphWidget	*graph,
-							 GpmGraphWidgetAxisType axis);
-void		 gpm_graph_widget_set_axis_type_y	(GpmGraphWidget	*graph,
-							 GpmGraphWidgetAxisType axis);
-gboolean	 gpm_graph_widget_key_data_clear	(GpmGraphWidget	*graph);
-gboolean	 gpm_graph_widget_key_data_add		(GpmGraphWidget	*graph,
-							 guint		 colour,
-							 const gchar	*desc);
-gboolean	 gpm_graph_widget_key_event_clear	(GpmGraphWidget	*graph);
-gboolean	 gpm_graph_widget_key_event_add		(GpmGraphWidget	*graph,
-							 guint		 id,
-							 guint32	 colour,
-							 GpmGraphWidgetShape shape,
-							 const gchar	*name);
-
-GpmGraphWidgetAxisType	 gpm_graph_widget_string_to_axis_type (const gchar	*type);
+gboolean	 gpm_graph_widget_data_clear		(GpmGraphWidget		*graph);
+gboolean	 gpm_graph_widget_data_assign		(GpmGraphWidget		*graph,
+							 GpmGraphWidgetPlot	 plot,
+							 GPtrArray		*array);
+gboolean	 gpm_graph_widget_key_data_add		(GpmGraphWidget		*graph,
+							 guint32		 color,
+							 const gchar		*desc);
 
 G_END_DECLS
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-main.c gnome-power-manager-2.24.4/src/gpm-main.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-main.c	2009-01-16 03:37:59.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-main.c	2020-04-05 16:08:10.000000000 +0000
@@ -26,20 +26,20 @@
 #include "config.h"
 
 #include <string.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <glib.h>
 #include <glib/gi18n.h>
+#include <gtk/gtk.h>
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
-#include <libgnomeui/libgnomeui.h>
-#include <glade/glade.h>
-#include <gst/gst.h>
 
 #include "gpm-stock-icons.h"
 #include "gpm-common.h"
 #include "egg-debug.h"
 
 #include "gpm-manager.h"
+#include "gpm-session.h"
 #include "dbus/xdg-power-management-core.h"
 
 static void gpm_exit (GpmManager *manager);
@@ -125,133 +125,188 @@
 }
 
 /**
+ * gpm_main_stop_cb:
+ **/
+static void
+gpm_main_stop_cb (GpmSession *session, GMainLoop *loop)
+{
+        g_main_loop_quit (loop);
+}
+
+/**
+ * gpm_main_query_end_session_cb:
+ **/
+static void
+gpm_main_query_end_session_cb (GpmSession *session, guint flags, GMainLoop *loop)
+{
+        /* just send response */
+        gpm_session_end_session_response (session, TRUE, NULL);
+}
+
+/**
+ * gpm_main_end_session_cb:
+ **/
+static void
+gpm_main_end_session_cb (GpmSession *session, guint flags, GMainLoop *loop)
+{
+        /* send response */
+        gpm_session_end_session_response (session, TRUE, NULL);
+
+        /* exit loop, will unref manager */
+        g_main_loop_quit (loop);
+}
+
+/**
  * main:
  **/
 int
 main (int argc, char *argv[])
 {
-	GMainLoop *loop;
-	GnomeClient *master;
-	GnomeClientFlags flags;
-	DBusGConnection *system_connection;
-	DBusGConnection *session_connection;
-	gboolean verbose = FALSE;
-	gboolean version = FALSE;
-	gboolean timed_exit = FALSE;
-	gboolean immediate_exit = FALSE;
-	GpmManager *manager = NULL;
-	GError *error = NULL;
-	GOptionContext *context;
- 	GnomeProgram *program;
+        GMainLoop *loop;
+        DBusGConnection *system_connection;
+        DBusGConnection *session_connection;
+        gboolean verbose = FALSE;
+        gboolean version = FALSE;
+        gboolean timed_exit = FALSE;
+        gboolean immediate_exit = FALSE;
+        GpmSession *session = NULL;
+        GpmManager *manager = NULL;
+        GError *error = NULL;
+        GOptionContext *context;
+        gint ret;
+        guint timer_id;
+
+	/*
+	GpmPrefs *prefs = NULL;
+	*/
+        GtkApplication *app;
+        GtkWidget *window;
+        gint status;
+
 
 	const GOptionEntry options[] = {
 		{ "verbose", '\0', 0, G_OPTION_ARG_NONE, &verbose,
 		  N_("Show extra debugging information"), NULL },
 		{ "version", '\0', 0, G_OPTION_ARG_NONE, &version,
-		  N_("Show version of installed program and exit"), NULL },
-		{ "timed-exit", '\0', 0, G_OPTION_ARG_NONE, &timed_exit,
-		  N_("Exit after a small delay (for debugging)"), NULL },
-		{ "immediate-exit", '\0', 0, G_OPTION_ARG_NONE, &immediate_exit,
 		  N_("Exit after the manager has loaded (for debugging)"), NULL },
 		{ NULL}
 	};
 
-	context = g_option_context_new (N_("GNOME Power Manager"));
+	context = g_option_context_new (N_("MATE Power Preferences"));
 
 	bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
 	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
 	textdomain (GETTEXT_PACKAGE);
 
+	dbus_g_thread_init();
+
 	g_option_context_add_main_entries (context, options, GETTEXT_PACKAGE);
 	g_option_context_set_translation_domain(context, GETTEXT_PACKAGE);
 
-	program = gnome_program_init (argv[0], VERSION,
-			   	      LIBGNOMEUI_MODULE, argc, argv,
-			    	      GNOME_PROGRAM_STANDARD_PROPERTIES,
-			    	      GNOME_PARAM_GOPTION_CONTEXT, context,
-			    	      GNOME_PARAM_HUMAN_READABLE_NAME, GPM_NAME,
-			    	      NULL);
-	g_set_application_name (GPM_NAME);
-
-	master = gnome_master_client ();
-	flags = gnome_client_get_flags (master);
-
 	if (version) {
 		g_print ("Version %s\n", VERSION);
 		goto unref_program;
 	}
 
-	if (flags & GNOME_CLIENT_IS_CONNECTED) {
-		/* We'll disable this as users are getting constant crashes */
-		/* gnome_client_set_restart_style (master, GNOME_RESTART_IMMEDIATELY);*/
-		gnome_client_flush (master);
-	}
-
-	g_signal_connect (GTK_OBJECT (master), "die", G_CALLBACK (gpm_exit), manager);
-
-	if (!g_thread_supported ())
-		g_thread_init (NULL);
-	dbus_g_thread_init ();
-
 	egg_debug_init (verbose);
 
-	egg_debug ("GNOME %s %s", GPM_NAME, VERSION);
-
-	/* check dbus connections, exit if not valid */
-	system_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
-	if (error) {
-		egg_warning ("%s", error->message);
-		g_error_free (error);
-		egg_error ("This program cannot start until you start "
-			   "the dbus system service.\n"
-			   "It is <b>strongly recommended</b> you reboot "
-			   "your computer after starting this service.");
-	}
-
-	session_connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-	if (error) {
-		egg_warning ("%s", error->message);
-		g_error_free (error);
-		egg_error ("This program cannot start until you start the "
-			   "dbus session service.\n\n"
-			   "This is usually started automatically in X "
-			   "or gnome startup when you start a new session.");
-	}
+        egg_debug ("MATE %s %s", GPM_NAME, VERSION);
+	dbus_g_thread_init();
+	gtk_init (&argc, &argv);
+
+        /* check dbus connections, exit if not valid */
+        system_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+        if (error) {
+                egg_warning ("%s", error->message);
+                g_error_free (error);
+                egg_error ("This program cannot start until you start "
+                           "the dbus system service.\n"
+                           "It is <b>strongly recommended</b> you reboot "
+                           "your computer after starting this service.");
+        }   
+
+        session_connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+        if (error) {
+                egg_warning ("%s", error->message);
+                g_error_free (error);
+                egg_error ("This program cannot start until you start the "
+                           "dbus session service.\n\n"
+                           "This is usually started automatically in X "
+                           "or mate startup when you start a new session.");
+        }   
 
-	/* Add application specific icons to search path */
-	gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (),
+        /* add application specific icons to search path */
+        gtk_icon_theme_append_search_path (gtk_icon_theme_get_default (), 
                                            GPM_DATA G_DIR_SEPARATOR_S "icons");
 
-	/* initialise gstreamer */
-	gst_init (&argc, &argv);
-
-	/* create a new gui object */
-	manager = gpm_manager_new ();
-
-	if (!gpm_object_register (session_connection, G_OBJECT (manager))) {
-		egg_error ("%s is already running in this session.", GPM_NAME);
-		return 0;
-	}
-
-	loop = g_main_loop_new (NULL, FALSE);
-
-	/* Only timeout and close the mainloop if we have specified it
-	 * on the command line */
-	if (timed_exit) {
-		g_timeout_add (1000 * 20, (GSourceFunc) timed_exit_cb, loop);
-	}
-
-	if (immediate_exit == FALSE) {
-		g_main_loop_run (loop);
-	}
+        loop = g_main_loop_new (NULL, FALSE);
 
-	g_main_loop_unref (loop);
+        /* optionally register with the session */
+        session = gpm_session_new ();
+        g_signal_connect (session, "stop", G_CALLBACK (gpm_main_stop_cb), loop);
+        g_signal_connect (session, "query-end-session", G_CALLBACK (gpm_main_query_end_session_cb), loop);
+        g_signal_connect (session, "end-session", G_CALLBACK (gpm_main_end_session_cb), loop);
+        gpm_session_register_client (session, "mate-power-manager", getenv ("DESKTOP_AUTOSTART_ID"));
+
+        /* create a new gui object */
+        manager = gpm_manager_new ();
+
+        if (!gpm_object_register (session_connection, G_OBJECT (manager))) {
+                egg_error ("%s is already running in this session.", GPM_NAME);
+                goto unref_program;
+        }
+
+        /* register to be a policy agent, just like kpackagekit does */
+        ret = dbus_bus_request_name(dbus_g_connection_get_connection(system_connection),
+                                    "org.freedesktop.Policy.Power",
+                                    DBUS_NAME_FLAG_REPLACE_EXISTING, NULL);
+        switch (ret) {
+        case DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:
+                egg_debug ("Successfully acquired interface org.freedesktop.Policy.Power.");
+                break;
+        case DBUS_REQUEST_NAME_REPLY_IN_QUEUE:
+                egg_debug ("Queued for interface org.freedesktop.Policy.Power.");
+                break;
+        default:
+                break;
+        };
+
+        /* Only timeout and close the mainloop if we have specified it
+         * on the command line */
+        if (timed_exit) {
+                timer_id = g_timeout_add_seconds (20, (GSourceFunc) timed_exit_cb, loop);
+                g_source_set_name_by_id (timer_id, "[GpmMain] timed-exit");
+        }
+
+        if (immediate_exit == FALSE) {
+                g_main_loop_run (loop);
+        }
+
+        g_main_loop_unref (loop);
+
+        g_object_unref (session);
+        g_object_unref (manager);
+
+
+
+
+	/*
+	gdk_init (&argc, &argv);
+        app = gtk_application_new("org.mate.PowerManager.Preferences", 0);
+
+        prefs = gpm_prefs_new ();
+
+        window = gpm_window (prefs);
+        g_signal_connect (app, "activate",
+                          G_CALLBACK (gpm_prefs_activated_cb), prefs);
+        g_signal_connect (prefs, "action-help",
+                          G_CALLBACK (gpm_prefs_help_cb), prefs);
+        g_signal_connect_swapped (prefs, "action-close",
+                          G_CALLBACK (gtk_widget_destroy), window);
+        status = g_application_run (G_APPLICATION (app), argc, argv);
+	*/
 
-	/* rip down gstreamer */
-	gst_deinit ();
-	g_object_unref (manager);
 unref_program:
-	g_object_unref (program);
 /*
 	g_option_context_free (context);
 */
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-manager.c gnome-power-manager-2.24.4/src/gpm-manager.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-manager.c	2008-12-02 07:24:51.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-manager.c	2020-04-05 16:08:10.000000000 +0000
@@ -38,7 +38,6 @@
 #include <gtk/gtk.h>
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
-#include <libgnomeui/gnome-client.h>
 
 #include <libhal-gpower.h>
 #include <libhal-gmanager.h>
@@ -417,6 +416,61 @@
 	return TRUE;
 }
 
+
+#define GSM_DBUS_SERVICE "org.gnome.SessionManager"
+#define GSM_DBUS_PATH "/org/gnome/SessionManager"
+#define GSM_DBUS_INTERFACE "org.gnome.SessionManager"
+
+#include <pwd.h>
+
+static gboolean
+can_shutdown ()
+{
+	uid_t uid;
+	struct passwd *pw;
+
+	uid = getuid ();                       
+	if ((pw = getpwuid (uid)) != NULL) {
+		return (gboolean)chkauthattr ("solaris.system.shutdown", pw->pw_name);
+	}
+	return FALSE;
+}
+
+/**
+ * gsm_dbus_method:
+ * @method: The g-s-m DBUS method name, e.g. "Logout" or "Shutdown"
+ **/
+static gboolean
+gpm_manager_action_interactive (GpmManager *manager)
+{
+	DBusGConnection *connection;
+	DBusGProxy *proxy;
+	GError *error = NULL;
+	
+	if (can_shutdown() == FALSE)
+		return FALSE;
+
+	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+	if (connection == NULL) {
+		if (error) {
+			egg_warning ("Couldn't connect to PowerManager %s",
+				     error->message);
+			g_error_free (error);
+		}
+		return FALSE;
+	}
+
+	proxy = dbus_g_proxy_new_for_name (connection,
+					   GSM_DBUS_SERVICE,
+					   GSM_DBUS_PATH,
+					   GSM_DBUS_INTERFACE);
+	dbus_g_proxy_call_no_reply (proxy, "Shutdown", 
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+	g_object_unref (proxy);
+	return TRUE;	
+}
+
 /**
  * manager_policy_do:
  * @manager: This class instance
@@ -465,9 +519,8 @@
 	} else if (strcmp (action, ACTION_INTERACTIVE) == 0) {
 		gpm_info_explain_reason (manager->priv->info, GPM_EVENT_NOTIFICATION,
 					_("GNOME interactive logout."), reason);
-		gnome_client_request_save (gnome_master_client (),
-					   GNOME_SAVE_GLOBAL,
-					   TRUE, GNOME_INTERACT_ANY, FALSE, TRUE);
+		if (gpm_manager_action_interactive (manager) == FALSE)
+			egg_warning ("Couldn't ask for interactive dialog from session manager");
 	} else {
 		egg_warning ("unknown action %s", action);
 	}
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-notify.c gnome-power-manager-2.24.4/src/gpm-notify.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-notify.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-notify.c	2020-04-05 16:08:10.000000000 +0000
@@ -103,15 +103,18 @@
 //		notify->priv->libnotify = NULL;
 	}
 
+	/*
 	if (notify->priv->status_icon != NULL &&
 	    gtk_status_icon_get_visible (notify->priv->status_icon)) {
 		notify->priv->libnotify = notify_notification_new_with_status_icon (title, content,
 										    msgicon,
 										    notify->priv->status_icon);
 	} else {
-		notify->priv->libnotify = notify_notification_new (title, content, msgicon, NULL);
+	*/
+		notify->priv->libnotify = notify_notification_new (title, content, msgicon);
+	/*
 	}
-
+	*/
 	if (timeout == GPM_NOTIFY_TIMEOUT_NEVER) {
 		notify_notification_set_timeout (notify->priv->libnotify, 0);
 	} else if (timeout == GPM_NOTIFY_TIMEOUT_LONG) {
@@ -321,7 +324,7 @@
 		error = NULL;
 
  		cmdline = g_strconcat ("gnome-open ", notify->priv->internet_url, NULL);
-		ret = gdk_spawn_command_line_on_screen (gscreen, cmdline, &error);
+		ret = g_spawn_command_line_async (cmdline, &error);
 		g_free (cmdline);
 
 		if (ret)
@@ -331,7 +334,7 @@
 		error = NULL;
 
  		cmdline = g_strconcat ("xdg-open ", notify->priv->internet_url, NULL);
-		ret = gdk_spawn_command_line_on_screen (gscreen, cmdline, &error);
+		ret = g_spawn_command_line_async (cmdline, &error);
 		g_free (cmdline);
 
 		if (!ret) {
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-notify.h gnome-power-manager-2.24.4/src/gpm-notify.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-notify.h	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-notify.h	2020-04-05 16:08:10.000000000 +0000
@@ -24,7 +24,7 @@
 #define __GPM_NOTIFY_H
 
 #include <glib-object.h>
-#include <gtk/gtkstatusicon.h>
+#include <gtk/gtk.h>
 
 G_BEGIN_DECLS
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-point-obj.c gnome-power-manager-2.24.4/src/gpm-point-obj.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-point-obj.c	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-point-obj.c	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,64 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Richard Hughes <richard@hughsie.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <glib.h>
+
+#include "egg-debug.h"
+#include "gpm-point-obj.h"
+
+/**
+ * gpm_point_obj_copy:
+ **/
+GpmPointObj *
+gpm_point_obj_copy (const GpmPointObj *cobj)
+{
+	GpmPointObj *obj;
+	obj = g_new0 (GpmPointObj, 1);
+	obj->x = cobj->x;
+	obj->y = cobj->y;
+	obj->color = cobj->color;
+	return obj;
+}
+
+/**
+ * gpm_point_obj_new:
+ **/
+GpmPointObj *
+gpm_point_obj_new (void)
+{
+	GpmPointObj *obj;
+	obj = g_new0 (GpmPointObj, 1);
+	obj->x = 0.0f;
+	obj->y = 0.0f;
+	obj->color = 0x0;
+	return obj;
+}
+
+/**
+ * gpm_point_obj_free:
+ **/
+void
+gpm_point_obj_free (GpmPointObj *obj)
+{
+	if (obj == NULL)
+		return;
+	g_free (obj);
+}
+
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-point-obj.h gnome-power-manager-2.24.4/src/gpm-point-obj.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-point-obj.h	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-point-obj.h	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,42 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Richard Hughes <richard@hughsie.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __GPM_POINT_OBJ_H__
+#define __GPM_POINT_OBJ_H__
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+typedef struct
+{
+	gfloat		 x;
+	gfloat		 y;
+	guint32		 color;
+} GpmPointObj;
+
+GpmPointObj	*gpm_point_obj_new		(void);
+GpmPointObj	*gpm_point_obj_copy		(const GpmPointObj	*cobj);
+void		 gpm_point_obj_free		(GpmPointObj		*obj);
+
+G_END_DECLS
+
+#endif /* __GPM_POINT_OBJ_H__ */
+
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-prefs-core.c gnome-power-manager-2.24.4/src/gpm-prefs-core.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-prefs-core.c	2008-11-04 05:42:39.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-prefs-core.c	2020-04-05 16:08:10.000000000 +0000
@@ -26,7 +26,6 @@
 #include <glib.h>
 #include <glib/gi18n.h>
 
-#include <glade/glade.h>
 #include <gtk/gtk.h>
 #include <dbus/dbus-glib.h>
 #include <math.h>
@@ -34,6 +33,7 @@
 #include <gconf/gconf-client.h>
 
 #include <libhal-gmanager.h>
+#include <libhal-gcpufreq.h>
 
 #include "gpm-tray-icon.h"
 #include "gpm-common.h"
@@ -44,6 +44,9 @@
 #include "gpm-stock-icons.h"
 #include "gpm-screensaver.h"
 #include "gpm-prefs-server.h"
+#if defined(sun) && defined(__SVR4)
+#include "gpm-control.h"
+#endif
 
 #ifdef HAVE_GCONF_DEFAULTS
 #include <polkit-gnome/polkit-gnome.h>
@@ -57,7 +60,7 @@
 
 struct GpmPrefsPrivate
 {
-	GladeXML		*glade_xml;
+	GtkBuilder		*builder;
 	gboolean		 has_batteries;
 	gboolean		 has_lcd;
 	gboolean		 has_ups;
@@ -67,11 +70,17 @@
 	gboolean		 can_shutdown;
 	gboolean		 can_suspend;
 	gboolean		 can_hibernate;
+#if defined(sun) && defined(__SVR4)
+       gboolean                 can_cpufreq;
+       gboolean                 can_brightness;
+#endif
 	GpmConf			*conf;
 	GpmScreensaver		*screensaver;
 #ifdef HAVE_GCONF_DEFAULTS
 	PolKitGnomeAction	*default_action;
 #endif
+	HalGCpufreq		*hal_cpufreq;
+	HalGCpufreqType	 cpufreq_types;
 };
 
 enum {
@@ -92,6 +101,17 @@
 #define ACTION_BLANK_TEXT		_("Blank screen")
 #define ACTION_NOTHING_TEXT		_("Do nothing")
 
+/* The text that should appear in the processor combo box */
+#define CPUFREQ_NOTHING_TEXT		_("Do nothing")
+/* SUN_BRANDING */
+#define CPUFREQ_ONDEMAND_TEXT		_("Based on processor load")
+/* SUN_BRANDING */
+#define CPUFREQ_CONSERVATIVE_TEXT	_("Automatic power saving")
+/* SUN_BRANDING */
+#define CPUFREQ_POWERSAVE_TEXT		_("Maximum power saving")
+/* SUN_BRANDING */
+#define CPUFREQ_PERFORMANCE_TEXT	_("Always maximum speed")
+
 /* If sleep time in a slider is set to 61 it is considered as never */
 const int NEVER_TIME_ON_SLIDER = 61;
 
@@ -135,9 +155,9 @@
 void
 gpm_prefs_activate_window (GpmPrefs *prefs)
 {
-	GtkWidget *widget;
-	widget = glade_xml_get_widget (prefs->priv->glade_xml, "window_preferences");
-	gtk_window_present (GTK_WINDOW (widget));
+	GtkWidget *window;
+	window =  GTK_WINDOW (gtk_builder_get_object (prefs->priv->builder, "dialog_preferences"));
+	gtk_window_present (window);
 }
 
 /**
@@ -340,7 +360,7 @@
 	gboolean is_writable;
 	guint gs_idle_time;
 
-	widget = glade_xml_get_widget (prefs->priv->glade_xml, widget_name);
+	widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, widget_name));
 	g_signal_connect (G_OBJECT (widget), "format-value",
 			  G_CALLBACK (gpm_prefs_format_time_cb), prefs);
 
@@ -400,12 +420,12 @@
 				   const gchar *widget_name,
 				   const gchar *gpm_pref_key)
 {
-	GladeXML    *xml = prefs->priv->glade_xml;
+	GtkBuilder    *builder = prefs->priv->builder;
 	GtkWidget *widget;
 	int value;
 	gboolean is_writable;
 
-	widget = glade_xml_get_widget (xml, widget_name);
+	widget = GTK_WIDGET (gtk_builder_get_object (builder, widget_name));
 
 	g_signal_connect (G_OBJECT (widget), "format-value",
 			  G_CALLBACK (gpm_prefs_format_percentage_cb), NULL);
@@ -438,7 +458,7 @@
 	const gchar *action;
 	gchar *gpm_pref_key;
 
-	value = gtk_combo_box_get_active_text (GTK_COMBO_BOX (widget));
+	value = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX (widget));
 
 	if (strcmp (value, ACTION_SUSPEND_TEXT) == 0) {
 		action = ACTION_SUSPEND;
@@ -463,6 +483,27 @@
 }
 
 /**
+ * gpm_prefs_set_combo_simple_text:
+ **/
+static void
+gpm_prefs_set_combo_simple_text (GtkWidget *combo_box)
+{
+	GtkCellRenderer *cell;
+	GtkListStore *store;
+
+	store = gtk_list_store_new (1, G_TYPE_STRING);
+	gtk_combo_box_set_model (GTK_COMBO_BOX (combo_box), GTK_TREE_MODEL (store));
+	g_object_unref (store);
+
+	cell = gtk_cell_renderer_text_new ();
+	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box), cell, TRUE);
+	gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo_box), cell,
+					"text", 0,
+					NULL);
+}
+
+
+/**
  * gpm_prefs_setup_action_combo:
  * @prefs: This prefs class instance
  * @widget_name: The GtkWidget name
@@ -475,14 +516,15 @@
 			      const gchar  *gpm_pref_key,
 			      const gchar **actions)
 {
-	GladeXML    *xml = prefs->priv->glade_xml;
+	GtkBuilder    *builder = prefs->priv->builder;
 	gchar *value;
 	gint i = 0;
 	gint n_added = 0;
 	gboolean is_writable;
 	GtkWidget *widget;
 
-	widget = glade_xml_get_widget (xml, widget_name);
+	widget = GTK_WIDGET (gtk_builder_get_object (builder, widget_name));
+	//gpm_prefs_set_combo_simple_text (widget);
 
 	gpm_conf_get_string (prefs->priv->conf, gpm_pref_key, &value);
 	gpm_conf_is_writable (prefs->priv->conf, gpm_pref_key, &is_writable);
@@ -502,7 +544,7 @@
 		if ((strcmp (actions[i], ACTION_SHUTDOWN) == 0) && !prefs->priv->can_shutdown) {
 			egg_debug ("Cannot add option, as cannot shutdown.");
 		} else if (strcmp (actions[i], ACTION_SHUTDOWN) == 0 && prefs->priv->can_shutdown) {
-			gtk_combo_box_append_text (GTK_COMBO_BOX (widget),
+			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
 						   ACTION_SHUTDOWN_TEXT);
 			n_added++;
 		} else if ((strcmp (actions[i], ACTION_SUSPEND) == 0) && !prefs->priv->can_suspend) {
@@ -510,23 +552,23 @@
 		} else if ((strcmp (actions[i], ACTION_HIBERNATE) == 0) && !prefs->priv->can_hibernate) {
 			egg_debug ("Cannot add option, as cannot hibernate.");
 		} else if ((strcmp (actions[i], ACTION_SUSPEND) == 0) && prefs->priv->can_suspend) {
-			gtk_combo_box_append_text (GTK_COMBO_BOX (widget),
+			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
 						   ACTION_SUSPEND_TEXT);
 			n_added++;
 		} else if ((strcmp (actions[i], ACTION_HIBERNATE) == 0) && prefs->priv->can_hibernate) {
-			gtk_combo_box_append_text (GTK_COMBO_BOX (widget),
+			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
 						   ACTION_HIBERNATE_TEXT);
 			n_added++;
 		} else if (strcmp (actions[i], ACTION_BLANK) == 0) {
-			gtk_combo_box_append_text (GTK_COMBO_BOX (widget),
+			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
 						   ACTION_BLANK_TEXT);
 			n_added++;
 		} else if (strcmp (actions[i], ACTION_INTERACTIVE) == 0) {
-			gtk_combo_box_append_text (GTK_COMBO_BOX (widget),
+			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
 						   ACTION_INTERACTIVE_TEXT);
 			n_added++;
 		} else if (strcmp (actions[i], ACTION_NOTHING) == 0) {
-			gtk_combo_box_append_text (GTK_COMBO_BOX (widget),
+			gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
 						   ACTION_NOTHING_TEXT);
 			n_added++;
 		} else {
@@ -574,13 +616,13 @@
 			  const gchar *gpm_pref_key)
 {
 
-	GladeXML    *xml = prefs->priv->glade_xml;
+	GtkBuilder    *builder = prefs->priv->builder;
 	gboolean checked;
 	GtkWidget *widget;
 
 	egg_debug ("Setting up %s", gpm_pref_key);
 
-	widget = glade_xml_get_widget (xml, widget_name);
+	widget = GTK_WIDGET (gtk_builder_get_object (builder, widget_name));
 
 	gpm_conf_get_bool (prefs->priv->conf, gpm_pref_key, &checked);
 	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), checked);
@@ -637,7 +679,7 @@
 		       gint         gs_idle_time)
 {
 	GtkWidget *widget;
-	widget = glade_xml_get_widget (prefs->priv->glade_xml, widget_name);
+	widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, widget_name));
 	if (gs_idle_time + 1 > NEVER_TIME_ON_SLIDER) {
 		egg_warning ("gnome-screensaver timeout is really big. "
 			     "Not sure what to do");
@@ -678,7 +720,7 @@
 	gboolean  enabled;
 
 	if (strcmp (key, GPM_CONF_BACKLIGHT_BRIGHTNESS_AC) == 0) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hscale_ac_brightness");
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hscale_ac_brightness"));
 		gpm_conf_get_int (conf, key, &value);
 		gtk_range_set_value (GTK_RANGE (widget), value);
 	}
@@ -697,6 +739,134 @@
 	}
 }
 
+/**
+ * gpm_prefs_processor_combo_changed_cb:
+ * @widget: The GtkWidget object
+ * @gpm_pref_key: The GConf key for this preference setting.
+ **/
+static void
+gpm_prefs_processor_combo_changed_cb (GtkWidget *widget,
+				      GpmPrefs  *prefs)
+{
+	gchar *value;
+	const gchar *policy;
+	gchar *gpm_pref_key;
+
+	value = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX (widget));
+	if (value == NULL) {
+		egg_warning ("active text failed");
+		return;
+	}
+	if (strcmp (value, CPUFREQ_ONDEMAND_TEXT) == 0) {
+		policy = CODE_CPUFREQ_ONDEMAND;
+	} else if (strcmp (value, CPUFREQ_CONSERVATIVE_TEXT) == 0) {
+		policy = CODE_CPUFREQ_CONSERVATIVE;
+	} else if (strcmp (value, CPUFREQ_POWERSAVE_TEXT) == 0) {
+		policy = CODE_CPUFREQ_POWERSAVE;
+	} else if (strcmp (value, CPUFREQ_PERFORMANCE_TEXT) == 0) {
+		policy = CODE_CPUFREQ_PERFORMANCE;
+	} else if (strcmp (value, CPUFREQ_NOTHING_TEXT) == 0) {
+		policy = CODE_CPUFREQ_NOTHING;
+	} else {
+		g_assert (FALSE);
+	}
+
+	g_free (value);
+	gpm_pref_key = (char *) g_object_get_data (G_OBJECT (widget), "conf_key");
+	egg_debug ("Changing %s to %s", gpm_pref_key, policy);
+	gpm_conf_set_string (prefs->priv->conf, gpm_pref_key, policy);
+}
+
+/**
+ * gpm_prefs_setup_action_combo:
+ * @prefs: This prefs class instance
+ * @widget_name: The GtkWidget name
+ * @gpm_pref_key: The GConf key for this preference setting.
+ * @actions: The actions to associate in an array.
+ **/
+static void
+gpm_prefs_setup_processor_combo (GpmPrefs         *prefs,
+				 const gchar      *widget_name,
+				 const gchar      *gpm_pref_key,
+				 HalGCpufreqType cpufreq_types)
+{
+	gchar *value;
+	guint n_added = 0;
+	gboolean has_option = FALSE;
+	gboolean is_writable;
+	GtkWidget *widget;
+	HalGCpufreqType cpufreq_type;
+
+	widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, widget_name));
+	gpm_conf_get_string (prefs->priv->conf, gpm_pref_key, &value);
+	gpm_conf_is_writable (prefs->priv->conf, gpm_pref_key, &is_writable);
+
+	gtk_widget_set_sensitive (widget, is_writable);
+
+	if (value == NULL) {
+		egg_warning ("invalid schema, please re-install");
+		value = g_strdup ("nothing");
+	}
+
+	g_object_set_data (G_OBJECT (widget), "conf_key", (gpointer) gpm_pref_key);
+	g_signal_connect (G_OBJECT (widget), "changed",
+			  G_CALLBACK (gpm_prefs_processor_combo_changed_cb),
+			  prefs);
+
+	cpufreq_type = hal_gcpufreq_string_to_enum (value);
+
+	if (cpufreq_types & LIBHAL_CPUFREQ_ONDEMAND) {
+		gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
+					   CPUFREQ_ONDEMAND_TEXT);
+		if (cpufreq_type == LIBHAL_CPUFREQ_ONDEMAND) {
+			gtk_combo_box_set_active (GTK_COMBO_BOX (widget), n_added);
+			has_option = TRUE;
+		}
+		n_added++;
+	}
+	if (cpufreq_types & LIBHAL_CPUFREQ_NOTHING) {
+		gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
+					   CPUFREQ_NOTHING_TEXT);
+		if (cpufreq_type == LIBHAL_CPUFREQ_ONDEMAND) {
+			gtk_combo_box_set_active (GTK_COMBO_BOX (widget), n_added);
+			has_option = TRUE;
+		}
+		n_added++;
+	}
+	if (cpufreq_types & LIBHAL_CPUFREQ_CONSERVATIVE) {
+		gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
+					   CPUFREQ_CONSERVATIVE_TEXT);
+		if (cpufreq_type == LIBHAL_CPUFREQ_CONSERVATIVE) {
+			gtk_combo_box_set_active (GTK_COMBO_BOX (widget), n_added);
+			has_option = TRUE;
+		}
+		n_added++;
+	}
+	if (cpufreq_types & LIBHAL_CPUFREQ_POWERSAVE) {
+		gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
+					   CPUFREQ_POWERSAVE_TEXT);
+		if (cpufreq_type == LIBHAL_CPUFREQ_POWERSAVE) {
+			gtk_combo_box_set_active (GTK_COMBO_BOX (widget), n_added);
+			has_option = TRUE;
+		}
+		n_added++;
+	}
+	if (cpufreq_types & LIBHAL_CPUFREQ_PERFORMANCE) {
+		gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (widget),
+					   CPUFREQ_PERFORMANCE_TEXT);
+		if (cpufreq_type == LIBHAL_CPUFREQ_PERFORMANCE) {
+			gtk_combo_box_set_active (GTK_COMBO_BOX (widget), n_added);
+			has_option = TRUE;
+		}
+		n_added++;
+	}
+
+	if (has_option == FALSE || cpufreq_type == LIBHAL_CPUFREQ_NOTHING) {
+		gtk_combo_box_set_active (GTK_COMBO_BOX (widget), n_added);
+	}
+	g_free (value);
+}
+
 /** setup the notification page */
 static void
 prefs_setup_notification (GpmPrefs *prefs)
@@ -714,16 +884,16 @@
 	icon_policy = gpm_tray_icon_mode_from_string (icon_policy_str);
 	g_free (icon_policy_str);
 
-	radiobutton_icon_always = glade_xml_get_widget (prefs->priv->glade_xml,
-							"radiobutton_notification_always");
-	radiobutton_icon_present = glade_xml_get_widget (prefs->priv->glade_xml,
-							"radiobutton_notification_present");
-	radiobutton_icon_charge = glade_xml_get_widget (prefs->priv->glade_xml,
-							"radiobutton_notification_charge");
-	radiobutton_icon_critical = glade_xml_get_widget (prefs->priv->glade_xml,
-							"radiobutton_notification_critical");
-	radiobutton_icon_never = glade_xml_get_widget (prefs->priv->glade_xml,
-							"radiobutton_notification_never");
+	radiobutton_icon_always =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder,
+							"radiobutton_notification_always"));
+	radiobutton_icon_present =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder,
+							"radiobutton_notification_present"));
+	radiobutton_icon_charge =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder,
+							"radiobutton_notification_charge"));
+	radiobutton_icon_critical =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder,
+							"radiobutton_notification_critical"));
+	radiobutton_icon_never =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder,
+							"radiobutton_notification_never"));
 
 	gpm_conf_is_writable (prefs->priv->conf, GPM_CONF_UI_ICON_POLICY, &is_writable);
 	gtk_widget_set_sensitive (radiobutton_icon_always, is_writable);
@@ -770,19 +940,23 @@
 	/* set up the sound checkbox */
 	gpm_prefs_setup_checkbox (prefs, "checkbutton_notification_sound",
 	  			  GPM_CONF_UI_ENABLE_BEEPING);
+	
+	/* set up the screen locking checkbox */
+	gpm_prefs_setup_checkbox (prefs, "checkbutton_screen_lock",
+                                 GPM_CONF_UI_ENABLE_SCREEN_LOCK);
 
 	if (prefs->priv->has_batteries) {
 		/* there's no use case for displaying this option */
-		gtk_widget_hide_all (radiobutton_icon_never);
+		gtk_widget_hide (radiobutton_icon_never);
 	}
 	if (prefs->priv->has_batteries == FALSE) {
 		/* Hide battery radio options if we have no batteries */
-		gtk_widget_hide_all (radiobutton_icon_charge);
-		gtk_widget_hide_all (radiobutton_icon_critical);
+		gtk_widget_hide (radiobutton_icon_charge);
+		gtk_widget_hide (radiobutton_icon_critical);
 	}
 	if (prefs->priv->has_batteries == FALSE && prefs->priv->has_ups == FALSE) {
 		/* Hide battery present option if no ups or primary */
-		gtk_widget_hide_all (radiobutton_icon_present);
+		gtk_widget_hide (radiobutton_icon_present);
 	}
 }
 
@@ -798,10 +972,27 @@
 				 ACTION_HIBERNATE,
 				 ACTION_SHUTDOWN,
 				 NULL};
+/* Disable AC tab on Solaris Sparc in Phase 1 development */
+#if defined(sun) && defined(__SVR4)
+        GtkWidget *notebook;
+        gint page;
+
+        if ((prefs->priv->has_button_lid == FALSE)
+	    && (prefs->priv->hal_cpufreq == FALSE)
+	    && (prefs->priv->has_lcd == FALSE)) {
+                notebook =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "notebook_preferences"));
+                widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "vbox_ac"));
+                page = gtk_notebook_page_num (GTK_NOTEBOOK (notebook), GTK_WIDGET (widget));
+                gtk_notebook_remove_page (GTK_NOTEBOOK (notebook), page);
+                return;
+        }
+#endif
 
 	gpm_prefs_setup_action_combo (prefs, "combobox_ac_lid",
 				      GPM_CONF_BUTTON_LID_AC,
 				      button_lid_actions);
+	gpm_prefs_setup_processor_combo (prefs, "combobox_ac_cpu",
+					 GPM_CONF_CPUFREQ_POLICY_AC, prefs->priv->cpufreq_types);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_computer",
 				      GPM_CONF_TIMEOUT_SLEEP_COMPUTER_AC);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_display",
@@ -817,15 +1008,45 @@
 	set_idle_hscale_stops (prefs, "hscale_ac_display", delay);
 
 	if (prefs->priv->has_button_lid == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_ac_lid");
-		gtk_widget_hide_all (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_ac_lid"));
+		gtk_widget_hide (widget);
+	}
+
+#if defined(sun) && defined(__SVR4)
+        if (prefs->priv->hal_cpufreq == NULL || prefs->priv->can_cpufreq == FALSE ) {
+#else
+	if (prefs->priv->hal_cpufreq == NULL) {
+#endif
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_ac_cpu"));
+		gtk_widget_hide (widget);
 	}
+
+#if defined(sun) && defined(__SVR4)
+	if (prefs->priv->has_lcd == FALSE || prefs->priv->can_brightness == FALSE) {
+#else
 	if (prefs->priv->has_lcd == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_ac_brightness");
-		gtk_widget_hide_all (widget);
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "checkbutton_ac_display_dim");
-		gtk_widget_hide_all (widget);
+#endif
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_ac_brightness"));
+		gtk_widget_hide (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "checkbutton_ac_display_dim"));
+		gtk_widget_hide (widget);
 	}
+
+/* Disable sleep configuration in Phase 1 development */
+#if defined(sun) && defined(__SVR4)
+	widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_ac_computer"));
+	gtk_widget_hide (widget);
+
+	if (prefs->priv->has_lcd == FALSE) {
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "vbox_ac_display"));
+		gtk_widget_hide (widget);
+	} else {
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_ac_display"));
+		gtk_widget_hide (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "checkbutton_ac_display_dim"));
+		gtk_widget_hide (widget);
+	}
+#endif
 }
 
 static void
@@ -851,8 +1072,8 @@
 				 NULL};
 
 	if (prefs->priv->has_batteries == FALSE) {
-		notebook = glade_xml_get_widget (prefs->priv->glade_xml, "notebook_preferences");
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "vbox_battery");
+		notebook =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "notebook_preferences"));
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "vbox_battery"));
 		page = gtk_notebook_page_num (GTK_NOTEBOOK (notebook), GTK_WIDGET (widget));
 		gtk_notebook_remove_page (GTK_NOTEBOOK (notebook), page);
 		return;
@@ -864,6 +1085,8 @@
 	gpm_prefs_setup_action_combo (prefs, "combobox_battery_critical",
 				      GPM_CONF_ACTIONS_CRITICAL_BATT,
 				      battery_critical_actions);
+	gpm_prefs_setup_processor_combo (prefs, "combobox_battery_cpu",
+                                         GPM_CONF_CPUFREQ_POLICY_BATT, prefs->priv->cpufreq_types);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_computer",
 				      GPM_CONF_TIMEOUT_SLEEP_COMPUTER_BATT);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_display",
@@ -877,8 +1100,8 @@
 				  GPM_CONF_BACKLIGHT_IDLE_DIM_BATT);
 
 	if (prefs->priv->has_ambient == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "checkbutton_general_ambient");
-		gtk_widget_hide_all (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "checkbutton_general_ambient"));
+		gtk_widget_hide (widget);
 	}
 
 	delay = gpm_screensaver_get_delay (prefs->priv->screensaver);
@@ -886,13 +1109,33 @@
 	set_idle_hscale_stops (prefs, "hscale_battery_display", delay);
 
 	if (prefs->priv->has_button_lid == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_battery_lid");
-		gtk_widget_hide_all (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_battery_lid"));
+		gtk_widget_hide (widget);
 	}
+#if defined(sun) && defined(__SVR4)
+        if (prefs->priv->has_lcd == FALSE || prefs->priv->can_brightness == FALSE) {
+#else
 	if (prefs->priv->has_lcd == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "checkbutton_battery_display_dim");
-		gtk_widget_hide_all (widget);
+#endif
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "checkbutton_battery_display_dim"));
+		gtk_widget_hide (widget);
 	}
+
+/* Disable sleep configuration in Phase 1 development */
+#if defined(sun) && defined(__SVR4)
+        widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_battery_computer"));
+        gtk_widget_hide (widget);
+
+        if (prefs->priv->has_lcd == FALSE) {
+                widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "vbox_battery_display"));
+                gtk_widget_hide (widget);
+        } else {
+                widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_battery_display"));
+                gtk_widget_hide (widget);
+                widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "checkbutton_battery_display_dim"));
+                gtk_widget_hide (widget);
+        }
+#endif
 }
 
 static void
@@ -910,8 +1153,8 @@
 				 NULL};
 
 	if (prefs->priv->has_ups == FALSE) {
-		notebook = glade_xml_get_widget (prefs->priv->glade_xml, "notebook_preferences");
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "vbox_ups");
+		notebook =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "notebook_preferences"));
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "vbox_ups"));
 		page = gtk_notebook_page_num (GTK_NOTEBOOK (notebook), GTK_WIDGET (widget));
 		gtk_notebook_remove_page (GTK_NOTEBOOK (notebook), page);
 		return;
@@ -955,13 +1198,13 @@
 				  GPM_CONF_AMBIENT_ENABLE);
 
 	if (prefs->priv->has_ambient == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "checkbutton_general_ambient");
-		gtk_widget_hide_all (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "checkbutton_general_ambient"));
+		gtk_widget_hide (widget);
 	}
 
 	if (prefs->priv->has_button_suspend == FALSE) {
-		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_general_suspend");
-		gtk_widget_hide_all (widget);
+		widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "hbox_general_suspend"));
+		gtk_widget_hide (widget);
 	}
 }
 
@@ -1016,7 +1259,7 @@
  * gpk_prefs_create_custom_widget:
  **/
 static GtkWidget *
-gpk_prefs_create_custom_widget (GladeXML *xml, gchar *func_name, gchar *name,
+gpk_prefs_create_custom_widget (GtkBuilder *builder, gchar *func_name, gchar *name,
 				     gchar *string1, gchar *string2,
 				     gint int1, gint int2, gpointer user_data)
 {
@@ -1062,12 +1305,16 @@
 static void
 gpm_prefs_init (GpmPrefs *prefs)
 {
+	guint retval;
+	GError *error = NULL;
 	GtkWidget *main_window;
 	GtkWidget *widget;
 	gint caps;
 
 	prefs->priv = GPM_PREFS_GET_PRIVATE (prefs);
 
+	prefs->priv->hal_cpufreq = hal_gcpufreq_new ();
+
 	prefs->priv->screensaver = gpm_screensaver_new ();
 	g_signal_connect (prefs->priv->screensaver, "gs-delay-changed",
 			  G_CALLBACK (gs_delay_changed_cb), prefs);
@@ -1082,26 +1329,45 @@
 	prefs->priv->has_lcd = ((caps & GPM_PREFS_SERVER_BACKLIGHT) > 0);
 	prefs->priv->has_ambient = ((caps & GPM_PREFS_SERVER_AMBIENT) > 0);
 	prefs->priv->has_button_lid = ((caps & GPM_PREFS_SERVER_LID) > 0);
+#if defined(sun) && defined(__SVR4)
+	prefs->priv->has_button_suspend = FALSE;
+#else
 	prefs->priv->has_button_suspend = TRUE;
+#endif
 	prefs->priv->can_shutdown = gpm_dbus_method_bool ("CanShutdown");
 	prefs->priv->can_suspend = gpm_dbus_method_bool ("CanSuspend");
 	prefs->priv->can_hibernate = gpm_dbus_method_bool ("CanHibernate");
 	egg_debug ("caps=%i", caps);
 
-#ifdef HAVE_GCONF_DEFAULTS
-	/* use custom widgets */
-	glade_set_custom_handler (gpk_prefs_create_custom_widget, prefs);
-
-	/* we have to do this before we connect up the glade file */
-	gpk_prefs_setup_policykit (prefs);
+#if defined(sun) && defined(__SVR4)
+	GpmControl *control = gpm_control_new ();
+	if (control) {
+		prefs->priv->can_cpufreq = gpm_control_is_user_privileged (control, "hal-power-cpu");
+		prefs->priv->can_cpufreq = 1;
+		prefs->priv->can_brightness = gpm_control_is_user_privileged (control, "hal-power-brightness");
+		g_object_unref (control);
+	} else {
+		prefs->priv->can_cpufreq = FALSE;
+		prefs->priv->can_brightness = FALSE;
+	}
 #endif
 
-	prefs->priv->glade_xml = glade_xml_new (GPM_DATA "/gpm-prefs.glade", NULL, NULL);
-	if (prefs->priv->glade_xml == NULL) {
-		g_error ("Cannot find 'gpm-prefs.glade'");
+
+	/* only enable cpufreq stuff if we have the hardware */
+	if (prefs->priv->hal_cpufreq) {
+		hal_gcpufreq_get_governors (prefs->priv->hal_cpufreq,
+					    &prefs->priv->cpufreq_types);
+	} else {
+		prefs->priv->cpufreq_types = LIBHAL_CPUFREQ_NOTHING;
+	}
+
+	prefs->priv->builder = gtk_builder_new ();
+	retval = gtk_builder_add_from_file (prefs->priv->builder, GPM_DATA "/gpm-prefs.ui", &error);
+	if (error) {
+		g_error ("Cannot find 'gpm-prefs.ui'");
 	}
 
-	main_window = glade_xml_get_widget (prefs->priv->glade_xml, "window_preferences");
+	main_window =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "dialog_preferences"));
 
 	/* Hide window first so that the dialogue resizes itself without redrawing */
 	gtk_widget_hide (main_window);
@@ -1112,11 +1378,11 @@
 	g_signal_connect (main_window, "delete_event",
 			  G_CALLBACK (gpm_prefs_delete_event_cb), prefs);
 
-	widget = glade_xml_get_widget (prefs->priv->glade_xml, "button_close");
+	widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "button_close"));
 	g_signal_connect (widget, "clicked",
 			  G_CALLBACK (gpm_prefs_close_cb), prefs);
 
-	widget = glade_xml_get_widget (prefs->priv->glade_xml, "button_help");
+	widget =  GTK_WIDGET (gtk_builder_get_object (prefs->priv->builder, "button_help"));
 	g_signal_connect (widget, "clicked",
 			  G_CALLBACK (gpm_prefs_help_cb), prefs);
 
@@ -1153,6 +1419,10 @@
 		g_object_unref (prefs->priv->screensaver);
 	}
 
+	if (prefs->priv->hal_cpufreq) {
+		g_object_unref (prefs->priv->hal_cpufreq);
+	}
+
 	G_OBJECT_CLASS (gpm_prefs_parent_class)->finalize (object);
 }
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-profile.h gnome-power-manager-2.24.4/src/gpm-profile.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-profile.h	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-profile.h	2020-04-05 16:08:10.000000000 +0000
@@ -34,7 +34,7 @@
 #define GPM_IS_PROFILE_CLASS(k)		(G_TYPE_CHECK_CLASS_TYPE ((k), GPM_TYPE_PROFILE))
 #define GPM_PROFILE_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GPM_TYPE_PROFILE, GpmProfileClass))
 
-#define GPM_PROFILE_GOOD_TRUST	40
+#define GPM_PROFILE_GOOD_TRUST	0
 
 typedef struct GpmProfilePrivate GpmProfilePrivate;
 
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-screensaver.c gnome-power-manager-2.24.4/src/gpm-screensaver.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-screensaver.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-screensaver.c	2020-04-05 16:08:10.000000000 +0000
@@ -29,6 +29,10 @@
 #include "gpm-conf.h"
 #include "gpm-screensaver.h"
 #include "egg-debug.h"
+#if defined(sun) && defined(__SVR4)
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#endif
 #include <libdbus-proxy.h>
 
 static void     gpm_screensaver_class_init (GpmScreensaverClass *klass);
@@ -239,6 +243,49 @@
 	guint sleepcount = 0;
 	DBusGProxy *proxy;
 
+#if defined(sun) && defined(__SVR4)
+	GError    *error = NULL;
+	char      *command;
+	GdkScreen *screen;
+	GtkWidget *invisible;
+
+	/* As per ARC requriement, use xdg-screensaver on Solaris */
+	command = g_strdup ("/usr/bin/xdg-screensaver lock");	
+	screen = gdk_screen_get_default ();
+
+	egg_debug ("Doing xdg-screensaver lock");
+	if (! g_spawn_command_line_async (command, &error)) {
+		g_warning ("Cannot lock screen: %s", error->message);
+		g_error_free (error);
+	}
+	g_free (command);
+
+	/* Make sure screen locking takes effect until both point 
+	 * and keyboard are grabbed successfully.
+	 */
+	invisible = gtk_invisible_new_for_screen (screen);
+	gtk_widget_show (invisible);
+	while (sleepcount++ < 50) {
+		egg_debug ("Try to determine if screen lock is active!");
+		if (gdk_pointer_grab (gtk_widget_get_window(invisible), 
+				TRUE, 
+				0,
+				NULL,
+				NULL,
+				GDK_CURRENT_TIME) 
+				== GDK_GRAB_ALREADY_GRABBED 
+		   && gdk_keyboard_grab (gtk_widget_get_window(invisible), FALSE, GDK_CURRENT_TIME)
+		  		== GDK_GRAB_ALREADY_GRABBED)
+			break;
+		else {
+			gdk_pointer_ungrab (GDK_CURRENT_TIME);
+			gdk_keyboard_ungrab (GDK_CURRENT_TIME);
+		}
+		g_usleep (1000 * 100);
+	} 
+	gtk_widget_destroy (invisible);
+	egg_debug ("Screen locking is sucessful!, sleepcount = %d", sleepcount);
+#else
 	g_return_val_if_fail (GPM_IS_SCREENSAVER (screensaver), FALSE);
 
 	proxy = dbus_proxy_get_proxy (screensaver->priv->gproxy);
@@ -265,6 +312,7 @@
 			break;
 		}
 	}
+#endif
 
 	return TRUE;
 }
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-session.c gnome-power-manager-2.24.4/src/gpm-session.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-session.c	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-session.c	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,288 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008-2009 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <dbus/dbus-glib.h>
+
+#include "gpm-session.h"
+#include "gpm-common.h"
+#include "egg-debug.h"
+#include "gpm-marshal.h"
+
+static void     gpm_session_finalize   (GObject		*object);
+
+#define GPM_SESSION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPM_TYPE_SESSION, GpmSessionPrivate))
+
+#define GPM_SESSION_MANAGER_SERVICE			"org.gnome.SessionManager"
+#define GPM_SESSION_MANAGER_PATH			"/org/gnome/SessionManager"
+#define GPM_SESSION_MANAGER_INTERFACE			"org.gnome.SessionManager"
+#define GPM_SESSION_MANAGER_CLIENT_PRIVATE_INTERFACE	"org.gnome.SessionManager.ClientPrivate"
+
+struct GpmSessionPrivate
+{
+	DBusGProxy		*proxy;
+	DBusGProxy		*proxy_client_private;
+};
+
+enum {
+	STOP,
+	QUERY_END_SESSION,
+	END_SESSION,
+	CANCEL_END_SESSION,
+	LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0 };
+static gpointer gpm_session_object = NULL;
+
+G_DEFINE_TYPE (GpmSession, gpm_session, G_TYPE_OBJECT)
+
+/**
+ * gpm_session_stop_cb:
+ **/
+static void
+gpm_session_stop_cb (DBusGProxy *proxy, GpmSession *session)
+{
+	egg_debug ("emitting ::stop()");
+	g_signal_emit (session, signals [STOP], 0);
+}
+
+/**
+ * gpm_session_query_end_session_cb:
+ **/
+static void
+gpm_session_query_end_session_cb (DBusGProxy *proxy, guint flags, GpmSession *session)
+{
+	egg_debug ("emitting ::query-end-session(%i)", flags);
+	g_signal_emit (session, signals [QUERY_END_SESSION], 0, flags);
+}
+
+/**
+ * gpm_session_end_session_cb:
+ **/
+static void
+gpm_session_end_session_cb (DBusGProxy *proxy, guint flags, GpmSession *session)
+{
+	egg_debug ("emitting ::end-session(%i)", flags);
+	g_signal_emit (session, signals [END_SESSION], 0, flags);
+}
+
+/**
+ * gpm_session_end_session_response:
+ **/
+gboolean
+gpm_session_end_session_response (GpmSession *session, gboolean is_okay, const gchar *reason)
+{
+	gboolean ret = FALSE;
+	GError *error = NULL;
+
+	g_return_val_if_fail (GPM_IS_SESSION (session), FALSE);
+	g_return_val_if_fail (session->priv->proxy_client_private != NULL, FALSE);
+
+	/* no gnome-session */
+	if (session->priv->proxy_client_private == NULL) {
+		egg_warning ("no gnome-session proxy");
+		goto out;
+	}
+
+	/* send response */
+	ret = dbus_g_proxy_call (session->priv->proxy_client_private, "EndSessionResponse", &error,
+				 G_TYPE_BOOLEAN, is_okay,
+				 G_TYPE_STRING, reason,
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+	if (!ret) {
+		egg_warning ("failed to send session response: %s", error->message);
+		g_error_free (error);
+		goto out;
+	}
+out:
+	return ret;
+}
+
+/**
+ * gpm_session_register_client:
+ **/
+gboolean
+gpm_session_register_client (GpmSession *session, const gchar *app_id, const gchar *client_startup_id)
+{
+	gboolean ret = FALSE;
+	gchar *client_id = NULL;
+	GError *error = NULL;
+	DBusGConnection *connection;
+
+	g_return_val_if_fail (GPM_IS_SESSION (session), FALSE);
+
+	/* no gnome-session */
+	if (session->priv->proxy == NULL) {
+		egg_warning ("no gnome-session");
+		goto out;
+	}
+
+	/* find out if this change altered the inhibited state */
+	ret = dbus_g_proxy_call (session->priv->proxy, "RegisterClient", &error,
+				 G_TYPE_STRING, app_id,
+				 G_TYPE_STRING, client_startup_id,
+				 G_TYPE_INVALID,
+				 DBUS_TYPE_G_OBJECT_PATH, &client_id,
+				 G_TYPE_INVALID);
+	if (!ret) {
+		egg_warning ("failed to register client '%s': %s", client_startup_id, error->message);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* get org.gnome.Session.ClientPrivate interface */
+	connection = dbus_g_bus_get (DBUS_BUS_SESSION, NULL);
+	session->priv->proxy_client_private = dbus_g_proxy_new_for_name_owner (connection, GPM_SESSION_MANAGER_SERVICE,
+									       client_id, GPM_SESSION_MANAGER_CLIENT_PRIVATE_INTERFACE, &error);
+	if (session->priv->proxy_client_private == NULL) {
+		egg_warning ("DBUS error: %s", error->message);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* get Stop */
+	dbus_g_proxy_add_signal (session->priv->proxy_client_private, "Stop", G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (session->priv->proxy_client_private, "Stop", G_CALLBACK (gpm_session_stop_cb), session, NULL);
+
+	/* get QueryEndSession */
+	dbus_g_proxy_add_signal (session->priv->proxy_client_private, "QueryEndSession", G_TYPE_UINT, G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (session->priv->proxy_client_private, "QueryEndSession", G_CALLBACK (gpm_session_query_end_session_cb), session, NULL);
+
+	/* get EndSession */
+	dbus_g_proxy_add_signal (session->priv->proxy_client_private, "EndSession", G_TYPE_UINT, G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (session->priv->proxy_client_private, "EndSession", G_CALLBACK (gpm_session_end_session_cb), session, NULL);
+
+	egg_debug ("registered startup '%s' to client id '%s'", client_startup_id, client_id);
+out:
+	g_free (client_id);
+	return ret;
+}
+
+/**
+ * gpm_session_class_init:
+ * @klass: This class instance
+ **/
+static void
+gpm_session_class_init (GpmSessionClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	object_class->finalize = gpm_session_finalize;
+	g_type_class_add_private (klass, sizeof (GpmSessionPrivate));
+
+	signals [STOP] =
+		g_signal_new ("stop",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (GpmSessionClass, stop),
+			      NULL, NULL, g_cclosure_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0);
+	signals [QUERY_END_SESSION] =
+		g_signal_new ("query-end-session",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (GpmSessionClass, query_end_session),
+			      NULL, NULL, g_cclosure_marshal_VOID__UINT,
+			      G_TYPE_NONE, 1, G_TYPE_UINT);
+	signals [END_SESSION] =
+		g_signal_new ("end-session",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (GpmSessionClass, end_session),
+			      NULL, NULL, g_cclosure_marshal_VOID__UINT,
+			      G_TYPE_NONE, 1, G_TYPE_UINT);
+	signals [CANCEL_END_SESSION] =
+		g_signal_new ("cancel-end-session",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (GpmSessionClass, cancel_end_session),
+			      NULL, NULL, g_cclosure_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0);
+}
+
+/**
+ * gpm_session_init:
+ * @session: This class instance
+ **/
+static void
+gpm_session_init (GpmSession *session)
+{
+	DBusGConnection *connection;
+	GError *error = NULL;
+
+	session->priv = GPM_SESSION_GET_PRIVATE (session);
+	session->priv->proxy_client_private = NULL;
+
+	connection = dbus_g_bus_get (DBUS_BUS_SESSION, NULL);
+
+	/* get org.gnome.Session interface */
+	session->priv->proxy = dbus_g_proxy_new_for_name_owner (connection, GPM_SESSION_MANAGER_SERVICE,
+								GPM_SESSION_MANAGER_PATH,
+								GPM_SESSION_MANAGER_INTERFACE, &error);
+	if (session->priv->proxy == NULL) {
+		egg_warning ("DBUS error: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+}
+
+/**
+ * gpm_session_finalize:
+ * @object: This class instance
+ **/
+static void
+gpm_session_finalize (GObject *object)
+{
+	GpmSession *session;
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GPM_IS_SESSION (object));
+
+	session = GPM_SESSION (object);
+	session->priv = GPM_SESSION_GET_PRIVATE (session);
+
+	g_object_unref (session->priv->proxy);
+	if (session->priv->proxy_client_private != NULL)
+		g_object_unref (session->priv->proxy_client_private);
+
+	G_OBJECT_CLASS (gpm_session_parent_class)->finalize (object);
+}
+
+/**
+ * gpm_session_new:
+ * Return value: new GpmSession instance.
+ **/
+GpmSession *
+gpm_session_new (void)
+{
+	if (gpm_session_object != NULL) {
+		g_object_ref (gpm_session_object);
+	} else {
+		gpm_session_object = g_object_new (GPM_TYPE_SESSION, NULL);
+		g_object_add_weak_pointer (gpm_session_object, &gpm_session_object);
+	}
+	return GPM_SESSION (gpm_session_object);
+}
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-session.h gnome-power-manager-2.24.4/src/gpm-session.h
--- ../g1/gnome-power-manager-2.24.4/src/gpm-session.h	1969-12-31 16:00:00.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-session.h	2020-04-05 16:08:10.000000000 +0000
@@ -0,0 +1,70 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __GPM_SESSION_H
+#define __GPM_SESSION_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define GPM_TYPE_SESSION		(gpm_session_get_type ())
+#define GPM_SESSION(o)			(G_TYPE_CHECK_INSTANCE_CAST ((o), GPM_TYPE_SESSION, GpmSession))
+#define GPM_SESSION_CLASS(k)		(G_TYPE_CHECK_CLASS_CAST((k), GPM_TYPE_SESSION, GpmSessionClass))
+#define GPM_IS_SESSION(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), GPM_TYPE_SESSION))
+#define GPM_IS_SESSION_CLASS(k)		(G_TYPE_CHECK_CLASS_TYPE ((k), GPM_TYPE_SESSION))
+#define GPM_SESSION_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GPM_TYPE_SESSION, GpmSessionClass))
+
+typedef struct GpmSessionPrivate GpmSessionPrivate;
+
+typedef struct
+{
+	GObject			 parent;
+	GpmSessionPrivate	*priv;
+} GpmSession;
+
+typedef struct
+{
+	GObjectClass	parent_class;
+	/* just exit */
+	void		(* stop)			(GpmSession	*session);
+	/* reply with EndSessionResponse */
+	void		(* query_end_session)		(GpmSession	*session,
+							 guint		 flags);
+	/* reply with EndSessionResponse */
+	void		(* end_session)			(GpmSession	*session,
+							 guint		 flags);
+	void		(* cancel_end_session)		(GpmSession	*session);
+} GpmSessionClass;
+
+GType		 gpm_session_get_type			(void);
+GpmSession	*gpm_session_new			(void);
+
+gboolean	 gpm_session_register_client		(GpmSession	*session,
+							 const gchar	*app_id,
+							 const gchar	*client_startup_id);
+gboolean	 gpm_session_end_session_response	(GpmSession	*session,
+							 gboolean	 is_okay,
+							 const gchar	*reason);
+
+G_END_DECLS
+
+#endif	/* __GPM_SESSION_H */
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-statistics-core.c gnome-power-manager-2.24.4/src/gpm-statistics-core.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-statistics-core.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-statistics-core.c	2020-04-05 16:08:10.000000000 +0000
@@ -24,7 +24,6 @@
 #include <glib.h>
 #include <glib/gi18n.h>
 
-#include <glade/glade.h>
 #include <gtk/gtk.h>
 #include <dbus/dbus-glib.h>
 #include <math.h>
@@ -70,7 +69,7 @@
 
 struct GpmStatisticsPrivate
 {
-	GladeXML		*glade_xml;
+	GtkBuilder		*builder;
 	GtkWidget		*graph_widget;
 	GpmConf			*conf;
 	DbusProxy		*gproxy;
@@ -191,7 +190,7 @@
 
 /**
  * gpm_graph_widget_custom_handler:
- * @xml: The glade file we are reading.
+ * @builder: The glade file we are reading.
  * @func_name: The function name to create the object
  *
  * Handler for libglade to provide interface with a pointer
@@ -199,7 +198,7 @@
  * Return value: The custom widget.
  **/
 static GtkWidget *
-gpm_graph_widget_custom_handler (GladeXML *xml,
+gpm_graph_widget_custom_handler (GtkBuilder *builder,
 			  gchar *func_name, gchar *name,
 			  gchar *string1, gchar *string2,
 			  gint int1, gint int2,
@@ -281,8 +280,10 @@
 gpm_statistics_refresh_events (GpmStatistics *statistics)
 {
 	gpm_statistics_get_events (statistics);
+	/*
 	gpm_graph_widget_events_add (GPM_GRAPH_WIDGET (statistics->priv->graph_widget),
 				     statistics->priv->events);
+	*/
 }
 
 /**
@@ -303,9 +304,9 @@
 
 	if (checked == FALSE) {
 		/* remove the dots from the graph */
-		gpm_graph_widget_enable_events (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), FALSE);
+		//gpm_graph_widget_enable_events (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), FALSE);
 		/* disable legend  */
-		gpm_graph_widget_enable_legend (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), FALSE);
+		//gpm_graph_widget_enable_legend (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), FALSE);
 		return;
 	}
 
@@ -313,10 +314,10 @@
 	gpm_statistics_refresh_events (statistics);
 
 	/* only enable the dots if the checkbox is checked */
-	gpm_graph_widget_enable_events (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), TRUE);
+	//gpm_graph_widget_enable_events (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), TRUE);
 
 	/* enable legend  */
-	gpm_graph_widget_enable_legend (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), TRUE);
+	//gpm_graph_widget_enable_legend (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), TRUE);
 }
 
 /**
@@ -332,8 +333,8 @@
 	/* save to gconf so we open next time with the correct setting */
 	gpm_conf_get_bool (statistics->priv->conf, GPM_CONF_STATS_SHOW_AXIS_LABELS, &show);
 
-	widget1 = glade_xml_get_widget (statistics->priv->glade_xml, "label_x_axis");
-	widget2 = glade_xml_get_widget (statistics->priv->glade_xml, "label_y_axis");
+	widget1 = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "label_x_axis"));
+	widget2 = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "label_y_axis"));
 
 	if (show == FALSE) {
 		gtk_widget_hide (widget1);
@@ -493,8 +494,13 @@
 {
 	GError *error = NULL;
 	gboolean ret;
+	/*
 	GpmGraphWidgetAxisType axis_type_x;
 	GpmGraphWidgetAxisType axis_type_y;
+	*/
+	gchar axis_type_x;
+	gchar axis_type_y;
+
 	gchar *axis_type_x_text;
 	gchar *axis_type_y_text;
 	DBusGProxy *proxy;
@@ -554,7 +560,7 @@
 	const gchar *desc;
 
 	/* clear the data key */
-	gpm_graph_widget_key_data_clear (GPM_GRAPH_WIDGET (statistics->priv->graph_widget));
+	//gpm_graph_widget_key_data_clear (GPM_GRAPH_WIDGET (statistics->priv->graph_widget));
 
 	for (i=0; i< ptr_data_array->len; i++) {
 		gva = (GValueArray *) g_ptr_array_index (ptr_data_array, i);
@@ -571,7 +577,7 @@
 	g_ptr_array_free (ptr_data_array, TRUE);
 
 	/* clear the events key */
-	gpm_graph_widget_key_event_clear (GPM_GRAPH_WIDGET (statistics->priv->graph_widget));
+	//gpm_graph_widget_key_event_clear (GPM_GRAPH_WIDGET (statistics->priv->graph_widget));
 
 	/* process events key */
 	for (i=0; i< ptr_event_array->len; i++) {
@@ -588,7 +594,7 @@
 		gv = g_value_array_get_nth (gva, 3);
 		desc = g_value_get_string (gv);
 		/* add to the data key */
-		gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), id, colour, shape, desc);
+		//gpm_graph_widget_key_event_add (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), id, colour, shape, desc);
 		g_value_unset (gv);
 		g_value_array_free (gva);
 	}
@@ -598,11 +604,15 @@
 	egg_debug ("graph type '%s' mapped to y-axis '%s'", type, axis_type_y_text);
 
 	/* convert the string types to enumerated values */
+	/*
 	axis_type_x = gpm_graph_widget_string_to_axis_type (axis_type_x_text);
 	axis_type_y = gpm_graph_widget_string_to_axis_type (axis_type_y_text);
+	*/
+	axis_type_x = axis_type_x_text;
+	axis_type_y = axis_type_y_text;
 
-	gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), axis_type_x);
-	gpm_graph_widget_set_axis_type_y (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), axis_type_y);
+	//gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), axis_type_x);
+	//gpm_graph_widget_set_axis_type_y (GPM_GRAPH_WIDGET (statistics->priv->graph_widget), axis_type_y);
 
 	return TRUE;
 }
@@ -635,9 +645,11 @@
 		gpm_array_float_free (result);
 	}
 
+	/*
 	gpm_graph_widget_data_clear (GPM_GRAPH_WIDGET (statistics->priv->graph_widget));
 	gpm_graph_widget_data_add (GPM_GRAPH_WIDGET (statistics->priv->graph_widget),
 				   statistics->priv->data);
+	*/
 
 	gtk_widget_hide (GTK_WIDGET (statistics->priv->graph_widget));
 	gtk_widget_show (GTK_WIDGET (statistics->priv->graph_widget));
@@ -650,7 +662,7 @@
 	gchar *value;
 	gchar *type = NULL;
 
-	value = gtk_combo_box_get_active_text (GTK_COMBO_BOX (widget));
+	value = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX (widget));
 	if (value == NULL) {
 		egg_debug ("no graph types available");
 		return;
@@ -742,7 +754,7 @@
 		if (strcmp (type, saved) == 0) {
 			pos = count;
 		}
-		gtk_combo_box_append_text (GTK_COMBO_BOX (widget), type_localized);
+		gtk_combo_box_text_append_text (GTK_COMBO_BOX (widget), type_localized);
 		count++;
 	}
 	gpm_statistics_free_list_strings (list);
@@ -778,7 +790,7 @@
 
 	g_return_if_fail (GPM_IS_STATISTICS (statistics));
 
-	widget = glade_xml_get_widget (statistics->priv->glade_xml, "window_graph");
+	widget = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "window_graph"));
 	gtk_window_present (GTK_WINDOW (widget));
 }
 
@@ -789,6 +801,8 @@
 static void
 gpm_statistics_init (GpmStatistics *statistics)
 {
+	guint 	retval;
+	GError	*error = NULL;
 	GtkWidget *main_window;
 	GtkWidget *widget;
 	gboolean   checked;
@@ -799,8 +813,6 @@
 	g_signal_connect (statistics->priv->conf, "value-changed",
 			  G_CALLBACK (conf_key_changed_cb), statistics);
 
-	glade_set_custom_handler (gpm_graph_widget_custom_handler, statistics);
-
 	statistics->priv->gproxy = dbus_proxy_new ();
 	dbus_proxy_assign (statistics->priv->gproxy,
 			  DBUS_PROXY_SESSION,
@@ -817,9 +829,10 @@
 	statistics->priv->events = gpm_array_new ();
 	statistics->priv->data = gpm_array_new ();
 
-	statistics->priv->glade_xml = glade_xml_new (GPM_DATA "/gpm-graph.glade", NULL, NULL);
+	statistics->priv->builder = gtk_builder_new();
+	retval = gtk_builder_add_from_file (statistics->priv->builder, GPM_DATA "/gpm-graph.ui", &error);
 
-	main_window = glade_xml_get_widget (statistics->priv->glade_xml, "window_graph");
+	main_window = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "window_graph"));
 
 	/* Hide window first so that the dialogue resizes itself without redrawing */
 	gtk_widget_hide (main_window);
@@ -830,28 +843,28 @@
 	g_signal_connect (main_window, "delete_event",
 			  G_CALLBACK (gpm_statistics_delete_event_cb), statistics);
 
-	widget = glade_xml_get_widget (statistics->priv->glade_xml, "button_close");
+	widget = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "button_close"));
 	g_signal_connect (widget, "clicked",
 			  G_CALLBACK (gpm_statistics_close_cb), statistics);
 
-	widget = glade_xml_get_widget (statistics->priv->glade_xml, "button_help");
+	widget = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "button_help"));
 	g_signal_connect (widget, "clicked",
 			  G_CALLBACK (gpm_statistics_help_cb), statistics);
 
-	widget = glade_xml_get_widget (statistics->priv->glade_xml, "custom_graph");
+	widget = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "custom_graph"));
 	gtk_widget_set_size_request (widget, 600, 300);
 	statistics->priv->graph_widget = widget;
-	gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (widget), GPM_GRAPH_WIDGET_TYPE_TIME);
-	gpm_graph_widget_set_axis_type_y (GPM_GRAPH_WIDGET (widget), GPM_GRAPH_WIDGET_TYPE_PERCENTAGE);
+	//gpm_graph_widget_set_axis_type_x (GPM_GRAPH_WIDGET (widget), GPM_GRAPH_WIDGET_TYPE_TIME);
+	//gpm_graph_widget_set_axis_type_y (GPM_GRAPH_WIDGET (widget), GPM_GRAPH_WIDGET_TYPE_PERCENTAGE);
 
 	/* FIXME: There's got to be a better way than this */
 	gtk_widget_hide (GTK_WIDGET (widget));
 	gtk_widget_show (GTK_WIDGET (widget));
 
-	widget = glade_xml_get_widget (statistics->priv->glade_xml, "combobox_type");
+	widget = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "combobox_type"));
 	gpm_statistics_populate_graph_types (statistics, widget);
 
-	widget = glade_xml_get_widget (statistics->priv->glade_xml, "checkbutton_events");
+	widget = GTK_WIDGET (gtk_builder_get_object (statistics->priv->builder, "checkbutton_events"));
 	gpm_conf_get_bool (statistics->priv->conf, GPM_CONF_STATS_SHOW_EVENTS, &checked);
 	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), checked);
 	g_signal_connect (widget, "clicked",
diff -urN ../g1/gnome-power-manager-2.24.4/src/gpm-tray-icon.c gnome-power-manager-2.24.4/src/gpm-tray-icon.c
--- ../g1/gnome-power-manager-2.24.4/src/gpm-tray-icon.c	2008-09-04 03:05:15.000000000 +0000
+++ gnome-power-manager-2.24.4/src/gpm-tray-icon.c	2020-04-05 16:08:10.000000000 +0000
@@ -38,7 +38,6 @@
 
 #include <glib/gi18n.h>
 #include <gtk/gtk.h>
-#include <gtk/gtkstatusicon.h>
 
 #include "gpm-conf.h"
 #include "gpm-control.h"
@@ -161,7 +160,7 @@
 	g_return_val_if_fail (GPM_IS_TRAY_ICON (icon), FALSE);
 	g_return_val_if_fail (tooltip != NULL, FALSE);
 
-	gtk_status_icon_set_tooltip (GTK_STATUS_ICON (icon->priv->status_icon), tooltip);
+	gtk_status_icon_set_tooltip_text (GTK_STATUS_ICON (icon->priv->status_icon), tooltip);
 	return TRUE;
 }
 
@@ -259,21 +258,6 @@
 }
 
 /**
- * gpm_tray_icon_show_statistics_cb:
- * @action: A valid GtkAction
- * @icon: This TrayIcon class instance
- **/
-static void
-gpm_tray_icon_show_statistics_cb (GtkMenuItem *item, gpointer data)
-{
-	const gchar *command = "gnome-power-statistics";
-
-	if (g_spawn_command_line_async (command, NULL) == FALSE) {
-		egg_warning ("Couldn't execute command: %s", command);
-	}
-}
-
-/**
  * gpm_tray_icon_show_preferences_cb:
  * @action: A valid GtkAction
  * @icon: This TrayIcon class instance
@@ -281,7 +265,7 @@
 static void
 gpm_tray_icon_show_preferences_cb (GtkMenuItem *item, gpointer data)
 {
-	const gchar *command = "gnome-power-preferences";
+	const gchar *command = "mate-power-preferences";
 
 	if (g_spawn_command_line_async (command, NULL) == FALSE) {
 		egg_warning ("Couldn't execute command: %s", command);
@@ -289,17 +273,6 @@
 }
 
 /**
- * gpm_tray_icon_show_help_cb:
- * @action: A valid GtkAction
- * @icon: This TrayIcon class instance
- **/
-static void
-gpm_tray_icon_show_help_cb (GtkMenuItem *item, gpointer data)
-{
-	gpm_help_display (NULL);
-}
-
-/**
  * gpm_tray_icon_show_about_cb:
  * @action: A valid GtkAction
  * @icon: This TrayIcon class instance
@@ -440,24 +413,28 @@
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 
 	/* Statistics */
+	/*
 	item = gtk_image_menu_item_new_with_mnemonic (_("Power _History"));
 	image = gtk_image_new_from_icon_name (GPM_STOCK_STATISTICS, GTK_ICON_SIZE_MENU);
 	gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), image);
 	g_signal_connect (G_OBJECT (item), "activate",
 			  G_CALLBACK (gpm_tray_icon_show_statistics_cb), icon);
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
+	*/
 
 	/* Separator for HIG? */
 	item = gtk_separator_menu_item_new ();
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 
 	/* Help */
+	/*
 	item = gtk_image_menu_item_new_with_mnemonic (_("_Help"));
 	image = gtk_image_new_from_icon_name (GTK_STOCK_HELP, GTK_ICON_SIZE_MENU);
 	gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), image);
 	g_signal_connect (G_OBJECT (item), "activate",
 			  G_CALLBACK (gpm_tray_icon_show_help_cb), icon);
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
+	*/
 
 	/* About */
 	item = gtk_image_menu_item_new_with_mnemonic (_("_About"));
